!-----------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! For further details please refer to the file LICENCE which you should have
! received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief An algorithm for COSMIC transport scheme on the cubed-sphere.
!> @details The algorithm iterates forwards in time and transports the density
!>          field using the COSMIC advection scheme. This routine updates density
!>          for horizontal transport only.
module cusph_cosmic_transport_alg_mod

  use constants_mod,                     only: r_def, i_def, LARGE_REAL_NEGATIVE
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use finite_element_config_mod,         only: element_order
  use fs_continuity_mod,                 only: W1, W2, W3
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE
  use geometric_constants_mod,           only: get_coordinates_xyz, &
                                               get_coordinates, &
                                               get_panel_id
  use cusph_split_transport_alg_mod,     only: cusph_split_transport_alg
  use cusph_fv_density_update_alg_mod,   only: cusph_fv_density_update_alg
  use flux_direction_mod,                only: x_direction, y_direction
  use initial_streamfunc_kernel_mod,     only: initial_streamfunc_kernel_type
  use initial_u_kernel_mod,              only: initial_u_kernel_type
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,      only: quadrature_rule_gaussian_type
  use mass_matrix_solver_alg_mod,        only: mass_matrix_solver_alg
  use strong_curl_kernel_mod,            only: strong_curl_kernel_type
  use base_mesh_config_mod,              only: geometry, geometry_spherical
  use initial_wind_config_mod,           only: profile,                         &
                                               profile_sbr_streamfunction,      &
                                               profile_dcmip301_streamfunction, &
                                               profile_div_free_reversible,     &
                                               profile_eternal_fountain,        &
                                               profile_rotational,              &
                                               sbr_angle_lat, sbr_angle_lon,    &
                                               u0, v0

  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type ) :: u_n, u_np1
  type( field_type ) :: r_u

  public :: set_winds
  public :: cusph_cosmic_transport_step

contains

  !> @brief Routine which analytically defines the winds each timestep.
  !> @details Wind field is defined each timestep for the transport only test
  !>          cases which are run within the transport mini-app.
  !> @param[in,out]   u         3D wind field
  !> @param[in]       mesh_id   Mesh id of mesh on which the model runs
  !> @param[in]       timestep  Timestep
  !> @param[in]       dt        The model timestep length
subroutine set_winds(u, mesh_id, timestep, dt)

    implicit none

    integer(i_def),   intent(in)    :: mesh_id
    type(field_type), intent(inout) :: u
    integer(i_def),   intent(in)    :: timestep
    real(r_def),      intent(in)    :: dt

    type(function_space_type), pointer    :: w1_fs   => null()
    type(function_space_type), pointer    :: w2_fs   => null()
    type(function_space_type), pointer    :: w3_fs   => null()
    type( quadrature_xyoz_type )          :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule

    type( field_type ), pointer           :: chi_xyz(:) => null()
    type( field_type ), pointer           :: chi_sph(:) => null()
    type( field_type ), pointer           :: panel_id => null()
    real(r_def)                           :: time
    type(field_type)                      :: psi, r_psi

    w1_fs   => function_space_collection%get_fs( mesh_id, element_order, W1 )
    w2_fs   => function_space_collection%get_fs( mesh_id, element_order, W2 )
    w3_fs   => function_space_collection%get_fs( mesh_id, element_order, W3 )

    call u_n%initialise( vector_space = w2_fs )
    call u_np1%initialise( vector_space = w2_fs )
    call r_u%initialise( vector_space = w2_fs )

    qr = quadrature_xyoz_type(element_order+2, quadrature_rule)
    chi_xyz => get_coordinates_xyz(mesh_id)
    chi_sph => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)

    time = dt*real(timestep,r_def)

    if ( profile == profile_sbr_streamfunction .or.  &
         profile == profile_dcmip301_streamfunction .or. &
         profile == profile_eternal_fountain .or. &
         profile == profile_div_free_reversible .or. &
         profile == profile_rotational ) then

      call log_event( "COSMIC: Initialising winds from stream function", LOG_LEVEL_INFO )
      call psi%initialise( vector_space = w1_fs )
      call r_psi%initialise( vector_space =  w1_fs )
      call invoke( name = "initialise_streamfunction", &
                   setval_c(psi, 0.0_r_def),           &
                   setval_c(r_psi, 0.0_r_def),         &
                   initial_streamfunc_kernel_type(r_psi, chi_sph, panel_id, &
                                                  time, sbr_angle_lat,      &
                                                  sbr_angle_lon, u0, v0, qr) )
      ! We do not want to force zero stream function at boundaries
      call mass_matrix_solver_alg(psi, r_psi, bc_flag=.false.)
      call invoke( name = "get_u_from_curl_of_psi", &
                   strong_curl_kernel_type(u, psi) )
      ! Prevent any flux out from the domain
      ! However for spherical domains this could prevent the resulting
      ! wind from being divergence-free, so only do this for Cartesian domains
      if (geometry /= geometry_spherical) then
        call invoke( name = "apply_bcs_to_u", &
                     enforce_bc_kernel_type( u ) )
      end if

    else
      call log_event( "COSMIC: Initialising winds", LOG_LEVEL_INFO )
      call invoke( name = "initialise_u",                     &
                   setval_c(u,   0.0_r_def),                  &
                   setval_c(r_u, 0.0_r_def),                  &
                   initial_u_kernel_type(r_u, chi_sph, panel_id, time, qr), &
                   enforce_bc_kernel_type( r_u ) )
      call mass_matrix_solver_alg(u, r_u)
    end if

    call invoke( setval_X(u_n, u), &
                 setval_X(u_np1, u) )

    nullify(w2_fs, w3_fs, chi_xyz, chi_sph, panel_id)

  end subroutine set_winds

  !> @brief An algorithm for testing the COSMIC transport scheme.
  !> @details The algorithm iterates forwards in time and transports the density
  !>          field using the COSMIC advection scheme. This routine advects in
  !>          horizontal direction only. The wind profile is defined analytically.
  !> @param[in,out] increment         Density increment
  !> @param[in]     rho               Density field
  !> @param[in]     dep_pts_x         Departure points in the x direction
  !> @param[in]     dep_pts_y         Departure points in the y direction
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     cell_orientation  Orientation of halo cells
  !> @param[in]     dt                The model timestep length
  subroutine cusph_cosmic_transport_step( increment,          &
                                          rho,                &
                                          dep_pts_x,          &
                                          dep_pts_y,          &
                                          detj_at_w2,         &
                                          cell_orientation,   &
                                          dt )

    implicit none

    type(field_type),    intent(inout) :: increment
    type(field_type),    intent(in)    :: rho
    type(field_type),    intent(in)    :: dep_pts_x
    type(field_type),    intent(in)    :: dep_pts_y
    type(field_type),    intent(in)    :: detj_at_w2
    type(field_type),    intent(in)    :: cell_orientation
    real(r_def),         intent(in)    :: dt

    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()

    type( field_type ) :: increment_x, increment_y
    type( field_type ) :: mass_flux_x, mass_flux_y

    w2_fs => dep_pts_x%get_function_space()
    w3_fs => rho%get_function_space()

    call mass_flux_x%initialise( vector_space = w2_fs )
    call mass_flux_y%initialise( vector_space = w2_fs )
    call increment_x%initialise( vector_space = w3_fs )
    call increment_y%initialise( vector_space = w3_fs )

    ! Call algorithm to calculate mass fluxes in x and y direction using COSMIC scheme
    call cusph_split_transport_alg( rho, cell_orientation,             &
                                    mass_flux_x, mass_flux_y, dep_pts_x, &
                                    dep_pts_y, dt )

    ! Calculate divergence (increment) in the x direction
    call cusph_fv_density_update_alg( increment_x, mass_flux_x, mass_flux_y,     &
                                      cell_orientation, x_direction, detj_at_w2)

    ! Calculate divergence (increment) in the y direction
    call cusph_fv_density_update_alg( increment_y, mass_flux_x, mass_flux_y,     &
                                      cell_orientation, y_direction, detj_at_w2)

    call invoke( X_plus_Y( increment, increment_x, increment_y ) )

    nullify(w2_fs, w3_fs)

  end subroutine cusph_cosmic_transport_step

end module cusph_cosmic_transport_alg_mod
