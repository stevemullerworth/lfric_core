!-----------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! For further details please refer to the file LICENCE which you should have
! received as part of this distribution.
!-----------------------------------------------------------------------------
!>@brief Vertical preconditioner for the pressure equation.
!>
!>
!>@details This preconditioner calculates \f$y = Px = H_z^{-1}x\f$ where
!> \f$H_z\f$ is the vertical part of the Helmholtz operator (scaled by the
!> inverse pressure mass matrix), i.e.
!>
!> \f[
!> H_z = 1 + M_3^{-1}\left(\omega_c^2 \Delta_h 
!>                       + \omega_c^2/(1+\omega_N^2) D_z M_{u,z,inv} D_z^T)
!>                   \right)
!> \f]
!> and \f$\Delta_h = \diag(D_h M_{u,h,inv} D_h^T) \f$. The lumped inverse mass
!> matrices are given by \f$M_{u,*,inv}\f$.
!> 

module gw_pressure_precon_alg_mod
  use vector_mod,                      only : abstract_vector_type
  use field_vector_mod,                only : field_vector_type
  use preconditioner_mod,              only : abstract_preconditioner_type
  use log_mod,                         only : log_event, &
                                              LOG_LEVEL_INFO, &
                                              LOG_LEVEL_ERROR, &
                                              log_scratch_space
  use constants_mod,                   only : i_def, r_def
  use operator_mod,                    only : operator_type,             &
                                              columnwise_operator_type

  ! Columnwise operator kernels                                                
  use columnwise_op_app_kernel_mod,    only : columnwise_op_app_kernel_type
  use columnwise_op_appinv_kernel_mod, only : columnwise_op_appinv_kernel_type
            
  implicit none

  type, public, extends(abstract_preconditioner_type) :: gw_pressure_preconditioner_type

     !> Constant \f$\omega_c^2 = (\alpha\Delta t c)^2\f$
     real(kind=r_def) :: omega2_c
     !> Constant \f$\omega_N^2 = (\alpha\Delta t N)^2\f$
     real(kind=r_def) :: omega2_N
     !> vertical Helmholtz operator
     type(columnwise_operator_type) :: Hz_cma

   contains
     ! Build the vertical part \f$H_z\f$ of the Helmholtz matrix
     procedure, private :: build_Hz
     ! overide the (abstract interface) for application of a preconditioner
     ! \f$y = P.x\f$
     procedure, public :: apply => apply_gw_pressure_preconditioner
     procedure, private :: apply_gw_pressure_preconditioner

     final :: destroy_gw_pressure_preconditioner

  end type gw_pressure_preconditioner_type

  ! Overload the default structure constructor                                 
  interface gw_pressure_preconditioner_type
     module procedure gw_pressure_preconditioner_constructor
  end interface

contains

  !> @brief Construct a <code> gw_pressure_preconditioner_type</code> object
  !>
  !> @return self the constructed preconditioner object
  function gw_pressure_preconditioner_constructor() result(self)

    use log_mod,                           only : log_event, LOG_LEVEL_INFO
    use timestepping_config_mod,           only: dt, alpha 
    use gravity_wave_constants_config_mod, only: cs_square
    use initial_temperature_config_mod,    only: bvf_square  
    implicit none

    type(gw_pressure_preconditioner_type)  :: self

    call log_event( 'Constructing pressure preconditioner...', &
         LOG_LEVEL_INFO )

    ! set scaling constants 
    self%omega2_c = alpha**2*dt**2*cs_square
    self%omega2_N = alpha**2*dt**2*bvf_square

    call self%build_Hz()

    call log_event( 'done', LOG_LEVEL_INFO )

  end function gw_pressure_preconditioner_constructor

  !> @brief Build the vertical Helmholtz matrix \f$H_z\f$ in CMA representation
  subroutine build_Hz(self)

    use runtime_constants_mod,       only : get_div_v,                 &
                                            get_div_h,                 &
                                            get_mass_matrix,           &
                                            w3_id,                     &
                                            w3inv_id,                  &
                                            w2h_id,                    &
                                            w2v_id 
    use transpose_matrix_kernel_mod, only : transpose_matrix_kernel_type
    use psykal_lite_mod,             only : invoke_enforce_operator_bc_kernel_type

    use columnwise_op_asm_kernel_mod,           only : columnwise_op_asm_kernel_type
    use columnwise_op_asm_diag_hmht_kernel_mod, only : columnwise_op_asm_diag_hmht_kernel_type
    use columnwise_op_mul_kernel_mod,           only : columnwise_op_mul_kernel_type
    use columnwise_op_scaledadd_kernel_mod,     only : columnwise_op_scaledadd_kernel_type
    use columnwise_op_asm_m2v_lumped_inv_kernel_mod, only : columnwise_op_asm_m2v_lumped_inv_kernel_type

    implicit none

    ! Instance of type
    class(gw_pressure_preconditioner_type), intent(inout)    :: self

    ! Pointers to mass matrices and derivative operators
    type(operator_type), pointer :: mm_w3
    type(operator_type), pointer :: mm_w3_inv
    type(operator_type), pointer :: mm_w2v_noBC
    type(operator_type), pointer :: mm_w2h
    type(operator_type), pointer :: div_v
    type(operator_type), pointer :: div_h
    ! Need a copy of vertical velocity matrix to enforce boundary conditions
    type(operator_type) :: mm_w2v
    type(operator_type) :: grad_v
    ! CMA representation of vertical weak derivatives, mass matrix and
    ! temporary matrices
    type(columnwise_operator_type) :: div_v_cma
    type(columnwise_operator_type) :: grad_v_cma
    type(columnwise_operator_type) :: mm_w3_cma
    type(columnwise_operator_type) :: mm_w3_inv_cma
    type(columnwise_operator_type) :: mm_w2v_cma
    type(columnwise_operator_type) :: mm_w2v_inv_diag_cma
    type(columnwise_operator_type) :: diag_DhMDht_cma
    type(columnwise_operator_type) :: tmp_1, tmp_2, tmp_3, tmp_4
    ! Scaling constants for invoke calls
    real(kind=r_def) :: alpha, beta

    ! Set pointers to vertical operators
    div_v => get_div_v()
    grad_v = operator_type( div_v%get_fs_from(), div_v%get_fs_to() )
    div_h => get_div_h()
    mm_w3 => get_mass_matrix(w3_id)
    mm_w3_inv => get_mass_matrix(w3inv_id)
    ! Take a copy of the vertical mass matrix since we need to apply the BCs
    mm_w2v_noBC => get_mass_matrix(w2v_id)
    mm_w2v = mm_w2v_noBC%deep_copy() 
    ! Now apply BCs
    call invoke_enforce_operator_bc_kernel_type( mm_w2v )
    ! Get horizontal velocity mass matrix
    mm_w2h => get_mass_matrix(w2h_id)
    
    ! Construct weak gradient as transpose of divergence
    call invoke( transpose_matrix_kernel_type( div_v, grad_v ) )

    ! Build individual CMA operators
    mm_w3_cma = columnwise_operator_type( mm_w3%get_fs_to(), &
                                          mm_w3%get_fs_from() )
    mm_w3_inv_cma = columnwise_operator_type( mm_w3_inv%get_fs_to(), &
                                              mm_w3_inv%get_fs_from() )
    mm_w2v_cma = columnwise_operator_type( mm_w2v%get_fs_to(), &
                                           mm_w2v%get_fs_from() )
    div_v_cma = columnwise_operator_type( div_v%get_fs_to(), &
                                          div_v%get_fs_from() )
    grad_v_cma  = columnwise_operator_type( grad_v%get_fs_to(), &
                                            grad_v%get_fs_from() )
    mm_w2v_inv_diag_cma = columnwise_operator_type( mm_w2v%get_fs_to(),   &
                                                    mm_w2v%get_fs_from(), &
                                                    1, 1, 0, 0)
    diag_DhMDht_cma = columnwise_operator_type( mm_w3%get_fs_to(), &
                                                mm_w3%get_fs_from() )
    
    call invoke(                                                       &
                 ! Pressure mass matrix M_3
                 columnwise_op_asm_kernel_type( mm_w3,                 &
                                                mm_w3_cma ),           &
                 ! Inverse mass matrix M_3
                 columnwise_op_asm_kernel_type( mm_w3_inv,             &
                                                mm_w3_inv_cma ),       &
                 ! Vertical divergence D_z
                 columnwise_op_asm_kernel_type( div_v,                 &
                                                div_v_cma ),           &
                 ! Weak vertical gradient D_z^T
                 columnwise_op_asm_kernel_type( grad_v,                &
                                                grad_v_cma ),          &
                 ! Lumped inverse vertical velocity mass matrix M_{u,z,inv}
                 columnwise_op_asm_m2v_lumped_inv_kernel_type( mm_w2v, &
                                                               mm_w2v_inv_diag_cma ), &
                 ! Delta_h = diag_h(D_h.M_{u,h,inv}.D_h^T)
                 columnwise_op_asm_diag_hmht_kernel_type( div_h,       &
                                                          mm_w2h,      &
                                                          diag_DhMDhT_cma ) )

    ! Assemble everything into the vertical Helmholtz operator

    ! STEP 1: tmp_1 = M_{u,z,inv}.D_z^T
    ! STEP 2: tmp_2 = D_z.tmp_1 = D_z.M_{u,z,inv}.D_z^T
    ! STEP 3: tmp_3 = \omega_c^2*\Delta_h + \omega_c^2/(1+\omega_N^2)*tmp_2
    !               = \omega_c^2*\Delta_h 
    !               + \omega_c^2/(1+\omega_N^2)*D_z.M_{u,z,inv}.D_z^T
    ! STEP 4: tmp_4 = M_3 + tmp_3
    ! STEP 5: H_z = M_3^{-1} tmp_4

    ! construct CMAs of the right size
    tmp_1 = mm_w2v_inv_diag_cma%columnwise_operator_product( grad_v_cma )
    tmp_2 = div_v_cma%columnwise_operator_product( tmp_1 )
    tmp_3 = diag_DhMDhT_cma%columnwise_operator_sum( tmp_2 )
    tmp_4 = mm_w3_cma%columnwise_operator_sum( tmp_3 )
    self%Hz_cma = mm_w3_inv_cma%columnwise_operator_product( tmp_4 )
    ! Calculate scaling constants (can not use expressions in invoke call)
    alpha = self%omega2_c
    beta = self%omega2_c/(1.0_r_def + self%omega2_N)
    ! Populate CMAs and construct vertical Helmholtz operator
    call invoke(                                                            &
                 ! STEP 1
                 columnwise_op_mul_kernel_type (       mm_w2v_inv_diag_cma, &
                                                       grad_v_cma,          &
                                                       tmp_1 ),             &
                 ! STEP 2
                 columnwise_op_mul_kernel_type (       div_v_cma,           &
                                                       tmp_1,               &
                                                       tmp_2 ),             &
                 ! STEP 3
                 columnwise_op_scaledadd_kernel_type ( diag_DhMDhT_cma,     &
                                                       tmp_2,               &
                                                       tmp_3,               &
                                                       alpha,               &
                                                       beta ),              &
                 ! STEP 4
                 columnwise_op_scaledadd_kernel_type ( mm_w3_cma,           &
                                                       tmp_3,               &
                                                       tmp_4,               &
                                                       1.0_r_def,           &
                                                       1.0_r_def ),         &
                 ! STEP 5
                 columnwise_op_mul_kernel_type (       mm_w3_inv_cma,       &
                                                       tmp_4,               &
                                                       self%Hz_cma ) )

  end subroutine build_Hz

  !>@brief Apply the preconditioner to calculate \f$y = P.x = x\f$
  !>
  !>@details Apply the vertical preconditioner \f$y = H_z^{-1}x\f$
  !> 
  !>@param[inout] self instance of type gw_pressure_preconditioner_type
  !>@param[inout] x field-vector containing the right hand side of the pressure
  !>@param[inout] y field-vector containing the solution 
  subroutine apply_gw_pressure_preconditioner(self, x, y)

    implicit none
    class(gw_pressure_preconditioner_type), intent(inout)    :: self
    class(abstract_vector_type), intent(in) :: x
    class(abstract_vector_type), intent(inout) :: y

    select type(x)
    type is(field_vector_type)
       select type(y)
       type is(field_vector_type)
          ! Multiply by inverse of vertical operator \f$ H_z \f$
          call invoke( columnwise_op_appinv_kernel_type( y%vector(1), &
                                                         x%vector(1), & 
                                                         self%Hz_cma ) )
       class default
          write(log_scratch_space, '(A)') &
                "gw_pressure_preconditioner_mod: incorrect vector_type argument y"
          call log_event(log_scratch_space, LOG_LEVEL_ERROR)
       end select
    class default
       write(log_scratch_space, '(A)') "gw_pressure_preconditioner_mod: incorrect vector_type argument x"
       call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select
    
  end subroutine apply_gw_pressure_preconditioner

  !>@brief Destructor
  !>
  !>@param[inout] self Instance of type to be destroyed
  subroutine destroy_gw_pressure_preconditioner(self)
    implicit none
    type(gw_pressure_preconditioner_type), intent(inout) :: self

  end subroutine destroy_gw_pressure_preconditioner

end module gw_pressure_precon_alg_mod

