!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief To solve the advection equation of a theta-type tracer using a
!>        split-approach with a semi-Lagrangian in the vertical and a
!>        multi-step RK method in the horizontal.
!>
module rk_transport_theta_mod

  use constants_mod,                     only: r_def, i_def, tiny_eps
  use log_mod,                           only: log_event,         &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_ERROR
  use fs_continuity_mod,                 only: W1
  ! Configuration options
  use finite_element_config_mod,         only: element_order
  use timestepping_config_mod,           only: dt
  use runge_kutta_init_mod,              only: num_rk_stage, ak
  use runtime_constants_mod,             only: get_mass_matrix,                &
                                               get_mass_matrix_diagonal,       &
                                               get_inverse_lumped_mass_matrix, &
                                               get_qr,                         &
                                               w2_id, w3_id, w3inv_id,         &
                                               wt_id, theta_space_id,          &
                                               get_coordinates_xyz,            &
                                               get_detj_at_w2

  use transport_config_mod,              only: operators,                      &
                                               fv_flux_order,                  &
                                               fv_advective_order,             &
                                               operators_fv,                   &
                                               operators_fem,                  &
                                               oned_reconstruction,            &
                                               consistent_metric,              &
                                               theta_splitting,                &
                                               theta_splitting_vh,             &
                                               theta_splitting_hv,             &
                                               theta_splitting_strang,         &
                                               cfl_mol_2d_stab

  ! PsyKAl-lite kernels
  use psykal_lite_mol_mod,               only: psykal_lite_mol_adv_init,       &
                                               invoke_poly1d_adv_recon,        &
                                               invoke_poly1d_advective_coeffs, &
                                               invoke_poly2d_adv_recon,        &
                                               invoke_poly2d_advective_coeffs, &
                                               invoke_poly1d_vert_adv_coeffs,  &
                                               invoke_poly1d_vert_adv

  ! PsyKAl PSYClone kernels
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use poly_advective_kernel_mod,         only: poly_advective_kernel_type
  use consistent_wind_kernel_mod,        only: consistent_wind_kernel_type

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use operator_mod,                      only: operator_type

  ! Algorithms
  use mass_matrix_solver_alg_mod,        only: mass_matrix_solver_alg
  ! Log
  use io_config_mod,                     only: subroutine_timers
  use timer_mod,                         only: timer
  use split_vector_field_kernel_mod,     only: split_vector_field_kernel_type
  use vert_sl_theta_alg_mod,             only: vert_sl_theta

  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type )              :: theta_n, r_theta, theta_inc
  type( field_type ), allocatable :: rt_prediction(:)
  type( field_type )              :: mt_lumped
  type( field_type )              :: theta0
  type( field_type )              :: ones
  type( field_type )              :: theta_av
  type( field_type )              :: advective_av_chi3, theta_metrics, chi3_at_wt

  ! Needed for nonuniform FV operators
  type( field_type ), allocatable :: adv_coeffs(:,:),  vert_adv_coeffs(:,:)

  integer(i_def) :: flux_stencil_extent,      &
                    advective_stencil_extent, &
                    flux2d_stencil_size,      &
                    advective2d_stencil_size
  integer(i_def) :: nfaces_h, nfaces_v

  public :: split_transport_theta_step
  public :: rk_transport_theta_step
  public :: rk_transport_theta_init
  public :: rk_transport_theta_final

contains

  !===========================================================================
  !> @brief This routine splits the wind into vertical and horizontal parts
  !>        then does a vertical semi-Lagrangian advection and a multi-step
  !>        Runge-Kutta-Method-Of-Line (RKMOL) in the horizontal.
  !> @param[in]     wind The 3D wind field
  !> @param[in,out] theta A theta/tracer type field
  !===========================================================================

  subroutine split_transport_theta_step( wind, theta)

    implicit none

    type( field_type ), intent( in    ) :: wind
    type( field_type ), intent( inout ) :: theta

    type(field_type) :: wind_horiz, wind_horiz2
    type(field_type) :: wind_vert
    type(function_space_type), pointer :: w2_fs => null()
    type(field_type), pointer          :: detj_at_w2 => null()

    integer(i_def)         :: mol_substeps
    integer(i_def)         :: sub_step_count
    real(r_def)            :: dt_substep, half_dt, full_dt
    real(r_def)            :: cfl_min, cfl_max
    type( field_type )     :: theta_in

    if ( subroutine_timers ) call timer('split_transport_theta_step')

    w2_fs =>  wind%get_function_space()
    call wind_horiz%initialise( vector_space = w2_fs )
    call wind_horiz2%initialise( vector_space = w2_fs )
    call wind_vert%initialise( vector_space = w2_fs )

    call theta_in%initialise( vector_space = theta%get_function_space())
    call theta%copy_field(theta_in)
    detj_at_w2 => get_detj_at_w2()

    if (theta_splitting /= theta_splitting_strang .and. &
        theta_splitting /= theta_splitting_vh     .and. &
        theta_splitting /= theta_splitting_hv           ) then
     call log_event( "split_transport_theta_step: Invalid theta splitting option", LOG_LEVEL_ERROR )
    end if

    call invoke(split_vector_field_kernel_type(wind_horiz, wind_vert, wind) )
    half_dt  = 0.5_r_def*dt
    full_dt  = real(dt, r_def)

    ! Do half-step SL vertical transport if Strang splitting
    ! Do full dt-SL-step if split vertical(dt)+horizontal(dt)

    if ( theta_splitting == theta_splitting_strang ) then
       call vert_sl_theta(wind_vert,theta,half_dt)
    elseif ( theta_splitting == theta_splitting_vh ) then
       call vert_sl_theta(wind_vert,theta,full_dt)
    end if

    call invoke( name = "Split the horizontal vertical winds",    &
                 X_divideby_Y(wind_horiz2,wind_horiz,detj_at_w2), &
                 inc_a_times_X(full_dt, wind_horiz2)              )
    call wind_horiz2%field_minmax(cfl_min, cfl_max)
    cfl_max = max(abs(cfl_max),abs(cfl_min))

    mol_substeps = int(cfl_max/(cfl_mol_2d_stab+tiny_eps),i_def) + 1_i_def
    dt_substep = full_dt/real(mol_substeps,r_def)

    do sub_step_count = 1, mol_substeps
       call rk_transport_theta_step(wind_horiz,theta,dt_substep)
    end do

    ! Do half-step SL vertical transport if splitting_strang
    ! Do full dt-SL-step if splitting_hv

    if ( theta_splitting == theta_splitting_strang ) then
       call vert_sl_theta(wind_vert,theta,half_dt)
    elseif ( theta_splitting == theta_splitting_hv ) then
       call vert_sl_theta(wind_vert,theta,full_dt)
    end if

    nullify( w2_fs, detj_at_w2 )

    if ( subroutine_timers ) call timer('split_transport_theta_step')

  end subroutine split_transport_theta_step

  !===========================================================================
  !> @brief A Runge-Kutta time-discretisation of the advection equation.
  !> @details An algorithm for timstepping the advection equation using the
  !>          Runge-Kutta method.
  !> @param[in]     u 3D wind field
  !> @param[in,out] theta A theta/tracer type field
  !> @param[in]     dts Local timestep
  !===========================================================================

  subroutine rk_transport_theta_step( u, theta, dts)

    implicit none

    ! Prognostic fields
    type( field_type ), intent( in    ) :: u
    type( field_type ), intent( inout ) :: theta
    real( r_def),        intent( in   ) :: dts

    ! The quadrature object
    type( quadrature_xyoz_type )        :: qr
    ! Coordinate fields
    type( field_type ), pointer         :: chi_xyz(:) => null()
    type( field_type )                  :: theta_n

    integer(i_def) :: stage, st

    ! Temps for retrieving objects back from runtime constants
    type(operator_type), pointer :: mm_w3_inv => null()
    type(field_type), pointer    :: mt_lumped_inv => null()
    type(field_type)             :: consistent_wind


    mm_w3_inv => get_mass_matrix(w3inv_id)
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)

    if ( subroutine_timers ) call timer('rk_transport_theta_alg')

    qr = get_qr()
    chi_xyz => get_coordinates_xyz()
    call theta_n%initialise( vector_space = theta%get_function_space() )
    call theta%copy_field(theta_n)

    ! Runge-Kutta algorithm
    do stage = 1,num_rk_stage
      ! Compute advection terms
      select case(operators)
        case(operators_fv)
          ! Use polynomial reconstruction
          call invoke( setval_c(theta_av, 0.0_r_def) )
          if ( oned_reconstruction ) then
            call invoke_poly1d_adv_recon( theta_av, u, theta, adv_coeffs, &
                                          fv_advective_order, advective_stencil_extent, &
                                          nfaces_h )
            ! Horizontal advection of metric terms
            if ( consistent_metric ) then
              call invoke( setval_c(advective_av_chi3, 0.0_r_def) )
              call invoke_poly1d_adv_recon( advective_av_chi3, u, &
                                            chi3_at_wt, adv_coeffs, &
                                            fv_advective_order, advective_stencil_extent, &
                                            nfaces_h )
            end if
          else
            ! Use 2d flux code
            call invoke_poly2d_adv_recon( theta_av, u, theta, adv_coeffs, &
                                          fv_advective_order, advective2d_stencil_size, &
                                          nfaces_h )
            ! Horizontal advection of metric terms
            if ( consistent_metric ) then
              call invoke( setval_c(advective_av_chi3, 0.0_r_def) )
              call invoke_poly2d_adv_recon( advective_av_chi3, u, &
                                            chi3_at_wt, adv_coeffs, &
                                            fv_advective_order, advective2d_stencil_size, &
                                            nfaces_h )
            end if
          end if
          call invoke( poly_advective_kernel_type( rt_prediction(stage), &
                                                   u, theta_av) )

          ! Compute vertical components of advective update
          call u%copy_field(consistent_wind)
          if ( consistent_metric ) then
            call invoke( poly_advective_kernel_type(theta_metrics, u, advective_av_chi3), &
            ! Modify advecting wind
                       consistent_wind_kernel_type(consistent_wind, u, theta_metrics, chi_xyz) )
          end if
          call invoke_poly1d_vert_adv( rt_prediction(stage), consistent_wind, theta, &
                                       vert_adv_coeffs, &
                                       fv_advective_order, nfaces_v)
        case(operators_fem)
          ! Use FEM projection
          ! Initialise fields
          call invoke( name = "FEM advection of theta",           &
                       setval_c(rt_prediction(stage), 0.0_r_def), &
          ! Theta advection
                       rtheta_kernel_type( rt_prediction(stage), theta, u, qr) )
        case default
          call log_event( "Gungho: Invalid advection method", LOG_LEVEL_ERROR )
      end select

      call invoke( setval_c(r_theta, 0.0_r_def) )

      do st = 1, stage
        call invoke( inc_X_plus_bY(r_theta, ak(stage,st), rt_prediction(st)) )
      end do

      ! Theta
      select case(operators)
        case(operators_fv) ! theta in Wtheta
          call invoke( inc_X_divideby_Y(r_theta, mt_lumped), &
                       X_minus_bY(theta, theta_n, dts, r_theta) )
        case(operators_fem)
          call mass_matrix_solver_alg( theta_inc, r_theta)
          call invoke( X_minus_bY(theta, theta_n, dts, theta_inc) )
        case default
          call log_event( "Gungho: Invalid advection method", LOG_LEVEL_ERROR )
      end select
    end do

    nullify( mm_w3_inv, mt_lumped_inv, chi_xyz )
    if ( subroutine_timers ) call timer('rk_transport_theta_alg')

  end subroutine rk_transport_theta_step

  !===========================================================================
  !> @brief Init routine for RK transport timestepping algorithm.
  !> @param[in] Mesh_id Mesh id of mesh on which the model runs
  !> @param[in] u 3D wind field
  !> @param[in] theta A theta/tracer w-type field
  !===========================================================================

  subroutine rk_transport_theta_init( mesh_id, u, theta)
    use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
    use sample_field_kernel_mod,           only: sample_field_kernel_type
    use quadrature_edge_mod,               only: quadrature_edge_type
    use quadrature_rule_gaussian_mod,      only: quadrature_rule_gaussian_type
    use quadrature_rule_gauss_lobatto_mod,  &
                                           only: quadrature_rule_gauss_lobatto_type
    use multiplicity_kernel_mod,           only: multiplicity_kernel_type
    use reference_element_mod,             only: reference_element_type
    use mesh_mod,                          only: mesh_type

    implicit none

    ! Mesh id
    integer(i_def),  intent(in)        :: mesh_id
    ! Prognostic fields
    type( field_type ), intent( in )   :: u, theta

    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: theta_fs => null()

    ! Timestepping variables
    integer(i_def)               :: stage
    type(operator_type), pointer :: mm_wt => null()

    type( field_type ), pointer :: chi_xyz(:) => null()
    type( field_type ), pointer :: md_wt => null()
    type( field_type )          :: wt_multiplicity
    integer(i_def)              :: direction, polynomial

    type( quadrature_xyoz_type )           :: qr
    type( quadrature_edge_type )           :: qre
    type( quadrature_rule_gaussian_type )  :: gaussian_quadrature
    type( quadrature_rule_gauss_lobatto_type )  :: gauss_lobatto_quadrature
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type),               pointer :: mesh => null()
    integer(i_def)                         :: face_quad_order
    integer(i_def)                         :: nqp_xy, nqp_z

    if ( subroutine_timers ) call timer('rk_transport_theta_init')

    allocate ( rt_prediction(num_rk_stage) )

    !=== Section 1: Create field objects =====================================!
    ! Local fields
    u_fs     => u%get_function_space()
    theta_fs => theta%get_function_space()

    call theta_n%initialise( vector_space = theta_fs )
    call r_theta%initialise( vector_space = theta_fs )
    call theta_inc%initialise( vector_space = theta_fs )

    do stage = 1,num_rk_stage
      call rt_prediction(stage)%initialise( vector_space = theta_fs )
    end do

    if ( operators == operators_fv ) then
      if ( element_order == 0 ) then
        ! Get topology information from the reference element
        mesh              => theta%get_mesh()
        reference_element => mesh%get_reference_element()
        ! Number of horizontal neighbours
        nfaces_h = reference_element%get_number_horizontal_faces()
        ! Number of vertical neighbours is (and always will be) 2
        nfaces_v = reference_element%get_number_vertical_faces()

        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1,r_def)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1,r_def)/2.0,i_def)
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high order elements", LOG_LEVEL_ERROR )
      end if
      mm_wt => get_mass_matrix(wt_id)
      call ones%initialise( vector_space = theta_fs )
      call mt_lumped%initialise( vector_space = theta_fs )
      call invoke( name = "Compute mt_lumped",     &
                   setval_c(ones,      1.0_r_def), &
                   setval_c(mt_lumped, 0.0_r_def), &
                   matrix_vector_kernel_type(mt_lumped, ones, mm_wt) )

      ! Compute stencil for nonuniform polynomial fit
      ! Initialise PSy layer arrays (this will not be needed when
      ! multi-dimensional field arrays are supported)
      if ( oned_reconstruction ) then
        call psykal_lite_mol_adv_init(theta,                &
                                      fv_advective_order,   &
                                      fv_advective_order+1, &
                                      nfaces_h, nfaces_v)
      else
        flux2d_stencil_size = 1_i_def
        do polynomial = 1, fv_flux_order
          if ( mod(polynomial,2_i_def) == 0 ) then
            flux2d_stencil_size = flux2d_stencil_size + nfaces_h
          else
            flux2d_stencil_size = flux2d_stencil_size + nfaces_h*polynomial
          end if
        end do
        advective2d_stencil_size = 1_i_def
        do polynomial = 1, fv_advective_order
          if ( mod(polynomial,2_i_def) == 0 ) then
            advective2d_stencil_size = advective2d_stencil_size + nfaces_h
          else
            advective2d_stencil_size = advective2d_stencil_size + nfaces_h*polynomial
          end if
        end do
        call psykal_lite_mol_adv_init(theta,                    &
                                      fv_advective_order,       &
                                      advective2d_stencil_size, &
                                      nfaces_h, nfaces_v)
      end if

      chi_xyz => get_coordinates_xyz()
      nqp_xy = fv_advective_order+3_i_def
      nqp_z = 2
      if ( oned_reconstruction ) then
        face_quad_order = 1_i_def
      else
        face_quad_order = fv_flux_order+1_i_def
      end if
      qr = quadrature_xyoz_type(nqp_xy, nqp_xy, nqp_z, &
                                gauss_lobatto_quadrature)
      qre = quadrature_edge_type(face_quad_order, .true., .false., &
                                 reference_element, gaussian_quadrature)
      md_wt => get_mass_matrix_diagonal(wt_id)
      call theta_av%initialise( vector_space =                        &
          function_space_collection%get_fs(mesh_id, element_order, W1) )
      if ( oned_reconstruction ) then
        allocate( adv_coeffs(fv_advective_order+1, nfaces_h) )
        do direction = 1,nfaces_h
          do polynomial = 1,fv_advective_order+1
            call adv_coeffs(polynomial,direction)%initialise( vector_space = theta_fs )
          end do
        end do
        call invoke_poly1d_advective_coeffs( adv_coeffs, md_wt, chi_xyz, qr, qre, &
                                             fv_advective_order,                  &
                                             advective_stencil_extent, nfaces_h )
      else
        allocate( adv_coeffs(advective2d_stencil_size, nfaces_h) )
        do direction = 1,nfaces_h
          do polynomial = 1,advective2d_stencil_size
            call adv_coeffs(polynomial,direction)%initialise( vector_space = theta_fs )
          end do
        end do
        call invoke_poly2d_advective_coeffs( adv_coeffs, md_wt, chi_xyz, qr, &
                                             qre, fv_advective_order,        &
                                             advective2d_stencil_size,       &
                                             nfaces_h )
      end if
      call log_event( "Gungho: computing vertical advective coeffs", LOG_LEVEL_INFO )
      ! Vertical advective coeffs
      allocate( vert_adv_coeffs(fv_advective_order+2, nfaces_v) )
      do direction = 1,nfaces_v
        do polynomial = 1,fv_advective_order+2
          call vert_adv_coeffs(polynomial,direction)%initialise( vector_space = theta_fs )
        end do
      end do
      call invoke_poly1d_vert_adv_coeffs( vert_adv_coeffs, chi_xyz, &
                                          fv_advective_order, nfaces_v )

      if ( consistent_metric ) then
        call advective_av_chi3%initialise(vector_space = theta_av%get_function_space() )
        call theta_metrics%initialise(vector_space = theta_fs )
        call chi3_at_wt%initialise(vector_space = theta_fs )
        call wt_multiplicity%initialise(vector_space = theta_fs )
        call invoke( setval_c(wt_multiplicity, 0.0_r_def),       &
                     multiplicity_kernel_type(wt_multiplicity),  &
                     sample_field_kernel_type( chi3_at_wt, wt_multiplicity, chi_xyz(3)) )
      end if

    else
      call invoke( setval_c(ones, 1.0_r_def) )
    end if

    ! Store initial values for computing errors

    call theta%copy_field(theta0)

    nullify( mm_wt, md_wt, chi_xyz, u_fs, theta_fs, mesh, reference_element )

    if ( subroutine_timers ) call timer('rk_transport_theta_init')

  end subroutine rk_transport_theta_init

  !===========================================================================
  !> @@brief Deallocate arrays used in transport.
  !===========================================================================
  subroutine rk_transport_theta_final()

    implicit none

    if (allocated(adv_coeffs)     )     deallocate(adv_coeffs     )
    if (allocated(vert_adv_coeffs))     deallocate(vert_adv_coeffs)
    if (allocated(rt_prediction)  )     deallocate(rt_prediction  )

  end subroutine rk_transport_theta_final

end module rk_transport_theta_mod
