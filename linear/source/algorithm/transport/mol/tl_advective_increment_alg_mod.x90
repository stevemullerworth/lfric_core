!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Compute the advective increment u.grad(f) for a wind field
!!        u and tracer f.

module tl_advective_increment_alg_mod

  implicit none

  private

  public :: tl_advective_increment_alg

contains

  !> @details Algorithm that uses the method-of-lines scheme to
  !!          compute the advective increment, u.grad(f), of field f
  !!          and wind u.
  !> @param[in,out] advective_increment ACTIVE Increment wind.grad(field)
  !> @param[in]     field               ACTIVE Field to compute the increment from
  !> @param[in]     wind                ACTIVE Advecting wind
  !> @param[in]     ls_field            PASSIVE Linearisation state advected field
  !> @param[in]     ls_wind             PASSIVE Linearisation state advecting wind
  !> @param[in]     dt                  Advection time step
  !> @param[in]     direction           Direction to perform the advective update
  !> @param[in]     transport_metadata  Contains transport configuration options
  !> @param[in]     final_rk_stage      Whether this is the last Runge-Kutta stage
  subroutine tl_advective_increment_alg(advective_increment, field, wind, &
                                        ls_field, ls_wind, dt, direction, &
                                        transport_metadata, final_rk_stage)

    use constants_mod,                   only: r_def, i_def, l_def
    use field_mod,                       only: field_type
    use log_mod,                         only: log_event, &
                                               LOG_LEVEL_ERROR
    use reconstruct_w3_field_alg_mod,    only: reconstruct_w3_field_alg
    use tl_reconstruct_w3_field_alg_mod, only: tl_reconstruct_w3_field_alg
    use w3_advective_update_kernel_mod,  only: w3_advective_update_kernel_type
    use w3h_advective_update_kernel_mod, only: w3h_advective_update_kernel_type
    use w3v_advective_update_kernel_mod, only: w3v_advective_update_kernel_type
    use tl_wt_advective_update_alg_mod,  only: tl_wt_advective_update_alg
    use fs_continuity_mod,               only: W3, Wtheta
    use operator_mod,                    only: operator_type
    use fem_constants_mod,               only: get_inverse_w3_mass_matrix
    use transport_metadata_mod,          only: transport_metadata_type
    use transport_enumerated_types_mod,  only: direction_3d, &
                                               direction_h,  &
                                               direction_v

    implicit none

    type(field_type),              intent(inout) :: advective_increment
    type(field_type),              intent(in)    :: field, wind
    type(field_type),              intent(in)    :: ls_field, ls_wind
    real(kind=r_def),              intent(in)    :: dt
    integer(kind=i_def),           intent(in)    :: direction
    type(transport_metadata_type), intent(in)    :: transport_metadata
    logical(kind=l_def),           intent(in)    :: final_rk_stage

    type(field_type)             :: recon_ls_tracer, recon_tracer
    type(field_type)             :: adv_inc_ls_tracer, adv_inc_tracer
    type(operator_type), pointer :: m3_inv => null()

    select case ( field%which_function_space() )

      case ( W3 )
        call adv_inc_tracer%initialise( field%get_function_space() )
        call adv_inc_ls_tracer%initialise( field%get_function_space() )
        call recon_tracer%initialise( wind%get_function_space() )
        call recon_ls_tracer%initialise( wind%get_function_space() )
        m3_inv => get_inverse_w3_mass_matrix( field%get_mesh_id() )

        ! Calculate reconstructions
        ! ls wind is still used here to define upwind direction
        call reconstruct_w3_field_alg(recon_ls_tracer, ls_field, ls_wind, &
                                      direction, transport_metadata, final_rk_stage)
        call tl_reconstruct_w3_field_alg(recon_tracer, field, ls_field,    &
                                         ls_wind, direction,               &
                                         transport_metadata, final_rk_stage)

        select case ( direction )
        case ( direction_3d )
          ! Compute increments
          call invoke( w3_advective_update_kernel_type(adv_inc_tracer,         &
                                                       recon_tracer, ls_wind,  &
                                                       m3_inv),                &
                       w3_advective_update_kernel_type(adv_inc_ls_tracer,      &
                                                       recon_ls_tracer, wind,  &
                                                       m3_inv),                &
          ! Obtain final increment by combining these two:
          ! df' = ls_u.grad(f') + u'.grad(ls_f) )
                      X_plus_Y(advective_increment,                            &
                                adv_inc_tracer, adv_inc_ls_tracer) )
        case ( direction_h )
          ! Compute increments
          call invoke( w3h_advective_update_kernel_type(adv_inc_tracer,        &
                                                        recon_tracer, ls_wind, &
                                                        m3_inv),               &
                       w3h_advective_update_kernel_type(adv_inc_ls_tracer,     &
                                                        recon_ls_tracer, wind, &
                                                        m3_inv),               &
          ! Obtain final increment by combining these two:
          ! df' = ls_u.grad(f') + u'.grad(ls_f) )
                      X_plus_Y(advective_increment,                            &
                                adv_inc_tracer, adv_inc_ls_tracer) )
        case ( direction_v )
          ! Compute increments
          call invoke( w3v_advective_update_kernel_type(adv_inc_tracer,        &
                                                        recon_tracer, ls_wind, &
                                                        m3_inv),               &
                       w3v_advective_update_kernel_type(adv_inc_ls_tracer,     &
                                                        recon_ls_tracer, wind, &
                                                        m3_inv),               &
          ! Obtain final increment by combining these two:
          ! df' = ls_u.grad(f') + u'.grad(ls_f) )
                      X_plus_Y(advective_increment,                            &
                                adv_inc_tracer, adv_inc_ls_tracer) )
        end select

        nullify(m3_inv)

      case ( Wtheta )

        ! Everything is handled by T.L. version of Wtheta advective update alg
        call tl_wt_advective_update_alg(advective_increment, field, wind, &
                                        ls_field, ls_wind, dt, direction, &
                                        transport_metadata, final_rk_stage)

      case default
        call log_event( "Advective increment only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )

    end select

  end subroutine tl_advective_increment_alg

end module tl_advective_increment_alg_mod
