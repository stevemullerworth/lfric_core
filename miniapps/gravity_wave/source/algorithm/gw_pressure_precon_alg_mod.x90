!-----------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! For further details please refer to the file LICENCE which you should have
! received as part of this distribution.
!-----------------------------------------------------------------------------
!>@brief Vertical preconditioner for the pressure equation.
!>
!>
!>@details This preconditioner calculates \f$y = Px = H_z^{-1}x\f$ where
!> \f$H_z\f$ is the vertical part of the Helmholtz operator (scaled by the
!> inverse pressure mass matrix), i.e.
!>
!> \f[
!> H_z = 1 + M_3^{-1}\left(\omega_c^2 \Delta_h
!>                       + \omega_c^2/(1+\omega_N^2) D_z M_{u,z,inv} D_z^T)
!>                   \right)
!> \f]
!> and \f$\Delta_h = \diag(D_h M_{u,h,inv} D_h^T) \f$. The lumped inverse mass
!> matrices are given by \f$M_{u,*,inv}\f$.
!>

module gw_pressure_precon_alg_mod
  use vector_mod,                      only : abstract_vector_type
  use field_vector_mod,                only : field_vector_type
  use hierarchical_preconditioner_mod, only : abstract_hierarchical_preconditioner_type
  use log_mod,                         only : log_event, &
                                              LOG_LEVEL_INFO, &
                                              LOG_LEVEL_ERROR, &
                                              log_scratch_space
  use columnwise_operator_mod,         only : columnwise_operator_type
  use constants_mod,                   only : i_def, r_def
  use operator_mod,                    only : operator_type

  ! Columnwise operator kernels
  use columnwise_op_app_kernel_mod,    only : columnwise_op_app_kernel_type
  use columnwise_op_appinv_kernel_mod, only : columnwise_op_appinv_kernel_type

  implicit none

  type, public, extends(abstract_hierarchical_preconditioner_type) :: gw_pressure_preconditioner_type

     integer(kind=i_def) :: level
     integer(kind=i_def) :: mesh_id
     !> Constant \f$\omega_c^2 = (\alpha\Delta t c)^2\f$
     real(kind=r_def) :: omega2_c
     !> Constant \f$\omega_N^2 = (\alpha\Delta t N)^2\f$
     real(kind=r_def) :: omega2_N
     !> vertical Helmholtz operator
     type(columnwise_operator_type) :: Hz_cma

   contains
     ! Build the vertical part \f$H_z\f$ of the Helmholtz matrix
     procedure, private :: build_Hz
     ! overide the (abstract interface) for application of a preconditioner
     ! \f$y = P.x\f$
     procedure, public :: apply => apply_gw_pressure_preconditioner
     procedure, private :: apply_gw_pressure_preconditioner
     procedure, public  :: gw_pressure_preconditioner_assign
     procedure, public  :: coarsen => coarsen_gw_pressure_preconditioner
     procedure, private :: coarsen_gw_pressure_preconditioner

     final              :: destroy_gw_pressure_preconditioner

     !> Override default assignment for gw_pressure_preconditioner_type pairs.
     generic            :: assignment(=) => gw_pressure_preconditioner_assign

  end type gw_pressure_preconditioner_type

  ! Overload the default structure constructor
  interface gw_pressure_preconditioner_type
     module procedure gw_pressure_preconditioner_constructor
  end interface

contains

  !> @brief Construct a <code> gw_pressure_preconditioner_type</code> object
  !>
  !> @param[in] level Multigrid level
  !>
  !> @return self the constructed preconditioner object
  function gw_pressure_preconditioner_constructor(level) result(self)

    use log_mod,                           only: log_event, LOG_LEVEL_INFO
    use timestepping_config_mod,           only: dt, alpha
    use gravity_wave_constants_config_mod, only: cs_square
    use initial_temperature_config_mod,    only: bvf_square
    use runtime_tools_mod,                 only: get_hierarchical_mesh_id
    implicit none

    type(gw_pressure_preconditioner_type)  :: self
    integer(kind=i_def), intent(in)        :: level

    call log_event( 'Constructing pressure preconditioner...', &
         LOG_LEVEL_INFO )

    ! set scaling constants
    self%omega2_c = alpha**2*dt**2*cs_square
    self%omega2_N = alpha**2*dt**2*bvf_square
    self%level = level
    self%mesh_id = get_hierarchical_mesh_id(level)

    call self%build_Hz()

    call log_event( 'done', LOG_LEVEL_INFO )

  end function gw_pressure_preconditioner_constructor

  !> @brief Build the vertical Helmholtz matrix \f$H_z\f$ in CMA representation
  subroutine build_Hz(self)

    use fem_constants_mod,            only : get_div_v,                 &
                                             get_div_h,                 &
                                             get_mass_matrix,           &
                                             get_inverse_w3_mass_matrix
    use fs_continuity_mod,            only : W3, W2h, W2v
    use transpose_matrix_kernel_mod,            only : transpose_matrix_kernel_type
    use enforce_operator_bc_kernel_mod,         only : enforce_operator_bc_kernel_type
    use columnwise_op_asm_kernel_mod,           only : columnwise_op_asm_kernel_type
    use columnwise_op_asm_diag_hmht_kernel_mod, only : columnwise_op_asm_diag_hmht_kernel_type
    use columnwise_op_mul_kernel_mod,           only : columnwise_op_mul_kernel_type
    use columnwise_op_scaledadd_kernel_mod,     only : columnwise_op_scaledadd_kernel_type
    use columnwise_op_asm_m2v_lumped_inv_kernel_mod, only : columnwise_op_asm_m2v_lumped_inv_kernel_type

    implicit none

    ! Instance of type
    class(gw_pressure_preconditioner_type), intent(inout) :: self

    ! Pointers to mass matrices and derivative operators
    type(operator_type), pointer :: mm_w3
    type(operator_type), pointer :: mm_w3_inv
    type(operator_type), pointer :: mm_w2v_noBC
    type(operator_type), pointer :: mm_w2h
    type(operator_type), pointer :: div_v
    type(operator_type), pointer :: div_h
    ! Need a copy of vertical velocity matrix to enforce boundary conditions
    type(operator_type) :: mm_w2v
    type(operator_type) :: grad_v
    ! CMA representation of vertical weak derivatives, mass matrix and
    ! temporary matrices
    type(columnwise_operator_type) :: div_v_cma
    type(columnwise_operator_type) :: grad_v_cma
    type(columnwise_operator_type) :: mm_w3_cma
    type(columnwise_operator_type) :: mm_w3_inv_cma
    type(columnwise_operator_type) :: mm_w2v_cma
    type(columnwise_operator_type) :: mm_w2v_inv_diag_cma
    type(columnwise_operator_type) :: diag_DhMDht_cma
    type(columnwise_operator_type) :: tmp_1, tmp_2, tmp_3, tmp_4
    ! Scaling constants for invoke calls
    real(kind=r_def)    :: alpha, beta
    integer(kind=i_def) :: mesh_id

    mesh_id = self%mesh_id

    ! Set pointers to vertical operators
    div_v => get_div_v(mesh_id)
    call grad_v%initialise( div_v%get_fs_from(), div_v%get_fs_to() )
    div_h => get_div_h(mesh_id)
    mm_w3 => get_mass_matrix(W3, mesh_id)
    mm_w3_inv => get_inverse_w3_mass_matrix(mesh_id)
    ! Take a copy of the vertical mass matrix since we need to apply the BCs
    mm_w2v_noBC => get_mass_matrix(W2v, mesh_id)
    mm_w2v = mm_w2v_noBC%deep_copy()
    ! Now apply BCs
    call invoke( enforce_operator_bc_kernel_type( mm_w2v ) )
    ! Get horizontal velocity mass matrix
    mm_w2h => get_mass_matrix(W2h, mesh_id)

    ! Construct weak gradient as transpose of divergence
    call invoke( transpose_matrix_kernel_type( div_v, grad_v ) )

    ! Build individual CMA operators
    call mm_w3_cma%initialise( mm_w3%get_fs_to(), &
                               mm_w3%get_fs_from() )
    call mm_w3_inv_cma%initialise( mm_w3_inv%get_fs_to(), &
                                   mm_w3_inv%get_fs_from() )
    call mm_w2v_cma%initialise( mm_w2v%get_fs_to(), &
                                mm_w2v%get_fs_from() )
    call div_v_cma%initialise( div_v%get_fs_to(), &
                               div_v%get_fs_from() )
    call grad_v_cma%initialise( grad_v%get_fs_to(), &
                                grad_v%get_fs_from() )
    call mm_w2v_inv_diag_cma%initialise( mm_w2v%get_fs_to(),   &
                                         mm_w2v%get_fs_from(), &
                                         1, 1, 0, 0)
    call diag_DhMDht_cma%initialise( mm_w3%get_fs_to(), &
                                     mm_w3%get_fs_from() )

    call invoke(                                                       &
                 ! Pressure mass matrix M_3
                 columnwise_op_asm_kernel_type( mm_w3,                 &
                                                mm_w3_cma ),           &
                 ! Inverse mass matrix M_3
                 columnwise_op_asm_kernel_type( mm_w3_inv,             &
                                                mm_w3_inv_cma ),       &
                 ! Vertical divergence D_z
                 columnwise_op_asm_kernel_type( div_v,                 &
                                                div_v_cma ),           &
                 ! Weak vertical gradient D_z^T
                 columnwise_op_asm_kernel_type( grad_v,                &
                                                grad_v_cma ),          &
                 ! Lumped inverse vertical velocity mass matrix M_{u,z,inv}
                 columnwise_op_asm_m2v_lumped_inv_kernel_type( mm_w2v, &
                                                               mm_w2v_inv_diag_cma ), &
                 ! Delta_h = diag_h(D_h.M_{u,h,inv}.D_h^T)
                 columnwise_op_asm_diag_hmht_kernel_type( div_h,       &
                                                          mm_w2h,      &
                                                          diag_DhMDhT_cma ) )

    ! Assemble everything into the vertical Helmholtz operator

    ! STEP 1: tmp_1 = M_{u,z,inv}.D_z^T
    ! STEP 2: tmp_2 = D_z.tmp_1 = D_z.M_{u,z,inv}.D_z^T
    ! STEP 3: tmp_3 = \omega_c^2*\Delta_h + \omega_c^2/(1+\omega_N^2)*tmp_2
    !               = \omega_c^2*\Delta_h
    !               + \omega_c^2/(1+\omega_N^2)*D_z.M_{u,z,inv}.D_z^T
    ! STEP 4: tmp_4 = M_3 + tmp_3
    ! STEP 5: H_z = M_3^{-1} tmp_4

    ! construct CMAs of the right size
    tmp_1 = mm_w2v_inv_diag_cma%columnwise_operator_product( grad_v_cma )
    tmp_2 = div_v_cma%columnwise_operator_product( tmp_1 )
    tmp_3 = diag_DhMDhT_cma%columnwise_operator_sum( tmp_2 )
    tmp_4 = mm_w3_cma%columnwise_operator_sum( tmp_3 )
    self%Hz_cma = mm_w3_inv_cma%columnwise_operator_product( tmp_4 )
    ! Calculate scaling constants (can not use expressions in invoke call)
    alpha = self%omega2_c
    beta = self%omega2_c/(1.0_r_def + self%omega2_N)
    ! Populate CMAs and construct vertical Helmholtz operator
    call invoke(                                                            &
                 ! STEP 1
                 columnwise_op_mul_kernel_type (       mm_w2v_inv_diag_cma, &
                                                       grad_v_cma,          &
                                                       tmp_1 ),             &
                 ! STEP 2
                 columnwise_op_mul_kernel_type (       div_v_cma,           &
                                                       tmp_1,               &
                                                       tmp_2 ),             &
                 ! STEP 3
                 columnwise_op_scaledadd_kernel_type ( diag_DhMDhT_cma,     &
                                                       tmp_2,               &
                                                       tmp_3,               &
                                                       alpha,               &
                                                       beta ),              &
                 ! STEP 4
                 columnwise_op_scaledadd_kernel_type ( mm_w3_cma,           &
                                                       tmp_3,               &
                                                       tmp_4,               &
                                                       1.0_r_def,           &
                                                       1.0_r_def ),         &
                 ! STEP 5
                 columnwise_op_mul_kernel_type (       mm_w3_inv_cma,       &
                                                       tmp_4,               &
                                                       self%Hz_cma ) )

  end subroutine build_Hz

  !>@brief Apply the preconditioner to calculate \f$y = P.x = x\f$
  !>
  !>@details Apply the vertical preconditioner \f$y = H_z^{-1}x\f$
  !>
  !>@param[inout] self instance of type gw_pressure_preconditioner_type
  !>@param[inout] x field-vector containing the right hand side of the pressure
  !>@param[inout] y field-vector containing the solution
  subroutine apply_gw_pressure_preconditioner(self, x, y)

    implicit none
    class(gw_pressure_preconditioner_type), intent(inout)    :: self
    class(abstract_vector_type), intent(in) :: x
    class(abstract_vector_type), intent(inout) :: y

    select type(x)
    type is(field_vector_type)
       select type(y)
       type is(field_vector_type)
          ! Set field to zero
          call y%set_scalar(0.0_r_def)
          ! Multiply by inverse of vertical operator \f$ H_z \f$
          call invoke( columnwise_op_appinv_kernel_type( y%vector(1), &
                                                         x%vector(1), &
                                                         self%Hz_cma ) )
       class default
          write(log_scratch_space, '(A)') &
                "gw_pressure_preconditioner_mod: incorrect vector_type argument y"
          call log_event(log_scratch_space, LOG_LEVEL_ERROR)
       end select
    class default
       write(log_scratch_space, '(A)') "gw_pressure_preconditioner_mod: incorrect vector_type argument x"
       call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end subroutine apply_gw_pressure_preconditioner

  !> Performs a deep copy between gw_pressure_preconditioner_type pairs.
  !> (for overriding the "=" operator)
  !>
  !> @param[out] dest   gw_pressure_preconditioner_type lhs
  !> @param[in]  source gw_pressure_preconditioner_type rhs
  subroutine gw_pressure_preconditioner_assign(dest, source)

    implicit none
    class(gw_pressure_preconditioner_type), intent(in)  :: source
    class(gw_pressure_preconditioner_type), intent(out) :: dest

    ! Deep copy of the contents of the pressure_operator_type
    dest%level = source%level
    dest%omega2_c = source%omega2_c
    dest%omega2_N = source%omega2_N
    dest%Hz_cma = source%Hz_cma

  end subroutine gw_pressure_preconditioner_assign

  !> Construct a coarsened version of the preconditioner on the next
  !> level of the multigrid hierarchy
  !>
  !>@param[inout] self instance of type gw_pressure_preconditioner_type
  !>@param[inout] other coarsed version on next multigrid level
  subroutine coarsen_gw_pressure_preconditioner(self, other)
    implicit none
    class(gw_pressure_preconditioner_type), intent(inout) :: self
    class(abstract_hierarchical_preconditioner_type), allocatable, intent(inout) :: other
    allocate(other, &
             source=gw_pressure_preconditioner_type(self%level+1))
  end subroutine coarsen_gw_pressure_preconditioner

  !>@brief Destructor
  !>
  !>@param[inout] self Instance of type to be destroyed
  subroutine destroy_gw_pressure_preconditioner(self)
    implicit none
    type(gw_pressure_preconditioner_type), intent(inout) :: self

  end subroutine destroy_gw_pressure_preconditioner

end module gw_pressure_precon_alg_mod

