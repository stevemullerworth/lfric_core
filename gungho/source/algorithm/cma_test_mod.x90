!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief Routines for testing the CMA data structures and kernels
!>
!>@details This module contains several routines for testing the correctness of 
!>         CMA operator kernels. It checks that the following operations are carried out
!>         directly:
!>
!>         * A CMA operator can be applied to a field (compare to result from equivalent
!>           operator application in LMA representation).
!>         * Two CMA operators can be multiplied to obtain a new CMA (compare result of 
!>           combined CMA operator application to successive application of the two
!>           operators in LMA representation).
!>         * Two CMA operator can be added to obtain a new CMA (compare result of 
!>           combined CMA operator application to successive application of the two
!>           operators in LMA representation).
!>         * The equation \f$Au=b\f$ can be solved for \f$u\f$ if \f$A\f$ is a CMA
!>           operator. For this, calculate \f$b=Au_{in}\f$ where \f$u_{in}\f$ is a 
!>           given field and compare \f$u\f$ and \f$u_{in}\f$.
!>         * The diagonal of a vertical velocity mass matrix can be extracted and 
!>           stored in a CMA (this is tested implicitly, since this CMA is used 
!>           in the construction in the term \f$D_vM_{2,v,inv}D_v^T\f$ in the 
!>           Helmholtz operator. This test currently only works reliably if the code
!>           is run on one processor.
!>
!>         Some of the tests construct a Helmholtz operator of the form
!>         \f$H=\alpha M_3 + \beta D_v M_{2,v,inv} D_v^T\f$.

module cma_test_mod

  ! Standard system kernels
  use log_mod,                        only : log_event,         &
                                             log_set_level,     &
                                             log_scratch_space, &
                                             LOG_LEVEL_ERROR,   &
                                             LOG_LEVEL_INFO,    &
                                             LOG_LEVEL_DEBUG,   &
                                             LOG_LEVEL_TRACE
  use constants_mod,                  only : i_def, r_def
  use function_space_mod,             only : function_space_type
  use function_space_collection_mod,  only : function_space_collection
  use field_mod,                      only : field_type
  use quadrature_mod,                 only : quadrature_type, GAUSSIAN
  use operator_mod,                   only : operator_type, &
                                             columnwise_operator_type
  use fs_continuity_mod,              only : W0,W1,W2,W2V,W2H,W3,Wchi
  use assign_coordinate_field_mod,    only : assign_coordinate_field
  use finite_element_config_mod,      only : element_order, coordinate_order
  ! Kernels for field assignment and manipulation
  use enforce_bc_kernel_mod,          only : enforce_bc_kernel_type
  use assign_field_random_kernel_mod, only : assign_field_random_kernel_type
  use assign_field_single_column_kernel_mod, only : assign_field_single_column_kernel_type
  ! Kernels for local operator assembly
  use compute_mass_matrix_kernel_w2_mod, only : compute_mass_matrix_kernel_w2_type
  use compute_mass_matrix_kernel_w3_mod, only : compute_mass_matrix_kernel_w3_type
  use compute_div_operator_kernel_mod,   only : compute_div_operator_kernel_type
  ! Kernels for local operator application and manipulation
  use matrix_vector_kernel_mod,           only : matrix_vector_kernel_type
  use transpose_matrix_vector_kernel_mod, only : transpose_matrix_vector_kernel_type
  use transpose_matrix_kernel_mod,        only : transpose_matrix_kernel_type
  use mm_diagonal_kernel_mod,             only : mm_diagonal_kernel_type
  use mm_diagonal_assembled_kernel_mod,   only : mm_diagonal_assembled_kernel_type
  use enforce_operator_bc_kernel_mod,     only : enforce_operator_bc_kernel_type
  ! Columnwise operator kernels
  use columnwise_op_asm_kernel_mod,           only : columnwise_op_asm_kernel_type
  use columnwise_op_asm_diag_hmht_kernel_mod, only : columnwise_op_asm_diag_hmht_kernel_type
  use columnwise_op_app_kernel_mod,           only : columnwise_op_app_kernel_type
  use columnwise_op_appinv_kernel_mod,        only : columnwise_op_appinv_kernel_type
  use columnwise_op_mul_kernel_mod,           only : columnwise_op_mul_kernel_type
  use columnwise_op_scaledadd_kernel_mod,     only : columnwise_op_scaledadd_kernel_type
  use columnwise_op_asm_m2v_lumped_inv_kernel_mod, only : columnwise_op_asm_m2v_lumped_inv_kernel_type
  ! PSYkal_lite kernels
  use psykal_lite_mod,                   only : invoke_enforce_operator_bc_kernel_type

  implicit none

  private

  ! Mesh id
  integer(kind=i_def) :: mesh_id
  ! Index of coordinate function space
  integer(kind=i_def) :: chi_space
  ! Coordinate field
  type(field_type) :: chi(3)
  ! Quadrature rule
  type(quadrature_type) :: qr
  ! Function spaces
  ! coordinates
  type(function_space_type), pointer :: fs_coord => null()
  ! vertical velocity
  type(function_space_type), pointer :: fs_vel_v => null()
  ! horizontal velocity
  type(function_space_type), pointer :: fs_vel_h => null()
  ! pressure
  type(function_space_type), pointer :: fs_pressure => null()
  ! Fields (temporaries used for testing)
  ! pressure space
  type(field_type) :: p_in,           &
                      p_tmp,          &  
                      p_out,          &  
                      p_out_cma
  ! velocity space
  type(field_type) :: u_v_in,                &
                      u_v_tmp,               &
                      u_h_tmp,               &
                      u_v_out,               &
                      u_v_out_cma
  ! Fields storing the diagonal of mass matrices
  type(field_type) :: mm_vel_v_diag,         &
                      mm_vel_h_diag
  ! LMA operators
  ! Mass matrices
  type(operator_type) :: mm_vel_v
  type(operator_type) :: mm_vel_h
  type(operator_type) :: mm_pressure
  ! Divergence and gradient operator
  type(operator_type) :: div_v
  type(operator_type) :: div_h
  type(operator_type) :: grad_v
  ! CMA operators
  type(columnwise_operator_type) :: div_v_cma
  type(columnwise_operator_type) :: grad_v_cma
  type(columnwise_operator_type) :: mm_vel_v_cma
  type(columnwise_operator_type) :: mm_pressure_cma
  type(columnwise_operator_type) :: mm_vel_v_inv_diag_cma 
  ! Bool to avoid initialising this module multiple times, set to .true. in first 
  ! call to cma_test_init().
  logical :: is_initialised = .false.

  ! Export functions
  public::cma_test_init
  public::test_cma_apply_mass_p
  public::test_cma_apply_mass_v
  public::test_cma_apply_div_v
  public::test_cma_multiply_div_v_mass_v
  public::test_cma_multiply_grad_v_div_v
  public::test_cma_add
  public::test_cma_apply_inv
  public::test_cma_diag_DhMDhT
  
contains

  !>@brief Initialise module
  !>@details Create operators which will be assembled into CMAs, assemble CMAs.
  !>         Also carries out some checks to ensure that the mesh is 
  !>         of an appropriate size (if the grid spacing is too small or too larger,
  !>         the two terms in the Helmholtz operator might have very different magnitude
  !>         distorting the test results).
  !>@param[in] mesh_id_in Id of mesh to be used
  subroutine cma_test_init(mesh_id_in)
    implicit none
    
    integer(kind=i_def), intent(in) :: mesh_id_in
    ! Local variables
    integer(kind=i_def)               :: i
    
    ! Return if module has already been initialised
    if (is_initialised) return

    mesh_id = mesh_id_in

    ! Set up coordinate field
    if ( coordinate_order == 0 ) then
       chi_space = W0
       call log_event( "cma test: Computing W0 coordinate fields", &
                       LOG_LEVEL_INFO )
    else
       chi_space = Wchi
       call log_event( "cma test: Computing Wchi coordinate fields", &
                       LOG_LEVEL_INFO )
    end if

    fs_coord => function_space_collection%get_fs(mesh_id,          &
                                                 coordinate_order, &
                                                 chi_space)

    do i = 1,3
       chi(i) = field_type (vector_space = fs_coord )
    end do

    call assign_coordinate_field(chi, mesh_id)

    ! Construct quadrature rule
    qr = quadrature_type(3, GAUSSIAN)

    ! Extract function spaces from mesh
    fs_vel_v    => function_space_collection%get_fs(mesh_id,       &
                                                    element_order, &
                                                    W2V)
    fs_vel_h    => function_space_collection%get_fs(mesh_id,       &
                                                    element_order, &
                                                    W2H)
    fs_pressure => function_space_collection%get_fs(mesh_id,       &
                                                    element_order, &
                                                    W3)
    ! Create temporary fields for testing
    p_in           = field_type( fs_pressure )
    p_tmp          = field_type( fs_pressure )
    p_out          = field_type( fs_pressure )
    p_out_cma      = field_type( fs_pressure )
    u_v_in         = field_type( fs_vel_v )
    u_v_tmp        = field_type( fs_vel_v )
    u_h_tmp        = field_type( fs_vel_h )
    u_v_out        = field_type( fs_vel_v )
    u_v_out_cma    = field_type( fs_vel_v )

    ! Create and assemble mass matrices, divergence and gradient operator
    mm_vel_v              = operator_type( fs_vel_v, fs_vel_v )
    mm_vel_h              = operator_type( fs_vel_h, fs_vel_h )
    mm_pressure           = operator_type( fs_pressure, fs_pressure )
    div_v                 = operator_type( fs_pressure, fs_vel_v )
    div_h                 = operator_type( fs_pressure, fs_vel_h )
    grad_v                = operator_type( fs_vel_v, fs_pressure )
    mm_vel_v_diag         = field_type( fs_vel_v )
    mm_vel_h_diag         = field_type( fs_vel_h )
    call invoke( compute_mass_matrix_kernel_w2_type(mm_vel_v,chi,qr) )
    call invoke( compute_mass_matrix_kernel_w2_type(mm_vel_h,chi,qr) )
    call invoke( compute_mass_matrix_kernel_w3_type(mm_pressure,chi,qr) )
    call invoke( compute_div_operator_kernel_type (div_v,chi,qr) )
    call invoke( compute_div_operator_kernel_type (div_h,chi,qr) )
    call invoke( transpose_matrix_kernel_type (div_v,grad_v) )

    ! Extract diagonal of vertical and horizontal velocity mass matrices
    ! Note that this has to be done BEFORE applying the boundary
    ! conditions to the velocity mass matrix, as it will contain zeros otherwise.
    ! This is an issue since we later divide by the diagonal mass matrix in
    ! the field representation.
    call invoke( set_field_scalar( 0.0_r_def, mm_vel_v_diag ) )
    call invoke( mm_diagonal_kernel_type(mm_vel_v_diag, mm_vel_v))
    call invoke( set_field_scalar( 0.0_r_def, mm_vel_h_diag ) )
    call invoke( mm_diagonal_kernel_type(mm_vel_h_diag, mm_vel_h))
    ! Copy back to LMA representation of diagonal, since this is later used
    ! to assemble to operator \f$diag(D_h M_{2,h,inv} D_h^T\f$.
    call invoke( mm_diagonal_assembled_kernel_type(mm_vel_h_diag, mm_vel_h))

    ! Enforce (vertical) BCs for velocity space on all relevant operators
    call invoke_enforce_operator_bc_kernel_type (mm_vel_v) 
    call invoke_enforce_operator_bc_kernel_type (div_v) 
    call invoke_enforce_operator_bc_kernel_type (grad_v) 

    ! Create and assemble CMA representations of operators
    ! Pressure mass matrix
    mm_pressure_cma          = columnwise_operator_type( fs_pressure, &
                                                         fs_pressure )
    ! Vertical divergence
    div_v_cma                = columnwise_operator_type( fs_pressure, &
                                                         fs_vel_v )
    ! vertical gradient
    grad_v_cma               = columnwise_operator_type( fs_vel_v, &
                                                         fs_pressure )
    ! vertical velocity mass matrix
    mm_vel_v_cma             = columnwise_operator_type( fs_vel_v, &
                                                         fs_vel_v )
    ! vertical diagonal velocity mass matrix
    mm_vel_v_inv_diag_cma    = columnwise_operator_type( fs_vel_v, &
                                                         fs_vel_v, 1, 1, 0, 0)
    call invoke( columnwise_op_asm_kernel_type( mm_pressure, &
                                                mm_pressure_cma) )
    call invoke( columnwise_op_asm_kernel_type( div_v,       &
                                                div_v_cma) )
    call invoke( columnwise_op_asm_kernel_type( grad_v,      &
                                                grad_v_cma) )
    call invoke( columnwise_op_asm_kernel_type( mm_vel_v,    &
                                                mm_vel_v_cma) )
    call invoke( columnwise_op_asm_m2v_lumped_inv_kernel_type( mm_vel_v,              &
                                                               mm_vel_v_inv_diag_cma ) )
    ! Set flag to true to avoid multiple initialisations
    is_initialised = .true.
    
  end subroutine cma_test_init

  !>@brief Check if two fields are idential up to some tolerance
  !>@details Auxilliary routine which calculates the relative difference
  !>         \f$\delta = ||x_1-x_2||/||x_1||\f$ of two fields 
  !>         \f$x_1\f$ and \f$x_2\f$ in the L2 norm. If this difference
  !>         is smaller than a given tolerance \f$\epsilon\f$, it will print
  !>         out a string with a PASS message, otherwise it will print a FAIL
  !>         message.
  !> Example:
  !>
  !> *** test            apply vert divergence ***
  !>   ||X1|| = 0.41820503E+02
  !>   ||X2|| = 0.41820503E+02
  !>   ||X1-X2|| = 0.00000000E+00
  !>   ||X1-X2||/||X1|| = 0.00000000E+00
  !>   test           apply vert divergence : PASS

  !>@param[in] x1 First field to compare
  !>@param[in] x2 Second field to compare
  !>@param[in] tolerance Tolerance \f$\epsilon\f$
  !>@param[in] label Label for comparison
  subroutine compare_fields(x1,x2,tolerance,label)
    implicit none
    ! passed parameters
    type(field_type), intent(in) :: x1
    type(field_type), intent(in) :: x2
    real(kind=r_def), intent(in) :: tolerance
    character(len=*), intent(in) :: label
   
    ! internal variables
    type(field_type) :: dx, x_tmp
    real(kind=r_def) :: dx_nrm_sq, x1_nrm_sq, x2_nrm_sq
    character(len=128) :: output
    character(len=4) :: pass_str
    type(function_space_type), pointer :: fs => null()

    ! Extract function space for creation of temporary fields
    fs => function_space_collection%get_fs(mesh_id,       &
                                           element_order, &
                                           x1%which_function_space())

    dx = field_type(fs)
    x_tmp = field_type(fs)

    ! Calculate differences
    call invoke( minus_fields ( x1, x2, dx) )
    call invoke( copy_field (dx, x_tmp) )
    call invoke( inner_product( dx, x_tmp, dx_nrm_sq ) )
    call invoke( copy_field (x1, x_tmp) )
    call invoke( inner_product( x1, x_tmp, x1_nrm_sq ) )
    call invoke( copy_field (x2, x_tmp) )
    call invoke( inner_product( x2, x_tmp, x2_nrm_sq ) )

    if (sqrt(dx_nrm_sq/x1_nrm_sq) < tolerance) then
       pass_str = "PASS"
    else
       pass_str = "FAIL"
    end if
    write(output,'(" *** test ",A32," ***")') trim(label)
    call log_event( output, LOG_LEVEL_INFO )
    write(output,'("   ||x1||           = ",E15.8)') sqrt(x1_nrm_sq)
    call log_event( output, LOG_LEVEL_INFO )
    write(output,'("   ||x2||           = ",E15.8)') sqrt(x2_nrm_sq)
    call log_event( output, LOG_LEVEL_INFO )
    write(output,'("   ||x1-x2||        = ",E15.8)') sqrt(dx_nrm_sq)
    call log_event( output, LOG_LEVEL_INFO )
    write(output,'("   ||x1-x2||/||x1|| = ",E15.8)') sqrt(dx_nrm_sq/x1_nrm_sq)
    call log_event( output, LOG_LEVEL_INFO )
    write(output,'("   test",A32," : ",A4)') trim(label), pass_str
    call log_event( output, LOG_LEVEL_INFO )
    call log_event( "", LOG_LEVEL_INFO )

  end subroutine compare_fields

  !> @brief Apply the Helmholtz-operator
  !>        \f$\hat{H}=\alpha M_3 + \beta D_vM_{2,v,inv}D_v^T\f$
  !> @details Applies the Helmholtz operator \f$H\f$ using the LMA representation
  !> @param[in]  alpha Scaling parameter \f$\alpha\f$
  !> @param[in]  beta Scaling parameter \f$\beta\f$
  !> @param[in]  p_in Input pressure field \f$p_{in}\f$
  !> @param[out] p_out Output pressure field \f$p_{out}=\hat{H}p_{in}\f$
  subroutine apply_helmholtz(alpha,beta,p_in, p_out)
    implicit none

    ! passed parameters
    real(kind=r_def), intent(in)    :: alpha, beta
    type(field_type), intent(in)    :: p_in
    type(field_type), intent(inout) :: p_out

    ! internal variables
    real(kind=r_def)                :: beta_divided_by_alpha

    call invoke( set_field_scalar( 0.0_r_def, u_v_tmp ) )
    call invoke( set_field_scalar( 0.0_r_def, p_tmp   ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out   ) )
    ! Apply gradient \f$D_v^T\f$
    call invoke( matrix_vector_kernel_type( u_v_tmp,         &
                                            p_in,            &
                                            grad_v ) )
    ! Divide by diagonally lumped vertical velocity mass matrix and
    ! enforce boundary conditions
    call invoke( divide_field( u_v_tmp, mm_vel_v_diag ) )
    call invoke( enforce_bc_kernel_type ( u_v_tmp ) )
    ! Apply divergence \f$D_v\f$
    call invoke( matrix_vector_kernel_type( p_out,           &
                                            u_v_tmp,         &
                                            div_v ) )
    beta_divided_by_alpha = beta/alpha
    call invoke( scale_field ( beta_divided_by_alpha, p_out ) )
    ! Apply and add pressure mass matrix \f$M_3\f$
    call invoke( matrix_vector_kernel_type( p_out,           &
                                            p_in,            &
                                            mm_pressure ) )
    call invoke( scale_field ( alpha, p_out ) )
  end subroutine apply_helmholtz

  !> @brief Construct CMA representation of Helmholtz operator
  !>        \f$\hat{H}=\alpha M_3 + \beta D_vM_{2,v,inv}D_v^T\f$
  !> @details Construct the CMA representation of \f$H\f$ from available CMAs
  !> @param[in]  alpha Scaling parameter \f$\alpha\f$
  !> @param[in]  beta Scaling parameter \f$\beta\f$
  !> @param[out] helmholtz_cma Helmholtz operator \f$\hat{H}\f$
  !>             in CMA representation
  subroutine assemble_helmholtz_cma(alpha,beta,helmholtz_cma)
    implicit none

    ! Passed parameters
    real(kind=r_def),               intent(in)    :: alpha, beta
    type(columnwise_operator_type), intent(inout) :: helmholtz_cma

    ! Internal variables
    type(columnwise_operator_type) :: mm_vel_v_inv_grad_v_cma
    type(columnwise_operator_type) :: div_v_mm_vel_v_inv_grad_v_cma
    logical :: test

    ! Construct \f$M_{u,v,inv}D_v^T\f$
    mm_vel_v_inv_grad_v_cma &
       = mm_vel_v_inv_diag_cma%columnwise_operator_product( grad_v_cma )
    call invoke( columnwise_op_mul_kernel_type( mm_vel_v_inv_diag_cma,   &
                                                grad_v_cma,              &
                                                mm_vel_v_inv_grad_v_cma ) )
    ! Construct \f$D_vM_{u,v,inv}D_v^T\f$
    div_v_mm_vel_v_inv_grad_v_cma &
         = div_v_cma%columnwise_operator_product( mm_vel_v_inv_grad_v_cma )
    call invoke( columnwise_op_mul_kernel_type( div_v_cma,               &
         mm_vel_v_inv_grad_v_cma, &
         div_v_mm_vel_v_inv_grad_v_cma ) )
    ! Construct \f$M_3 + D_vM_{u,v,inv}D_v^T\f$
    helmholtz_cma &
         = mm_pressure_cma%columnwise_operator_sum( div_v_mm_vel_v_inv_grad_v_cma )
    call invoke( columnwise_op_scaledadd_kernel_type( mm_pressure_cma,   &
                                                      div_v_mm_vel_v_inv_grad_v_cma, &
                                                      helmholtz_cma,     &
                                                      alpha,             &
                                                      beta) )
    
  end subroutine assemble_helmholtz_cma

  !> @brief Test application of pressure mass matrix
  !> @details Apply the pressure mass matrix
  !>          both as a LMA and as a CMA and compare the results.
  !> @param[in] tolerance Error tolerance for comparison
  subroutine test_cma_apply_mass_p(tolerance)
    implicit none
    real(kind=r_def), intent(in) :: tolerance
    character(len=32) :: label = "apply pressure mass matrix"

    call invoke( assign_field_random_kernel_type (p_in   ) )
    call invoke( set_field_scalar( 1.0_r_def, p_in       ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out      ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out_cma  ) )
    call invoke( columnwise_op_app_kernel_type( p_out_cma, &
                                                p_in,      &
                                                mm_pressure_cma ) )
    call invoke( matrix_vector_kernel_type( p_out,         &
                                            p_in,          &
                                            mm_pressure ) )
    call compare_fields(p_out,p_out_cma,tolerance,label)
  end subroutine test_cma_apply_mass_p

  !>@brief Test application of (vertical-only) velocity mass matrix
  !>@details Apply the (vertical-only) velocity mass matrix
  !>         both as a LMA and as a CMA and compare the results.
  !> @param[in] tolerance Error tolerance for comparison
  subroutine test_cma_apply_mass_v(tolerance)
    implicit none

    real(kind=r_def), intent(in) :: tolerance
    character(len=32) :: label = "apply vert velocity mass matrix"
    
    call invoke( assign_field_random_kernel_type (u_v_in) )
    call invoke( enforce_bc_kernel_type ( u_v_in ) )
    call invoke( set_field_scalar( 0.0_r_def, u_v_out     ) )
    call invoke( set_field_scalar( 0.0_r_def, u_v_out_cma ) )
    ! Apply velocity mass matrix in CMA representation
    call invoke( columnwise_op_app_kernel_type( u_v_out_cma, &
                                                u_v_in,      &
                                                mm_vel_v_cma ) )
    ! boundary conditioned need to be enforced manually for CMA operation
    call invoke( enforce_bc_kernel_type ( u_v_out_cma ) )
    ! Apply velocity mass matrix in LMA representation
    call invoke( matrix_vector_kernel_type( u_v_out,         &
                                            u_v_in,          &
                                            mm_vel_v ) )
    call compare_fields(u_v_out,u_v_out_cma,tolerance,label)
  end subroutine test_cma_apply_mass_v

  !>@brief Test application of (vertical-only) divergence operator
  !>@details Apply the (vertical-only) divergence operator
  !>         both as a LMA and as a CMA and compare the results.
  !> @param[in] tolerance Error tolerance for comparison
  subroutine test_cma_apply_div_v(tolerance)
    implicit none

    real(kind=r_def), intent(in) :: tolerance
    character(len=32) :: label = "apply vert divergence"
    
    call invoke( assign_field_random_kernel_type (u_v_in) )
    call invoke( enforce_bc_kernel_type ( u_v_in ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out     ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out_cma ) )
    ! Apply divergence operator in CMA representation
    call invoke( columnwise_op_app_kernel_type( p_out_cma,   &
                                                u_v_in,      &
                                                div_v_cma ) )
    ! Apply divergence operator in LMA representation
    call invoke( matrix_vector_kernel_type( p_out,           &
                                            u_v_in,          &
                                            div_v ) )
    call compare_fields(p_out,p_out_cma,tolerance,label)
  end subroutine test_cma_apply_div_v

  !>@brief Test multiplication of two CMA operators (divergence and mass matrix)
  !>@details Multiply the (vertical-only) divergence operator with the
  !>         corresponding velocity mass matrix in the CMA representation.
  !>         Apply the operator and compare to the separate application
  !>         of the two operators in LMA representation.
  !> @param[in] tolerance Error tolerance for comparison
  subroutine test_cma_multiply_div_v_mass_v(tolerance)
    implicit none

    real(kind=r_def), intent(in) :: tolerance
    type(columnwise_operator_type) :: div_v_mm_vel_v_cma
    character(len=32) :: label = "multiply D_v.M_{u,v}"

    ! Construct combined CMA operator \f$A = D_v.M_{u,v}\f$
    div_v_mm_vel_v_cma  = div_v_cma%columnwise_operator_product( mm_vel_v_cma)

    call invoke( columnwise_op_mul_kernel_type( div_v_cma,       &
                                                mm_vel_v_cma,    &
                                                div_v_mm_vel_v_cma ) )
    ! Initialise fields
    call invoke( assign_field_random_kernel_type (u_v_in) )
    call invoke( enforce_bc_kernel_type ( u_v_in ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out      ) )
    call invoke( set_field_scalar( 0.0_r_def, u_v_tmp    ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out_cma  ) )

    ! Apply combined CMA operator A = D_v.M_{u,v}
    call invoke( columnwise_op_app_kernel_type( p_out_cma,   &
                                                u_v_in,      &
                                                div_v_mm_vel_v_cma ) )
    ! Successively apply operators in LMA representation: 
    ! first M_{u,v}, then D_v
    call invoke( matrix_vector_kernel_type( u_v_tmp,      &
                                            u_v_in,       &
                                            mm_vel_v ) )
    call invoke( matrix_vector_kernel_type( p_out,        &
                                            u_v_tmp,      &
                                            div_v ) )

    call compare_fields(p_out,p_out_cma,tolerance,label)
   
  end subroutine test_cma_multiply_div_v_mass_v

  !>@brief Test multiplication of two CMA operators (gradient and divergence)
  !>@details Multiply the (vertical-only) gradient (i.e. the transpose of 
  !>         the divergence operator) with the (vertical-only) divergence operator 
  !>         and compare to the separate application of the two operators
  !>         in LMA representation.
  !> @param[in] tolerance Error tolerance for comparison
  subroutine test_cma_multiply_grad_v_div_v(tolerance)
    implicit none

    real(kind=r_def), intent(in) :: tolerance
    type(columnwise_operator_type) :: grad_v_div_v_cma
    character(len=32) :: label = "multiply D_v^T.D_v"

    ! Construct combined CMA operator A = D_v^T.D_v
    grad_v_div_v_cma  = grad_v_cma%columnwise_operator_product( div_v_cma)

    call invoke( columnwise_op_mul_kernel_type( grad_v_cma,       &
                                                div_v_cma,        &
                                                grad_v_div_v_cma ) )
    ! Initialise fields
    call invoke( assign_field_random_kernel_type (u_v_in) )
    call invoke( enforce_bc_kernel_type ( u_v_in ) )
    call invoke( set_field_scalar( 0.0_r_def, p_tmp       ) )
    call invoke( set_field_scalar( 0.0_r_def, u_v_out     ) )
    call invoke( set_field_scalar( 0.0_r_def, u_v_out_cma ) )

    ! Apply combined CMA operator A = D_v^T.D_v
    call invoke( columnwise_op_app_kernel_type( u_v_out_cma, &
                                                u_v_in,      &
                                                grad_v_div_v_cma ) )
    ! Manually apply boundary conditions
    call invoke( enforce_bc_kernel_type ( u_v_out_cma ) )
    ! Successively apply divergence and gradient operators:
    ! first D_v, then D_v^T
    call invoke( matrix_vector_kernel_type( p_tmp,           &
                                            u_v_in,          &
                                            div_v ) )
    call invoke( matrix_vector_kernel_type( u_v_out,         &
                                            p_tmp,           &
                                            grad_v ) )

    call compare_fields(u_v_out,u_v_out_cma,tolerance,label)
   
  end subroutine test_cma_multiply_grad_v_div_v

  !>@brief Test addition of two CMA operators
  !>@details Construct the Helmholtz CMA operator 
  !>         \f$H = \alpha M_3 + \beta D_v D_v^T\f$ in the CMA
  !>         representation. Compare the result of applying \f$A\f$
  !>         to applying the operators individually.
  !> @param[in] tolerance Error tolerance for comparison
  subroutine test_cma_add(tolerance)
    implicit none

    real(kind=r_def), intent(in) :: tolerance
    type(columnwise_operator_type) :: helmholtz_cma
    character(len=32) :: label = "add M_3+D_v.M_{u,v,inv}.D_v^T"
    real(kind=r_def) :: alpha, beta

    ! Choose arbitrary scaling parameters
    alpha = 2.5_r_def
    beta = 3.7_r_def
    call invoke( assign_field_random_kernel_type (p_in) )
    call invoke( set_field_scalar( 0.0_r_def, p_out     ) )   
    call invoke( set_field_scalar( 0.0_r_def, p_out_cma ) )
    ! Assemble CMA representation of Helmholtz operator
    ! (this is where the addition of two CMAs happens)
    call assemble_helmholtz_cma(alpha,beta,helmholtz_cma)
    ! Apply Helholtz operator using LMAs
    call apply_helmholtz(alpha,beta,p_in, p_out)
    ! Apply combined Helmholtz operator in CMA representation
    call invoke( columnwise_op_app_kernel_type( p_out_cma, &
                                                p_in,      &
                                                helmholtz_cma ) )
    call compare_fields(p_out,p_out_cma,tolerance,label)

  end subroutine test_cma_add

  !>@brief Test inversion of CMA operator
  !>@details Construct the CMA operator
  !>         \f$A = \alpha M_3 + \beta D_v M_{2,v,inv}D_v^T\f$
  !>         in the CMA representation and solve the system \f$Au=v\f$ where
  !>         \f$u\f$ is constructed by applying the components of \f$A\f$
  !>         to a given input field \f$u_{in}\f$. Then compare \f$u\f$ and
  !>         \f$u_{in}\f$ which should be identical.
  !> @param[in] tolerance Error tolerance for comparison

  subroutine test_cma_apply_inv(tolerance)
    implicit none

    real(kind=r_def), intent(in) :: tolerance
    type(columnwise_operator_type) :: helmholtz_cma
    character(len=32) :: label = "solve M_3+D_v.M_{u,v,inv}.D_v^T"
    real(kind=r_def) :: alpha, beta

    ! Choose arbitrary scaling parameters
    alpha = 2.5_r_def
    beta = 3.7_r_def

    call invoke( assign_field_random_kernel_type (p_in) )
    call invoke( set_field_scalar( 0.0_r_def, p_tmp      ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out_cma  ) )

    ! Assemble CMA representation of Helmholtz operator
    call assemble_helmholtz_cma(alpha,beta,helmholtz_cma)

    ! Apply Helholtz operator using LMAs
    call apply_helmholtz(alpha,beta,p_in, p_tmp)
    ! Solve to recover original field
    call invoke( columnwise_op_appinv_kernel_type( p_out_cma, &
                                                   p_tmp,     &
                                                   helmholtz_cma ) )
    call compare_fields(p_in,p_out_cma,tolerance,label)

  end subroutine test_cma_apply_inv    

  !>@brief Test operator \f$diag(D_h M_{2,h,inv} D_h^T)\f$
  !>@details Construct the CMA operator \f$D=diag(D_h M_{2,h,inv} D_h^T)\f$.
  !>         and apply it to a pressure field \f$p_{in}\f$ with exactly one entry to
  !>         obtain \f$p_{out}^{CMA}\f$. Apply
  !>         \f$D_h M_{2,h,inv} D_h\f$ in LMA representation to the same field to
  !>         obtain \f$p_{out}\f$. Then the dot-products \f$p_{out}.p_{in}\f$ and 
  !>         \f$p_{out}^{CMA}.p_{in}\f$ should be identical.
  !>
  !>         This test currently only works reliably on one processor.
  !> @param[in] tolerance Error tolerance for comparison
  subroutine test_cma_diag_DhMDhT(tolerance)
    implicit none
    type(columnwise_operator_type) :: diag_DhMDhT_cma
    real(kind=r_def), intent(in) :: tolerance
    character(len=32) :: label = "diag D_h.M_{u,h,inv}.D_h^T"
    type(field_type) :: p_out_masked, &
                        p_out_masked_cma


    p_out_masked     = field_type( fs_pressure )
    p_out_masked_cma = field_type( fs_pressure )

    call invoke( assign_field_single_column_kernel_type (p_in ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out           ) )
    call invoke( set_field_scalar( 0.0_r_def, p_out_cma       ) )
    call invoke( set_field_scalar( 0.0_r_def, u_h_tmp         ) )

    ! Build CMA representation of operator \f$diag(D_h M_{2,h,inv} D_h^T)\f$
    diag_DhMDht_cma = columnwise_operator_type ( fs_pressure, fs_pressure )
    call invoke ( columnwise_op_asm_diag_hmht_kernel_type( div_h,      &
                                                           mm_vel_h,   &
                                                           diag_DhMDhT_cma ) )

    ! Apply in CMA representation
    call invoke( columnwise_op_app_kernel_type( p_out_cma,      &
                                                p_in,           &
                                                diag_DhMDhT_cma ) )

    ! Apply in LMA representation
    ! Step 1: weak horizontal gradient
    call invoke( transpose_matrix_vector_kernel_type( u_h_tmp,     &
                                                      p_in,        &
                                                      div_h ) )
    ! Step 2: divide by diagonally lumped horizontal mass matrix
    call invoke( divide_field( u_h_tmp, mm_vel_h_diag ) )    
    ! Step 3: weak divergence
    call invoke( matrix_vector_kernel_type( p_out,       &
                                            u_h_tmp,     &
                                            div_h ) )

    ! Mask with input value to extract diagonal element
    call invoke( multiply_fields (p_out,     p_in, p_out_masked     ) )
    call invoke( multiply_fields (p_out_cma, p_in, p_out_masked_cma ) )

    call compare_fields(p_out_masked, p_out_masked_cma, tolerance,label)
        
  end subroutine test_cma_diag_DhMDhT 

end module cma_test_mod
