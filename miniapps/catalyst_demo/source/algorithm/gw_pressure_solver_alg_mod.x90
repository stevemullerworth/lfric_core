!-----------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! For further details please refer to the file LICENCE which you should have
! received as part of this distribution.
!-----------------------------------------------------------------------------
!>@brief Routines for solving the semi-implicit equation set by
!!       eliminating all variables in favour of the pressure increment

module gw_pressure_solver_alg_mod
  use field_mod,                          only: field_type
  use constants_mod,                      only: i_def, r_def
  use fem_constants_mod,                  only: get_inverse_w3_mass_matrix, &
                                                get_mass_matrix, &
                                                get_div
  use fs_continuity_mod,                  only: W0, W2, W3, Wtheta
  use initial_temperature_config_mod,     only: bvf_square
  use timestepping_config_mod,            only: dt
  use gravity_wave_constants_config_mod,  only: cs_square, b_space,                &
                                                gravity_wave_constants_b_space_w0, &
                                                gravity_wave_constants_b_space_w3, &
                                                gravity_wave_constants_b_space_wtheta
  use operator_mod,                       only: operator_type
  use field_indices_mod,                  only: igw_u, igw_p, igw_b
  use io_config_mod,                      only: subroutine_timers
  use timer_mod,                          only: timer

  implicit none

  private
  real(kind=r_def), private, parameter :: tau_u = 0.5_r_def
  real(kind=r_def), private, parameter :: tau_p = 0.5_r_def
  real(kind=r_def), private, parameter :: tau_b = 0.5_r_def
  integer(kind=i_def), private :: bundle_size = 3
  ! Auxiliary constants to group invokes
  real(kind=r_def), private    :: const1, const2

  ! Q matrix
  type(operator_type), private :: Q

  type(field_type), private :: pressure_rhs

  ! Fields for bicgstab (all W3)
  type(field_type), private :: res, p, v, s, t, z, y

  ! Increments
  type(field_type), private :: p_inc, b_inc, u_inc

  ! For building the rhs
  type(field_type), private :: rhs_u, rhs_p, mb_rb, hb_ru

  ! For building the lhs
  type(field_type), private :: grad_p, div_grad_p

  type(field_type), private :: Mb_lumped_inv, Hb_lumped_inv

  ! Sub algorithms used for solving the gw_pressure equation
  public  :: gw_pressure_solver_init
  public  :: gw_pressure_solver_alg
  private :: build_gw_pressure_rhs
  private :: apply_gw_pressure_lhs
  private :: bicgstab
  private :: back_substitute
  private :: gw_pressure_precondition

contains
!=============================================================================!
  !>@brief Create all the required fields for the Helmholtz solver
  !>@param[in] state Bundle of fields that are used in the semi-implicit solver
  subroutine gw_pressure_solver_init(state)
    use function_space_mod,            only: function_space_type
    use finite_element_config_mod,     only: element_order
    use quadrature_xyoz_mod,           only: quadrature_xyoz_type
    use quadrature_rule_gaussian_mod,  only: quadrature_rule_gaussian_type
    use compute_q_operator_kernel_mod, only: compute_q_operator_type
    use matrix_vector_kernel_mod,      only: matrix_vector_kernel_type
    use transpose_matrix_vector_kernel_mod, &
                                       only: transpose_matrix_vector_kernel_type
    use log_mod,                       only: log_event,         &
                                             LOG_LEVEL_INFO

    implicit none

    type(field_type), intent(in)        :: state(bundle_size)
    type(function_space_type), pointer  :: wp => null(), wu => null(), wb => null()
    type(field_type)                    :: ones, M_lumped, QT1
    type(operator_type), pointer        :: Mb => null(), Mu => null()
    type(quadrature_xyoz_type)          :: qr
    type(quadrature_rule_gaussian_type) :: quadrature_rule
    integer(kind=i_def)                 :: mesh_id

    call log_event( 'Constructing pressure solver...', LOG_LEVEL_INFO )

    ! Get needed function spaces
    mesh_id = state(igw_u)%get_mesh_id()
    wu => state(igw_u)%get_function_space()
    wp => state(igw_p)%get_function_space()
    wb => state(igw_b)%get_function_space()

    call pressure_rhs%initialise(vector_space = wp)
    call p_inc%initialise(vector_space = wp)
    call b_inc%initialise(vector_space = wb)
    call u_inc%initialise(vector_space = wu)

    ! For building the rhs
    call rhs_u%initialise(vector_space = wu)
    call rhs_p%initialise(vector_space = wp)
    call mb_rb%initialise(vector_space = wb)
    call hb_ru%initialise(vector_space = wu)

    ! Create bicgstab fields
    call v%initialise( vector_space = wp)
    call z%initialise( vector_space = wp)
    call p%initialise( vector_space = wp)
    call t%initialise( vector_space = wp)
    call s%initialise( vector_space = wp)
    call y%initialise( vector_space = wp)
    call res%initialise( vector_space = wp)

    ! Apply lhs
    call grad_p%initialise(vector_space = wu)
    call div_grad_p%initialise(vector_space = wp)

    ! Back substitute

    ! Compute inverse approximate Mt
    call ones%initialise(vector_space = wb)
    call M_lumped%initialise(vector_space = wb)
    call Mb_lumped_inv%initialise(vector_space = wb)

    select case(b_space)
      case(gravity_wave_constants_b_space_w0)
        Mb => get_mass_matrix(W0, mesh_id)
      case(gravity_wave_constants_b_space_w3)
        Mb => get_mass_matrix(W3, mesh_id)
      case(gravity_wave_constants_b_space_wtheta)
        Mb => get_mass_matrix(Wtheta, mesh_id)
    end select
    call invoke( name = "Compute inverse approximate Mt",       &
                 setval_c( ones,     1.0_r_def ),               &
                 setval_c( M_lumped, 0.0_r_def ),               &
                 matrix_vector_kernel_type(M_lumped, ones, Mb), &
                 X_divideby_Y(Mb_lumped_inv, ones, M_lumped) )

    ! Compute Q operator
    Q = operator_type( wu, wb )
    qr = quadrature_xyoz_type(element_order+2, quadrature_rule)
    call invoke( compute_q_operator_type(Q, qr) )

   ! Compute inverse approximate HB
    call ones%initialise(vector_space = wu)
    call M_lumped%initialise(vector_space = wu)
    call QT1%initialise(vector_space = wb)
    call Hb_lumped_inv%initialise(vector_space = wu)
    Mu => get_mass_matrix(W2, mesh_id)

    const1 = tau_u*tau_b*dt**2*bvf_square
    call invoke( name = "Compute inverse approximate HB",           &
                 setval_c(ones,     1.0_r_def),                     &
                 setval_c(M_lumped, 0.0_r_def),                     &
                 setval_c(QT1,      0.0_r_def),                     &
                 transpose_matrix_vector_kernel_type(QT1, ones, Q), &
                 inc_X_times_Y(QT1, Mb_lumped_inv),                 &
                 matrix_vector_kernel_type(M_lumped, QT1, Q),       &
                 inc_a_times_X(const1, M_lumped),                   &
                 matrix_vector_kernel_type(M_lumped, ones, Mu),     &
                 X_divideby_Y(HB_lumped_inv, ones, M_lumped) )

    nullify( Mb, Mu, wp, wu, wb )

    call log_event( 'done', LOG_LEVEL_INFO )

  end subroutine gw_pressure_solver_init

!=============================================================================!
  !>@brief Control routine for the gw_pressure solver to solve A*x0 = rhs0
  !>       Using the approximate Schur complement
  !>@details Control routine for the gw_pressure solver to solve A*x0 = rhs0
  !>         Using the approximate Schur complement of the form H*p = R
  !>         1) Builds the gw_pressure rhs: R
  !>         2) Solves for the presssure increment (p) using a Krylov method
  !>         3) Back substitutes to find remaining field increments
  !>@param[inout] x0 Field bundle containing the states to be incremented
  !>@param[in] rhs0 Field bundle containing the residuals
  subroutine gw_pressure_solver_alg(x0, rhs0)
    implicit none

    type(field_type), intent(inout) :: x0(bundle_size)
    type(field_type), intent(in)    :: rhs0(bundle_size)

    if ( subroutine_timers ) call timer('gw_pressure_solver_alg')
    ! Build Helmholtz RHS
    call build_gw_pressure_rhs(pressure_rhs, rhs0)

    ! Krylov solver to obtain pressure increment
    call bicgstab(p_inc, pressure_rhs)

    ! Back substitution to obtain other fields
    call back_substitute(x0, rhs0)
    if ( subroutine_timers ) call timer('gw_pressure_solver_alg')

  end subroutine gw_pressure_solver_alg

!=============================================================================!
  !>@brief Compute the rhs to the gw_pressure equation for the pressure increment
  !>@param[inout] gw_pressure_rhs Right hand side of the Helmholtz equation
  !>@param[in]    rhs0            Initial residuals used to form gw_pressure_rhs
  subroutine build_gw_pressure_rhs(gw_pressure_rhs, rhs0)
    use matrix_vector_kernel_mod,    only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use log_mod,                     only: LOG_LEVEL_DEBUG
    use enforce_bc_kernel_mod,       only: enforce_bc_kernel_type

    implicit none
    type(field_type),                intent(inout) :: gw_pressure_rhs
    type(field_type),                intent(in)    :: rhs0(bundle_size)

    type(operator_type), pointer :: div => null(), M3_inv => null()

    ! rhs = Rp - tau_p * dt * cs^2 * M3^-1 * D * HB^-1 * rhs_u
    ! rhs_u = Ru + tau_u * dt * Q * Mb^-1 * Rb

    ! Compute rhs_u
    const1 = tau_u*dt
    call invoke( name = "Compute rhs_u",                       &
                 X_times_Y(mb_rb, rhs0(igw_b), Mb_lumped_inv), &
                 setval_c( rhs_u, 0.0_r_def ),                 &
                 matrix_vector_kernel_type(rhs_u, mb_rb, Q),   &
                 inc_aX_plus_Y(const1, rhs_u, rhs0(igw_u)),    &
                 enforce_bc_kernel_type(rhs_u) )

    ! Compute rhs
    div    => get_div()
    M3_inv => get_mass_matrix(w3inv_id)
    const2 = -tau_p*dt*cs_square
    call invoke( name = "Compute rhs",                                         &
                 X_times_Y(hb_ru, rhs_u, Hb_lumped_inv),                       &
                 dg_matrix_vector_kernel_type(rhs_p, hb_ru, div),              &
                 dg_matrix_vector_kernel_type(gw_pressure_rhs, rhs_p, M3_inv), &
                 inc_aX_plus_Y(const2, gw_pressure_rhs, rhs0(igw_p)) )

    call gw_pressure_rhs%log_minmax(LOG_LEVEL_DEBUG,  'gw_pressure_rhs ')

    nullify( div, M3_inv )

  end subroutine build_gw_pressure_rhs

!=============================================================================!
  !>@brief Apply the full Helmholtz lhs to a pressure field p, this is the Ax
  !>       routine called from the Krylov solver
  !>@param[inout] Hp Field resulting from the application of the Helmholtz
  !!              matrix H on the input field p
  !>@param[inout] p Pressure field to apply the Helmholtz matrix to
  subroutine apply_gw_pressure_lhs(Hp, p)
    use dg_matrix_vector_kernel_mod,        only: dg_matrix_vector_kernel_type
    use transpose_matrix_vector_kernel_mod, only: transpose_matrix_vector_kernel_type
    use enforce_bc_kernel_mod,              only: enforce_bc_kernel_type

    implicit none
    type(field_type),                intent(inout) :: Hp
    type(field_type),                intent(inout) :: p

    type(operator_type), pointer :: div => null(), M3_inv => null()
    integer(kind=i_def)          :: mesh_id

    ! lhs = (I + tau_p*tau_u*dt^2*cs^2*M3^-1 * D * HB^-1 * D^T)*p
    mesh_id = p%get_mesh_id()
    div    => get_div(mesh_id)
    M3_inv => get_inverse_w3_mass_matrix(mesh_id)
    const1 = tau_p*tau_u*dt**2*cs_square
    call invoke( name = "Apply GW pressure lhs",                        &
                 setval_c(grad_p, 0.0_r_def),                           &
                 transpose_matrix_vector_kernel_type(grad_p, p, div),   &
                 enforce_bc_kernel_type(grad_p),                        &
                 inc_X_times_Y(grad_p, Hb_lumped_inv),                  &
                 dg_matrix_vector_kernel_type(div_grad_p, grad_p, div), &
                 dg_matrix_vector_kernel_type(Hp, div_grad_p, M3_inv),  &
                 inc_aX_plus_Y(const1, Hp, p) )

    nullify( div, M3_inv )

  end subroutine apply_gw_pressure_lhs

!=============================================================================!
  !>@brief Krylov solver specifically for solving the Helmholtz equation
  !!       A*lhs = rhs
  !>@param[inout] lhs Field to solver for
  !>@param[in]    rhs Residual field
  subroutine bicgstab(lhs, rhs)
    use helmholtz_solver_config_mod, only: si_pressure_maximum_iterations, &
                                           si_pressure_tolerance
    use log_mod,                     only: log_event,          &
                                           log_scratch_space,  &
                                           LOG_LEVEL_ERROR,    &
                                           LOG_LEVEL_INFO,     &
                                           LOG_LEVEL_DEBUG,    &
                                           LOG_LEVEL_TRACE
    implicit none
    type(field_type),             intent(inout) :: lhs
    type(field_type),             intent(in)    :: rhs

    ! The scalars
    real(kind=r_def)                   :: rho,alpha,omega,beta, norm
    real(kind=r_def)                   :: ts,tt
    ! Others
    real(kind=r_def)                   :: err,sc_err, init_err
    integer(kind=i_def)                :: iter

    ! Compute the residual this is a global sum to the PSy ---
    call invoke( X_innerproduct_X(sc_err, rhs) )
    sc_err = max(sqrt(sc_err), 0.001_r_def)
    write( log_scratch_space, '(A,E15.8)' ) &
         "solver_algorithm: bicgstab starting ... ||b|| = ", sc_err
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    alpha  = 1.0_r_def
    omega  = 1.0_r_def
    norm   = 1.0_r_def

    call invoke( setval_c(lhs, 0.0_r_def), &
                 setval_X(res, rhs),       &
                 X_innerproduct_X(err, res) )
    err = sqrt(err)/sc_err
    init_err=err
    if (err < si_pressure_tolerance) then
      write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)')     &
           'gravity_wave:'//                                  &
           ' gw_pressure solver_algorithm converged in ', 0,  &
           ' iters, init=', init_err,                         &
           ' final=', err
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      return
    end if

    call invoke( setval_c(v, 0.0_r_def), &
                 setval_c(p, 0.0_r_def) )

    do iter = 1, si_pressure_maximum_iterations

      call invoke( X_innerproduct_Y(rho, res, rhs) )
      beta = (rho/norm) * (alpha/omega)
      ! p = r + beta*(p - omega*v)
      const1 = -beta*omega
      call invoke( inc_aX_plus_Y(beta, p, res), &
                   inc_X_plus_bY(p, const1, v) )
      call gw_pressure_precondition( y, p)
      call apply_gw_pressure_lhs( v, y)

      call invoke( X_innerproduct_Y(norm, rhs, v) )
      alpha = rho/norm
      call invoke( X_minus_bY(s, res, alpha, v) )
      call gw_pressure_precondition( z, s )
      call apply_gw_pressure_lhs( t, z )

      call invoke( X_innerproduct_X(tt, t), &
                   X_innerproduct_Y(ts, t, s) )

      omega = ts/tt

      ! lhs = lhs + omega * z + alpha * y
      call invoke( inc_X_plus_bY(lhs, omega, z), &
                   inc_X_plus_bY(lhs, alpha, y), &
                   X_minus_bY(res, s, omega, t) )

      norm = rho

      ! Check for convergence
      call invoke( X_innerproduct_X(err, res) )
      err = sqrt(err)/sc_err

      write( log_scratch_space, '(A,I2,A, E15.8)' ) "solver_algorithm[", iter, &
                                                    "]: res = ", err
      call log_event(log_scratch_space, LOG_LEVEL_DEBUG)

      if (err < si_pressure_tolerance) then
        write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
             "Helmholtz solver_algorithm:converged in ", iter,    &
             " iters, init=", init_err,                           &
             " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if
    end do

    if(iter >= si_pressure_maximum_iterations) then
      write(log_scratch_space, '(A, I3, A, E15.8)')         &
           "Helmholtz solver_algorithm: NOT converged in ", &
           iter, " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if
  end subroutine bicgstab

!=============================================================================!
  !>@brief Obtain the increments to each field from the pressure field given by
  !>       the gw_pressure equation
  !>@param[inout] state Field bundle to increment
  !>@param[in] rhs Initial residual array use to compute increments
  subroutine back_substitute(state, rhs)

    use transpose_matrix_vector_kernel_mod, &
                                  only: transpose_matrix_vector_kernel_type
    use log_mod,                  only: LOG_LEVEL_DEBUG
    use enforce_bc_kernel_mod,    only: enforce_bc_kernel_type

    implicit none
    type(field_type),                intent(inout) :: state(bundle_size)
    type(field_type),                intent(in)    :: rhs(bundle_size)

    type(operator_type), pointer :: div => null()

    ! Initialise increment fields
    call invoke( setval_c(u_inc, 0.0_r_def), &
                 setval_c(b_inc, 0.0_r_def) )
    ! U increment
    div => get_div(u_inc%get_mesh_id())
    const1 = tau_u*dt
    call invoke( name = "Compute U increment",                           &
                 transpose_matrix_vector_kernel_type(u_inc, p_inc, div), &
                 inc_aX_plus_Y(const1, u_inc, rhs_u),                    &
                 inc_X_times_Y(u_inc, Hb_lumped_inv),                    &
                 enforce_bc_kernel_type(u_inc) )

    ! b increment
    const2 = -tau_b*dt*bvf_square
    call invoke( name = "Compute b increment",                         &
                 transpose_matrix_vector_kernel_type(b_inc, u_inc, Q), &
                 inc_aX_plus_Y(const2, b_inc, rhs(igw_b)),             &
                 inc_X_times_Y(b_inc, Mb_lumped_inv) )

    call u_inc%log_minmax(LOG_LEVEL_DEBUG,  'u increment')
    call p_inc%log_minmax(LOG_LEVEL_DEBUG,  'p increment')
    call b_inc%log_minmax(LOG_LEVEL_DEBUG,  'b increment')

    call invoke( name = "Increment all states",     &
                 inc_X_plus_Y(state(igw_u), u_inc), &
                 inc_X_plus_Y(state(igw_p), p_inc), &
                 inc_X_plus_Y(state(igw_b), b_inc) )

    nullify( div )

  end subroutine back_substitute

!=============================================================================!
  !>@brief Preconditioner for the gw_pressure equation
  !>@details Options to precondition the gw_pressure equation, currently allows only
  !>         preconditioning with the inverse mass matrix or no preconditioner
  !>@param[inout] y Preconditioned field to compute
  !>@param[in]    x Field to apply preconditioner to
  !>@param[in]    prec optional flag to specify the type of preconditioner used
  subroutine gw_pressure_precondition(y, x, prec)

    implicit none
    type(field_type),             intent(inout) :: y
    type(field_type),             intent(in)    :: x
    integer, intent(in), optional :: prec
    integer                       :: precon

    if ( present(prec) ) precon = prec

    call invoke( setval_X( y, x ) )

  end subroutine gw_pressure_precondition
!=============================================================================!

end module gw_pressure_solver_alg_mod

