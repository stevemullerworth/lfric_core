!-----------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! For further details please refer to the file LICENCE which you should have
! received as part of this distribution.
!-----------------------------------------------------------------------------

!> @brief Diagonal preconditioner for the gravity-wave system
!>
!> @details This type is derived from the abstract preconditioner type and
!> implements a preconditioner for the mixed gravity-wave system in the
!> variables \f$(\mathbf{U},P,B)\f$.
!>
!> This preconditioner simply divides each of the fields by the corresponding
!> diagonal mass matrix.

module gw_mixed_diag_precon_alg_mod

  use constants_mod,                  only: i_def
  use vector_mod,                     only: abstract_vector_type
  use preconditioner_mod,             only: abstract_preconditioner_type
  use field_mod,                      only: field_type
  use field_vector_mod,               only: field_vector_type
  use log_mod,                        only: log_event,       &
                                            LOG_LEVEL_ERROR, &
                                            LOG_LEVEL_INFO,  &
                                            LOG_LEVEL_DEBUG, &
                                            log_scratch_space
  use io_config_mod,                  only: subroutine_timers
  use timer_mod,                      only: timer

  implicit none

  private

  !> @brief Mixed diagonal preconditioner type
  !>
  !> @details Implements mixed diagonal preconditioner which can be used in the
  !> iterative solver algorithms.
  type, public, extends(abstract_preconditioner_type) :: &
                        gw_mixed_diag_preconditioner_type

     private

     !> Diagonal mass matrices
     type(field_type) :: mm_diagonal_p, mm_diagonal_u, mm_diagonal_b

     contains

     ! Overide the (abstract interface) for application of
     ! a preconditioner \f$y = P.x\f$
     procedure, public :: apply => apply_gw_mixed_diag_preconditioner
     procedure, private :: apply_gw_mixed_diag_preconditioner

     !> Performs a deep copy (for overriding the "=" operator)
     procedure, public  :: gw_mixed_diag_preconditioner_assign

     !> Destructor
     final :: destroy_gw_mixed_diag_preconditioner

     !> Override default assignment for gw_mixed_diag_preconditioner_type pairs.
     generic            :: assignment(=) => gw_mixed_diag_preconditioner_assign

  end type gw_mixed_diag_preconditioner_type

  ! Overload the default structure constructor
  interface gw_mixed_diag_preconditioner_type
     module procedure gw_mixed_diag_preconditioner_constructor
  end interface

contains

  !> @brief Construct a <code> gw_mixed_diag_preconditioner_type</code> object
  !>
  !> @details This constructs all required fields and builds operators.
  !>
  !> @param[in] state Current state (passed as a field-vector)
  !> @return self The constructed preconditioner object
  function gw_mixed_diag_preconditioner_constructor(state) result(self)

    use gravity_wave_constants_config_mod, only: b_space,    &
                                                 b_space_w0, &
                                                 b_space_w3, &
                                                 b_space_wtheta
    use fem_constants_mod,                 only: get_mass_matrix_diagonal
    use fs_continuity_mod,                 only: W0, W2, W3, Wtheta
    use field_indices_mod,                 only: igw_u


    implicit none

    type(field_vector_type), intent(in) :: state
    type(gw_mixed_diag_preconditioner_type)  :: self
    integer(kind=i_def) :: mesh_id

    call log_event('Constructing gravity waves mixed diag preconditioner...', &
                   LOG_LEVEL_INFO )
    mesh_id = state%vector(igw_u)%get_mesh_id()
    self%mm_diagonal_u = get_mass_matrix_diagonal(W2, mesh_id)
    self%mm_diagonal_p = get_mass_matrix_diagonal(W3, mesh_id)
    select case(b_space)
      case(b_space_w0)
        self%mm_diagonal_b = get_mass_matrix_diagonal(W0, mesh_id)
      case(b_space_w3)
        self%mm_diagonal_b = get_mass_matrix_diagonal(W3, mesh_id)
      case(b_space_wtheta)
        self%mm_diagonal_b = get_mass_matrix_diagonal(Wtheta, mesh_id)
    end select

    call log_event( 'done', LOG_LEVEL_INFO )

  end function gw_mixed_diag_preconditioner_constructor

  !> @brief Performs a deep copy between gw_mixed_diag_preconditioner_type pairs
  !> (for overriding the "=" operator).
  !>
  !> @param[in]  source gw_mixed_diag_preconditioner_type rhs
  !> @param[out] dest   gw_mixed_diag_preconditioner_type lhs
  subroutine gw_mixed_diag_preconditioner_assign(dest, source)

    implicit none

    class(gw_mixed_diag_preconditioner_type), intent(in)  :: source
    class(gw_mixed_diag_preconditioner_type), intent(out) :: dest

    ! Deep copy of the contents of the pressure_operator_type
    call source%mm_diagonal_p%copy_field(dest%mm_diagonal_p)
    call source%mm_diagonal_u%copy_field(dest%mm_diagonal_u)
    call source%mm_diagonal_b%copy_field(dest%mm_diagonal_b)

  end subroutine gw_mixed_diag_preconditioner_assign

  !> @brief Apply the preconditioner to calculate \f$y = P.x\f$ for the
  !> mixed system in velocity, pressure and buoyancy
  !>
  !> @details Apply the preconditioner by dividing each of the fields in the
  !> fieldvector by its associated mass matrix
  !>
  !> @param[in,out] self Instance of type gw_mixed_preconditioner_type
  !> @param[in]     x    Field-vector containing the residuals
  !>                     \f$(\textbf{R}_u,R_p,r_b)\f$
  !> @param[in,out] y    Field-vector containing the solution
  !>                     \f$(\textbf{U},P,B)\f$ to be calculated
  subroutine apply_gw_mixed_diag_preconditioner(self, x, y)

    use field_indices_mod,          only: igw_u, igw_p, igw_b

    implicit none

    class(gw_mixed_diag_preconditioner_type), intent(inout) :: self
    class(abstract_vector_type),              intent(in)    :: x
    class(abstract_vector_type),              intent(inout) :: y

    if ( subroutine_timers ) call timer('gw_mixed_diag_precon_alg')
    select type(x)
    type is(field_vector_type)
       select type(y)
       type is(field_vector_type)
          call invoke( X_divideby_Y(y%vector(igw_u),                &
                                    x%vector(igw_u),                &
                                    self%mm_diagonal_u),            &
                       X_divideby_Y(y%vector(igw_p),                &
                                    x%vector(igw_p),                &
                                    self%mm_diagonal_p),            &
                       X_divideby_Y(y%vector(igw_b),                &
                                    x%vector(igw_b),                &
                                    self%mm_diagonal_b) )
       class default
          write(log_scratch_space, '(A)') &
               "gw_mixed_diag_preconditioner_mod: incorrect vector_type argument y"
          call log_event(log_scratch_space, LOG_LEVEL_ERROR)
       end select

    class default
       write(log_scratch_space, '(A)') &
             "gw_mixed_diag_preconditioner_mod: incorrect vector_type argument x"
       call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

    if ( subroutine_timers ) call timer('gw_mixed_diag_precon_alg')

  end subroutine apply_gw_mixed_diag_preconditioner

  !> @brief Destructor
  !> @param[in,out] self Instance of type to be destroyed
  subroutine destroy_gw_mixed_diag_preconditioner(self)

    implicit none

    type(gw_mixed_diag_preconditioner_type), intent(inout) :: self

  end subroutine destroy_gw_mixed_diag_preconditioner

end module gw_mixed_diag_precon_alg_mod
