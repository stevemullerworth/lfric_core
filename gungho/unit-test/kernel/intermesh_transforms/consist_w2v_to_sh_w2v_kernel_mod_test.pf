!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the kernel mapping from W2v to the shifted W2v space
!>
module consist_w2v_to_sh_w2v_kernel_mod_test

  use constants_mod,         only: i_def, r_def
  use pFUnit_Mod


  implicit none

  private
  public :: consist_w2v_to_sh_w2v_test_type, test_all

  @TestCase
  type, extends(MPITestCase) :: consist_w2v_to_sh_w2v_test_type
    private
  contains

    procedure setUp
    procedure tearDown
    procedure test_all

  end type consist_w2v_to_sh_w2v_test_type

contains
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(consist_w2v_to_sh_w2v_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod, only: final_configuration

    implicit none

    class(consist_w2v_to_sh_w2v_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine test_all( this )

    use consist_w2v_to_sh_w2v_kernel_mod, only : consist_w2v_to_sh_w2v_code

    implicit none

    class(consist_w2v_to_sh_w2v_test_type), intent(inout) :: this

    real(kind=r_def), parameter ::  tol = 1.0e-12_r_def
    real(kind=r_def), parameter ::   dx = 5.0_r_def
    real(kind=r_def), parameter ::   dy = 4.0_r_def

    ! Fields
    real(kind=r_def), allocatable :: u_sh_field(:)
    real(kind=r_def), allocatable :: u_field(:)
    real(kind=r_def), allocatable :: answer(:)
    real(kind=r_def), allocatable :: height_wt(:)
    real(kind=r_def), allocatable :: height_wt_sh(:)

    integer(kind=i_def) :: cell, k

    ! Sizes
    integer(kind=i_def) :: nlayers, nlayers_sh, ncells
    integer(kind=i_def) :: ndf_w2v_sh, ndf_wt_sh
    integer(kind=i_def) :: ndf_w2v, ndf_wt
    integer(kind=i_def) :: undf_w2v_sh, undf_wt_sh
    integer(kind=i_def) :: undf_w2v, undf_wt

    ! Dofmaps
    integer(kind=i_def), allocatable :: map_w2v(:,:), map_w2v_sh(:,:)
    integer(kind=i_def), allocatable :: map_wt(:,:), map_wt_sh(:,:)

    ! just consider a single column of three layers
    nlayers = 3
    nlayers_sh = 4
    ndf_w2v = 2
    undf_w2v = 4
    ndf_w2v_sh = 2
    undf_w2v_sh = 5
    ndf_wt = 2
    undf_wt = 4
    ndf_wt_sh = 1
    undf_wt_sh = 5
    ncells = 1
    cell = 1

    ! Create the data
    allocate( u_sh_field(undf_w2v_sh) )
    allocate( u_field(undf_w2v) )
    allocate( answer(undf_w2v_sh) )
    allocate( map_w2v_sh(ndf_w2v, ncells) )
    allocate( map_w2v(ndf_w2v, ncells) )
    allocate( map_wt_sh(ndf_wt, ncells) )
    allocate( map_wt(ndf_wt, ncells) )

    ! Only one cell so all maps are to first cell
    map_w2v_sh(:,:) = reshape( [1_i_def, 2_i_def], [2,1])
    map_wt_sh(:,:)  = reshape( [1_i_def, 2_i_def], [2,1])
    map_w2v(:,:)    = reshape( [1_i_def, 2_i_def], [2,1])
    map_wt(:,:)     = reshape( [1_i_def, 2_i_def], [2,1])

    ! Set up the height fields for the meshes
    ! These are used for the initial conditions but not by the kernel
    ! Let's consider a quadratic extrusion
    height_wt    = (/ 0.0_r_def, 1.0_r_def, 4.0_r_def, 9.0_r_def /)
    height_wt_sh = (/ 0.0_r_def, 0.5_r_def, 2.5_r_def, 6.5_r_def, 9.0_r_def /)

    ! Now set up initial field in w2v and the answer in shifted w2v
    ! Assume a horizontal velocity that is constant in the vertical direction
    ! Vertical velocity varies linearly
    u_field(:) = 0.0_r_def
    answer(:) = 0.0_r_def

    do k = 1, nlayers
      u_field(map_w2v(1, cell)+k-1) = height_wt(map_wt(1, cell)+k-1) * dx * dy
    end do

    u_field(map_w2v(2, cell)+nlayers-1) = height_wt(map_wt(2, cell)+nlayers-1) * dx * dy

    ! Set up shifted w2v fields (including the answer)
    do k = 1, nlayers_sh
      answer(map_w2v_sh(1, cell)+k-1) = height_wt_sh(map_wt_sh(1, cell)+k-1) * dx * dy
    end do

    answer(map_w2v_sh(2, cell)+nlayers_sh-1) = &
      height_wt_sh(map_wt_sh(2, cell)+nlayers_sh-1) * dx * dy

    ! Perform kernel
    u_sh_field(:) = 0.0_r_def

    call consist_w2v_to_sh_w2v_code(  nlayers_sh,       &
                                      u_sh_field,       &
                                      u_field,          &
                                      ndf_w2v_sh,       &
                                      undf_w2v_sh,      &
                                      map_w2v_sh,       &
                                      ndf_w2v,          &
                                      undf_w2v,         &
                                      map_w2v           &
                                    )

    @assertEqual(answer(:), u_sh_field(:), tol)

    deallocate( u_sh_field )
    deallocate( u_field )
    deallocate( answer )
    deallocate( map_w2v_sh )
    deallocate( map_w2v )
    deallocate( map_wt_sh )
    deallocate( map_wt )

  end subroutine test_all

end module consist_w2v_to_sh_w2v_kernel_mod_test
