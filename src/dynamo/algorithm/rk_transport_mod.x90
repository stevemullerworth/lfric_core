!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the transport equation
!>@details An algorithm for timstepping the 3D transport equation using a
!>         multistage explicit Runge-Kutta algorithm.
module rk_transport_mod

  use constants_mod,                     only: r_def, i_def
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE

  ! Configuration and restart/checkpoint options
  use finite_element_config_mod,         only: element_order
  use restart_control_mod,               only: restart_type
  use solver_config_mod,                 only: method,         &
                                               preconditioner, &
                                               solver_preconditioner_diagonal
  use timestepping_config_mod,           only: dt
  use runge_kutta_init_mod,              only: num_rk_stage, ak
  use runtime_constants_mod,             only: get_mass_matrix, &
                                               get_mass_matrix_diagonal, &
                                               get_qr
  use transport_config_mod,              only: operators, &
                                               fv_flux_order, &
                                               fv_advective_order, &
                                               transport_operators_fv, &
                                               transport_operators_fem
  use formulation_config_mod,            only: supg

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                   only: invoke_axpy,                   &
                                               invoke_copy_field_data,        &
                                               invoke_set_field_scalar,       &
                                               invoke_sample_poly_flux,       &
                                               invoke_sample_poly_adv,        &
                                               invoke_divide_field
  ! PsyKAl PSYClone kernels
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use flux_rhs_kernel_mod,               only: flux_rhs_kernel_type
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use rtheta_supg_kernel_mod,            only: rtheta_supg_kernel_type


  use sample_poly_flux_kernel_mod,       only: sample_poly_flux_init
  use sample_poly_adv_kernel_mod,        only: sample_poly_adv_init

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use operator_mod,                      only: operator_type

  ! Algorithms
  use solver_mod,                        only: solver_algorithm
  ! Log
  use log_mod,                           only: log_event,         &
                                               LOG_LEVEL_ERROR
  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type ) :: rho_n, r_u, r_rho, rho_inc, mass_flux, &
                        theta_n, r_theta, theta_inc
  type( field_type ), allocatable :: rr_prediction(:), rt_prediction(:)

  type( field_type ) :: mt_lumped
  type( field_type ) :: rho0, theta0
  type( field_type ) :: ones

  integer(i_def) :: flux_stencil_extent, &
                    advective_stencil_extent

  public :: rk_transport_init
  public :: rk_transport_step
  public :: rk_transport_final

contains

  !> @brief Init routine for rk transport timestepping algorithm
  !> @details Rho and u fields are initialised before
  !>          this algorithm is called. State items are created,
  !> @param[in]    mesh_id Mesh id of mesh on which the model runs
  !> @param[in]    u The 3D wind field
  !> @param[inout] rho The density
  subroutine rk_transport_init( mesh_id, u, rho, theta)
    use mesh_mod,                          only: mesh_type
    use mesh_collection_mod,               only: mesh_collection
    use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
    implicit none

    ! Mesh id
    integer(i_def),  intent(in) :: mesh_id
    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta

    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: theta_fs => null()
    type( mesh_type ),         pointer :: mesh     => null()

    ! Timestepping variables
    integer :: stage
    type(operator_type)       :: mm_wt

    allocate ( rr_prediction(num_rk_stage) )
    allocate ( rt_prediction(num_rk_stage) )

    !=== Section 1: Create field objects =====================================!
    ! Local fields
    u_fs     => function_space_collection%get_fs(mesh_id, element_order, &
                                                 u%which_function_space())
    rho_fs   => function_space_collection%get_fs(mesh_id, element_order, &
                                                 rho%which_function_space())
    theta_fs => function_space_collection%get_fs(mesh_id, element_order, &
                                                 theta%which_function_space())


    rho_n        = field_type( vector_space = rho_fs )
    r_rho        = field_type( vector_space = rho_fs )
    rho_inc      = field_type( vector_space = rho_fs )
    r_u          = field_type( vector_space = u_fs )
    mass_flux    = field_type( vector_space = u_fs )
    theta_n      = field_type( vector_space = theta_fs )
    r_theta      = field_type( vector_space = theta_fs )
    theta_inc    = field_type( vector_space = theta_fs )


    do stage = 1,num_rk_stage
      rr_prediction(stage) = field_type( vector_space = rho_fs )
      rt_prediction(stage) = field_type( vector_space = theta_fs )
    end do


    call invoke_set_field_scalar(0.0_r_def, mass_flux)

    if ( operators == transport_operators_fv ) then
      if ( element_order == 0 ) then
        mesh => mesh_collection%get_mesh( mesh_id )
        call sample_poly_flux_init(fv_flux_order, mesh%get_nlayers())
        call sample_poly_adv_init (fv_advective_order, mesh%get_nlayers())
        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
      else
        call log_event( "Dynamo: subgrid mappings needed for FV MoL with high order elements", LOG_LEVEL_ERROR )
      end if
      mm_wt = get_mass_matrix(5)
      ones  = field_type( vector_space = theta_fs )
      mt_lumped  = field_type( vector_space = theta_fs )
      call invoke_set_field_scalar( 1.0_r_def, ones )
      call invoke_set_field_scalar( 0.0_r_def, mt_lumped)
      call invoke(matrix_vector_kernel_type(mt_lumped, ones, mm_wt) )
    else
      ones  = field_type( vector_space = rho_fs)
      call invoke_set_field_scalar( 1.0_r_def, ones )
    end if

    ! Store initial values for computing errors
    rho0   = rho
    theta0 = theta

  end subroutine rk_transport_init

  !> @brief A Runge-Kutta time-discretisation of the transport equation
  !> @details An algorithm for timstepping the transport equation using the
  !>          Runge-Kutta algorithm. theta, rho and u fields are initialised before
  !>          this algorithm is called.
  !>          If fem advection is used theta must be in W0,
  !>          If fv advection is used theta must be in Wtheta
  !> @param[in]    mesh_id Mesh id of mesh on which the model runs
  !> @param[inout] chi  The finite element form of the coordinates
  !> @param[in]    u The 3D wind field
  !> @param[inout] rho The density like tracer
  !> @param[inout] theta The temperature like tracer

  subroutine rk_transport_step( mesh_id, chi, u, rho, theta)

    implicit none

    ! Mesh id
    integer(i_def),  intent(in) :: mesh_id
    ! Coordinate fields
    type( field_type ), intent( inout ) :: chi(3)
    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta

    ! the quadrature object
    type( quadrature_type )          :: qr

    integer(i_def) :: stage, st


    ! temps for retrieving objects back from runtime constants
    type(operator_type), pointer :: mm_w2, mm_w3_inv, mm_w0 => null()
    type(field_type),    pointer :: mm_w0_d => null()
    
    qr = get_qr()

    ! Create operators needed for timestepping
    mm_w2     => get_mass_matrix(2)
    mm_w3_inv => get_mass_matrix(4)
    if ( operators == transport_operators_fem ) then
      mm_w0 => get_mass_matrix(0)
      mm_w0_d => get_mass_matrix_diagonal(0)
    end if
    call invoke_copy_field_data(rho,   rho_n)
    call invoke_copy_field_data(theta, theta_n)


    ! Runge-Kutta algorithm
    do stage = 1,num_rk_stage
      ! Compute advection terms
      ! mass flux ( F = rho * u )
      select case(operators)
        case(transport_operators_fv)
          ! Use polynomial reconstruction
          call invoke_sample_poly_flux( mass_flux, u, rho, &
                                        flux_stencil_extent )
          call invoke_sample_poly_adv( rt_prediction(stage), u, theta, &
                                       advective_stencil_extent )
        case(transport_operators_fem)      
          ! Use FEM projection
          ! Rho advection, compute mass flux
          call invoke_set_field_scalar(0.0_r_def, r_u)
          call invoke(flux_rhs_kernel_type( r_u, u, rho, chi, qr ) )
          call invoke(enforce_bc_kernel_type( r_u ) )

          call invoke_set_field_scalar(0.0_r_def, mass_flux)
          call solver_algorithm( mass_flux, r_u, mesh_id, chi, method, mm=mm_w2 )

          ! theta advection
          call invoke_set_field_scalar( 0.0_r_def, rt_prediction(stage) )
          call invoke( rtheta_kernel_type( rt_prediction(stage), theta, u, ones, qr) )
          if ( supg ) &
            call invoke( rtheta_supg_kernel_type( rt_prediction(stage),     &
                                theta, theta_n, u, ones, chi, qr) )
        case default
          call log_event( "Dynamo: Invalid advection method", LOG_LEVEL_ERROR )
     end select
      ! Compute rrho = div(F)
      call invoke( rrho_kernel_type  ( rr_prediction(stage), mass_flux, qr ) )

      call invoke_set_field_scalar(0.0_r_def, r_rho)
      call invoke_set_field_scalar(0.0_r_def, r_theta)

      do st = 1, stage
        call invoke_axpy(ak(stage,st), rr_prediction(st), r_rho,   r_rho)
        call invoke_axpy(ak(stage,st), rt_prediction(st), r_theta, r_theta)
      end do

      ! Invert mass matrices and add increments
      ! Rho
      call invoke_set_field_scalar( 0.0_r_def, rho_inc )
      call invoke( matrix_vector_kernel_type( rho_inc, r_rho, mm_w3_inv) )
      call invoke_axpy(dt, rho_inc, rho_n,   rho)

      ! Theta
      select case(operators)
        case(transport_operators_fv) ! theta in Wtheta
          call invoke_divide_field(r_theta, mt_lumped, r_theta)
          call invoke_axpy(-dt,r_theta, theta_n, theta)
        case(transport_operators_fem) ! theta in W0
          call solver_algorithm( theta_inc, r_theta,       &
                                 mesh_id, chi, method, mm=mm_w0,&
                                 mmd=mm_w0_d, &
                                 preconditioner_choice=preconditioner )
           call invoke_axpy(dt, theta_inc, theta_n, theta)
      end select      
    end do


  end subroutine rk_transport_step

  !> @brief Final routine for rk transport timestepping algorithm
  !> @param[in] rho The density
  !> @param[in] theta The potential temperature field
  subroutine rk_transport_final( mesh_id, rho, theta)
    use psykal_lite_mod,          only: invoke_minus_field_data, &
                                        invoke_set_field_scalar, &
                                        invoke_inner_prod
    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type

   implicit none

    integer(i_def),     intent(in) :: mesh_id
    type( field_type ), intent(in) :: rho, theta
 
    type( field_type )                 :: drho, dtheta, l2_rho, l2_theta
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: theta_fs => null()
    type(operator_type),       pointer :: mm_wt, mm_w3 => null()
    real(kind=r_def)                   :: l2

    ! Compute L errors
    rho_fs   => function_space_collection%get_fs(mesh_id, element_order, &
                                                 rho%which_function_space())
    theta_fs => function_space_collection%get_fs(mesh_id, element_order, &
                                                 theta%which_function_space())

    drho   = field_type( vector_space = rho_fs )
    dtheta = field_type( vector_space = theta_fs )
    call invoke_minus_field_data(rho,   rho0,   drho)
    call invoke_minus_field_data(theta, theta0, dtheta)
    
    ! L2 error
    mm_w3 => get_mass_matrix(3)
    if ( operators == transport_operators_fem ) then
      mm_wt => get_mass_matrix(0)
    else
      mm_wt => get_mass_matrix(5)
    end if
    l2_theta = field_type( vector_space = theta_fs )
    l2_rho   = field_type( vector_space = rho_fs )
    call invoke_set_field_scalar( 0.0_r_def, l2_theta )
    call invoke_set_field_scalar( 0.0_r_def, l2_rho )
    call invoke(matrix_vector_kernel_type(l2_theta, dtheta, mm_wt))
    call invoke(matrix_vector_kernel_type(l2_rho,   drho,   mm_w3) )

    call invoke_inner_prod(dtheta, l2_theta, l2)
    write( log_scratch_space, '(A, E15.8)' ) "L2 theta = ", sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_info )

    call invoke_inner_prod(drho, l2_rho, l2)
    write( log_scratch_space, '(A, E15.8)' ) "L2 rho   = ", sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_info )

  end subroutine rk_transport_final

end module rk_transport_mod
