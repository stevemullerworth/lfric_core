!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Unit-tests for objects contain key-value pairs (key_value_type)
!>
module key_value_mod_test

  use, intrinsic :: iso_fortran_env, only: int32, int64, real32, real64

  use key_value_mod, only: key_value_type,                                        &
                           int32_key_value_type,       int64_key_value_type,      &
                           int32_arr_key_value_type,   int64_arr_key_value_type,  &
                           real32_key_value_type,      real64_key_value_type,     &
                           real32_arr_key_value_type,  real64_arr_key_value_type, &
                           logical_key_value_type,     str_key_value_type,        &
                           logical_arr_key_value_type, str_arr_key_value_type,    &
                           abstract_key_value_type,    abstract_value_type,       &
                           create_key_value

  use pfunit

  implicit none

  private

  public :: test_integer, test_real, test_logical, test_string, test_abstract, &
            test_create_key_value

  type, extends(abstract_value_type) :: test_type
    integer, public :: int_number
  contains
  end type test_type

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_integer()

    implicit none

    type(int32_key_value_type)     :: test_unit_int32
    type(int64_key_value_type)     :: test_unit_int64
    type(int32_arr_key_value_type) :: test_unit_int32_arr
    type(int64_arr_key_value_type) :: test_unit_int64_arr

    character(*),   parameter :: key           = 'fish'
    character(*),   parameter :: big_key       = 'big_fish'
    character(*),   parameter :: shoal_key     = 'fish_shoal'
    character(*),   parameter :: big_shoal_key = 'big_shoal'
    integer(int32), parameter :: turbot = 15
    integer(int32), parameter :: plaice = 20
    integer(int64), parameter :: big_turbot = 30000
    integer(int64), parameter :: big_plaice = 50000

    integer(int32), parameter :: shoal(2)     = [turbot, plaice]
    integer(int64), parameter :: big_shoal(2) = [big_turbot, big_plaice]


    call test_unit_int32%initialise( key, turbot )
    call test_unit_int64%initialise( big_key, big_turbot )

    call test_unit_int32_arr%initialise( shoal_key, shoal )
    call test_unit_int64_arr%initialise( big_shoal_key, big_shoal )

    @assertEqual( key,        test_unit_int32%get_key() )
    @assertEqual( turbot,     test_unit_int32%value  )
    @assertEqual( big_key,    test_unit_int64%get_key() )
    @assertEqual( big_turbot, test_unit_int64%value  )

    @assertEqual( shoal_key,     test_unit_int32_arr%get_key() )
    @assertEqual( big_shoal_key, test_unit_int64_arr%get_key() )
    @assertEqual( shoal,         test_unit_int32_arr%value )
    @assertEqual( big_shoal,     test_unit_int64_arr%value )

    ! Test that you can directly alter the values
    test_unit_int32%value = plaice
    test_unit_int64%value = big_plaice

    @assertEqual( plaice,     test_unit_int32%value )
    @assertEqual( big_plaice, test_unit_int64%value )

    deallocate( test_unit_int32_arr%value )
    deallocate( test_unit_int64_arr%value )
    allocate( test_unit_int32_arr%value, source=[plaice] )
    allocate( test_unit_int64_arr%value, source=[big_plaice] )

    @assertEqual( [plaice],     test_unit_int32_arr%value  )
    @assertEqual( [big_plaice], test_unit_int64_arr%value  )

  end subroutine test_integer

  @test
  subroutine test_real()

    implicit none

    type(real32_key_value_type)     :: test_unit_real32
    type(real64_key_value_type)     :: test_unit_real64
    type(real32_arr_key_value_type) :: test_unit_real32_arr
    type(real64_arr_key_value_type) :: test_unit_real64_arr

    character(*), parameter :: key           = 'fish'
    character(*), parameter :: big_key       = 'big_fish'
    character(*), parameter :: shoal_key     = 'fish_shoal'
    character(*), parameter :: big_shoal_key = 'big_shoal'

    real(real32), parameter :: turbot = 15.0_real32
    real(real32), parameter :: plaice = 20.0_real32
    real(real64), parameter :: big_turbot = 30000.0_real64
    real(real64), parameter :: big_plaice = 50000.0_real64

    real(real32), parameter :: shoal(2)     = [turbot, plaice]
    real(real64), parameter :: big_shoal(2) = [big_turbot, big_plaice]

    call test_unit_real32%initialise( key, turbot )
    call test_unit_real64%initialise( big_key, big_turbot )
    call test_unit_real32_arr%initialise( shoal_key, shoal )
    call test_unit_real64_arr%initialise( big_shoal_key, big_shoal )

    @assertEqual( key,        test_unit_real32%get_key() )
    @assertEqual( turbot,     test_unit_real32%value  )
    @assertEqual( big_key,    test_unit_real64%get_key() )
    @assertEqual( big_turbot, test_unit_real64%value  )

    @assertEqual( shoal_key,     test_unit_real32_arr%get_key() )
    @assertEqual( big_shoal_key, test_unit_real64_arr%get_key() )
    @assertEqual( shoal,         test_unit_real32_arr%value )
    @assertEqual( big_shoal,     test_unit_real64_arr%value )

    ! Test that you can directly alter the values
    test_unit_real32%value = plaice
    test_unit_real64%value = big_plaice

    @assertEqual( plaice,     test_unit_real32%value  )
    @assertEqual( big_plaice, test_unit_real64%value  )

    deallocate( test_unit_real32_arr%value )
    deallocate( test_unit_real64_arr%value )
    allocate( test_unit_real32_arr%value, source=[plaice] )
    allocate( test_unit_real64_arr%value, source=[big_plaice] )

    @assertEqual( [plaice],     test_unit_real32_arr%value  )
    @assertEqual( [big_plaice], test_unit_real64_arr%value  )

  end subroutine test_real

  @test
  subroutine test_logical()

    implicit none

    type(logical_key_value_type)     :: test_unit_logical
    type(logical_arr_key_value_type) :: test_unit_logical_arr

    character(*), parameter :: key = 'height'
    logical, parameter :: tall  = .true.
    logical, parameter :: short = .false.
    logical, parameter :: crowd(2) = [short, tall]

    call test_unit_logical%initialise( key, tall )
    call test_unit_logical_arr%initialise( key, crowd )

    @assertEqual( key,  test_unit_logical%get_key() )
    @assertEqual( key,  test_unit_logical_arr%get_key() )

    @assertTrue( tall  .eqv. test_unit_logical%value )
    @assertTrue( crowd .eqv. test_unit_logical_arr%value )

    ! Test that you can directly alter the values
    test_unit_logical%value = short
    deallocate(test_unit_logical_arr%value)
    allocate(test_unit_logical_arr%value, source=[short])

    @assertEqual( key, test_unit_logical%get_key() )
    @assertTrue( short  .eqv. test_unit_logical%value )
    @assertTrue([short] .eqv. test_unit_logical_arr%value )

  end subroutine test_logical


  @test
  subroutine test_string()

    implicit none

    type(str_key_value_type)     :: test_unit_str
    type(str_arr_key_value_type) :: test_unit_str_arr

    character(*), parameter :: key = 'muppets'
    character(*), parameter :: one = 'piggy'
    character(*), parameter :: two = 'gonzo'
    character(*), parameter :: crowd(2) = [one, two]

    call test_unit_str%initialise( key, one )
    call test_unit_str_arr%initialise( key, crowd )

    @assertEqual( key, test_unit_str%get_key() )
    @assertEqual( key, test_unit_str_arr%get_key() )

    @assertEqual( one,      test_unit_str%value )
    @assertEqual( crowd(1), test_unit_str_arr%value(1) )
    @assertEqual( crowd(2), test_unit_str_arr%value(2) )

    ! Test that you can directly alter the values
    test_unit_str%value = two
    deallocate(test_unit_str_arr%value)
    allocate(test_unit_str_arr%value(1))
    test_unit_str_arr%value(1) = two

    @assertEqual( two, test_unit_str%value )
    @assertEqual( two, test_unit_str_arr%value(1) )

  end subroutine test_string

  @test
  subroutine test_abstract()

    implicit none

    type(test_type) :: test_object
    character(*), parameter :: key = 'test_obj'

    type(abstract_key_value_type) :: test_unit_abstract

    ! Initialise an object that inherits from the abstract key_value_type
    test_object%int_number = 17

    ! Create a key value pair that holds "test_object" as an abstract object
    call test_unit_abstract%initialise( key, test_object )

    ! Test that we can extract the correct key from the key-value pair
    @assertEqual( key, test_unit_abstract%get_key() )

    ! Test that we can extract the correct abstract object by making it
    ! concrete with a "select type" and testing the value we put in the object
    select type (value => test_unit_abstract%value)
    type is (test_type)
      @assertEqual( 17, value%int_number )
    end select

  end subroutine test_abstract

  @test
  subroutine test_create_key_value()

    implicit none

    class(key_value_type), pointer :: instance

    instance => create_key_value( "int32_val", 41_int32 )
    select type (instance)
    type is (int32_key_value_type)
      @assertEqual( 41_int32, instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "int32_arr_val", [41_int32, 79_int32] )
    select type (instance)
    type is (int32_arr_key_value_type)
      @assertEqual( [41_int32, 79_int32], instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "int64_val", 43_int64 )
    select type (instance)
    type is (int64_key_value_type)
      @assertEqual( 43_int64, instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "int64_arr_val", [47_int64, 73_int64] )
    select type (instance)
    type is (int64_arr_key_value_type)
      @assertEqual( [47_int64, 73_int64], instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "real32_val", 29.0_real32 )
    select type (instance)
    type is (real32_key_value_type)
      @assertEqual( 29.0_real32, instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "real32_arr_val", [29.0_real32, 87.0_real32] )
    select type (instance)
    type is (real32_arr_key_value_type)
      @assertEqual( [29.0_real32, 87.0_real32], instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "real64_val", 17.0_real64 )
    select type (instance)
    type is (real64_key_value_type)
      @assertEqual( 17.0_real64, instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "real64_arr_val", [17.0_real64, 93.0_real64] )
    select type (instance)
    type is (real64_arr_key_value_type)
      @assertEqual( [17.0_real64, 93.0_real64], instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "logical_val", .true. )
    select type (instance)
    type is (logical_key_value_type)
      @assertTrue( instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "logical_arr_val", [.true., .false.] )
    select type (instance)
    type is (logical_arr_key_value_type)
      ! (No assert for arrays of logicals - do them individually)
      @assertTrue ( instance%value(1) )
      @assertFalse( instance%value(2) )
    end select
    deallocate(instance)

    instance => create_key_value( "str_val", "Bob" )
    select type (instance)
    type is (str_key_value_type)
      @assertEqual( "Bob", instance%value )
    end select
    deallocate(instance)

    instance => create_key_value( "str_arr_val", &
                                  [character(9) :: "Cardboard", "Box"] )
    select type (instance)
    type is (str_arr_key_value_type)
      ! (No assert for arrays of strings - do them individually)
      @assertEqual( "Cardboard", instance%value(1) )
      @assertEqual( "Box", instance%value(2) )
    end select
    deallocate(instance)

  end subroutine test_create_key_value

end module key_value_mod_test

