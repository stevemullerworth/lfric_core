!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Wrapper algorithm to compute the lhs of the prognostic
!>       equations for the linear gravity wave equations
module gw_lhs_alg_mod

  use constants_mod,                     only: r_def, i_def
  use function_space_collection_mod,     only: function_space_collection
  use runtime_constants_mod,             only: get_div, &
                                               get_mass_matrix, &
                                               w0_id, w2_id, w3_id, w3inv_id, &
                                               wt_id
  use field_mod,                         only: field_type
  use operator_mod,                      only: operator_type
  use field_indices_mod,                 only: igw_u, igw_b, igw_p
  implicit none

  type(field_type),    private :: lhs_p
  type(operator_type), private :: Q

  private
  public  :: gw_lhs_alg
  public  :: gw_lhs_init
contains

!>@brief Initialise fields to be used for computing the lhs
  subroutine gw_lhs_init(state)
    use finite_element_config_mod,     only: element_order
    use function_space_mod,            only: function_space_type
    use mesh_mod,                      only: mesh_type
    use derived_config_mod,            only: bundle_size
    use quadrature_xyoz_mod,           only: quadrature_xyoz_type
    use quadrature_rule_gaussian_mod,  only: quadrature_rule_gaussian_type
    use compute_q_operator_kernel_mod, only: compute_q_operator_type
    implicit none

    type(field_type), intent(in)          :: state(bundle_size)
    type(function_space_type), pointer    :: u_fs => null(), &
                                             b_fs => null(), &
                                             p_fs => null()
    integer(i_def)                        :: mesh_id
    type( quadrature_xyoz_type )          :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule

    mesh_id = state(igw_u)%get_mesh_id()
    u_fs => function_space_collection%get_fs ( mesh_id, element_order,   &
                                               state(igw_u)%which_function_space() )

    p_fs => function_space_collection%get_fs ( mesh_id, element_order,   &
                                               state(igw_p)%which_function_space() )
    lhs_p =  field_type( vector_space = p_fs )

    b_fs => function_space_collection%get_fs ( mesh_id, element_order,   &
                                               state(igw_b)%which_function_space() )

    Q = operator_type( u_fs, b_fs)
    qr = quadrature_xyoz_type(element_order+2, quadrature_rule)
    call invoke( compute_q_operator_type(Q, qr) )

    nullify( u_fs, b_fs, p_fs )

  end subroutine gw_lhs_init
  !============================================================================!
!>@details A wrapper for computing the lhs of the prognostic
!>         equations by choosing certain terms to approximate the
!>         Jacobian, namely:
!>         \f[
!>         \mathbf{L_u} = \mathbf{u}' - \alpha\Delta t\nabla p' - b\mathbf{z}
!>         \f]
!>         \f[ L_p = p' + \alpha\Delta t c^2\nabla.\mathbf{u}'\f]
!>         \f[ L_b = b' + \alpha\Delta t N^2\mathbf{u}'.\mathbf{z}\f]
!>
!>         Where primed terms are increments to the n timelevel field
!> @param[inout] lhs The state vector to compute
!> @param[inout] state The current model prognostic state
  subroutine gw_lhs_alg(lhs, state)

  use matrix_vector_kernel_mod,           only: matrix_vector_kernel_type
  use operator_mod,                       only: operator_type
  use derived_config_mod,                 only: bundle_size
  use transpose_matrix_vector_kernel_mod, only: transpose_matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,        only: dg_matrix_vector_kernel_type
  use initial_temperature_config_mod,     only: bvf_square
  use gravity_wave_constants_config_mod,  only: cs_square, b_space,                &
                                                gravity_wave_constants_b_space_w0, &
                                                gravity_wave_constants_b_space_w3, &
                                                gravity_wave_constants_b_space_wtheta
  use timestepping_config_mod,            only: dt, alpha
  use enforce_bc_kernel_mod,              only: enforce_bc_kernel_type

  implicit none

  ! Form of state and lhs is [u,theta,rho,exner]
  type(field_type), target,        intent(inout) :: state(bundle_size)
  type(field_type),                intent(inout) :: lhs(bundle_size)

  type(operator_type), pointer :: mm_w2  => null()
  type(operator_type), pointer :: mm_wt  => null()
  type(operator_type), pointer :: m3_inv => null()
  type(operator_type), pointer :: div    => null()

  type(field_type),    pointer :: u => null(),  &
                                  p => null(),  &
                                  b => null()

  ! Auxiliary constants to group invokes
  real(kind=r_def)             :: const1, const2, const3

  select case(b_space)
    case(gravity_wave_constants_b_space_w0)
      mm_wt => get_mass_matrix(w0_id)
    case(gravity_wave_constants_b_space_w3)
      mm_wt => get_mass_matrix(w3_id)
    case(gravity_wave_constants_b_space_wtheta)
      mm_wt => get_mass_matrix(wt_id)
  end select


  mm_w2 => get_mass_matrix(w2_id)
  div   => get_div()
  m3_inv => get_mass_matrix(w3inv_id)

  u => state(igw_u)
  p => state(igw_p)
  b => state(igw_b)

  ! Set auxiliary constants
  const1 = -alpha*dt
  const2 = alpha*dt*bvf_square
  const3 = alpha*dt*cs_square

  ! Compute gravity wave lhs
  call invoke( name = "Compute gravity wave lhs",                              &
  ! Initialise lhs
               setval_c(lhs(igw_u), 0.0_r_def),                                &
               setval_c(lhs(igw_b), 0.0_r_def),                                &
  ! Compute lhs
               transpose_matrix_vector_kernel_type(lhs(igw_u), p,     div),    &
               matrix_vector_kernel_type          (lhs(igw_u), b,     Q),      &
               dg_matrix_vector_kernel_type       (lhs_p,      u,     div),    &
               dg_matrix_vector_kernel_type       (lhs(igw_p), lhs_p, m3_inv), &
               transpose_matrix_vector_kernel_type(lhs(igw_b), u,     Q),      &
  ! Scale lhs
               inc_a_times_X(const1, lhs(igw_u)),                              &
               inc_a_times_X(const2, lhs(igw_b)),                              &
  ! Add time dependencies
               matrix_vector_kernel_type(lhs(igw_u), u, mm_w2),                &
               enforce_bc_kernel_type(lhs(igw_u)),                             &
               matrix_vector_kernel_type(lhs(igw_b), b, mm_wt),                &
               inc_aX_plus_Y(const3, lhs(igw_p), p) )

  nullify( mm_w2, mm_wt, m3_inv, div, u, p, b )

  end subroutine gw_lhs_alg
  !============================================================================!

end module gw_lhs_alg_mod


