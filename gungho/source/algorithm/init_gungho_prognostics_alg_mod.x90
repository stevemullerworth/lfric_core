!-----------------------------------------------------------------------------
! (C) Crown copyright 2019 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Initialisation of prognostic fields
module init_gungho_prognostics_alg_mod

  use log_mod,                         only: log_event,         &
                                             log_scratch_space, &
                                             LOG_LEVEL_ERROR,   &
                                             LOG_LEVEL_INFO,    &
                                             LOG_LEVEL_ERROR,   &
                                             LOG_LEVEL_TRACE
  use constants_mod,                   only: r_def, i_def,      &
                                             str_short
  use mass_matrix_solver_alg_mod,      only: mass_matrix_solver_alg
  use dg_matrix_vector_kernel_mod,     only: dg_matrix_vector_kernel_type
  use geometric_constants_mod,         only: get_coordinates, &
                                             get_panel_id,    &
                                             get_height
  use fem_constants_mod,               only: get_inverse_w3_mass_matrix

  use finite_element_config_mod,       only: element_order, &
                                             nqp_exact
  use base_mesh_config_mod,            only: geometry,           &
                                             geometry_spherical, &
                                             geometry_planar
  use formulation_config_mod,          only: use_moisture,         &
                                             transport_only,       &
                                             eos_method,           &
                                             eos_method_sampled,   &
                                             eos_method_projected
  use initial_pressure_config_mod,     only: method,           &
                                             method_sampled,   &
                                             method_projected, &
                                             method_balanced
  use initial_wind_config_mod,         only: smp_init_wind,                   &
                                             profile,                         &
                                             profile_sbr_streamfunction,      &
                                             profile_dcmip301_streamfunction, &
                                             profile_div_free_reversible,     &
                                             profile_eternal_fountain,        &
                                             profile_rotational
  use io_mod,                          only: ts_fname

  ! PsyKAl-lite kernels
  use field_bundle_mod,                only: set_bundle_scalar

  ! PsyKAl PSYClone kernels
  use set_exner_kernel_mod,            only: set_exner_kernel_type
  use set_rho_kernel_mod,              only: set_rho_kernel_type
  use initial_u_kernel_mod,            only: initial_u_kernel_type
  use enforce_bc_kernel_mod,           only: enforce_bc_kernel_type
  use initial_theta_kernel_mod,        only: initial_theta_kernel_type
  use initial_exner_sample_kernel_mod, only: initial_exner_sample_kernel_type
  use initial_rho_sample_kernel_mod,   only: initial_rho_sample_kernel_type
  use project_eos_rho_kernel_mod,      only: project_eos_rho_kernel_type
  use sample_eos_rho_kernel_mod,       only: sample_eos_rho_kernel_type
  use hydrostatic_exner_kernel_mod,    only: hydrostatic_exner_kernel_type
  use moist_dyn_factors_kernel_mod,    only: moist_dyn_factors_kernel_type
  use initial_mr_kernel_mod,           only: initial_mr_kernel_type
  use initial_streamfunc_kernel_mod,   only: initial_streamfunc_kernel_type
  use strong_curl_kernel_mod,          only: strong_curl_kernel_type

  ! Derived Types
  use field_mod,                       only: field_type
  use field_collection_mod,            only: field_collection_type
  use quadrature_xyoz_mod,             only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,    only: quadrature_rule_gaussian_type
  use sample_initial_u_kernel_mod,     only: sample_initial_u_kernel_type
  use operator_mod,                    only: operator_type
  use function_space_collection_mod,   only: function_space_collection

  ! Handles
  use fs_continuity_mod,               only: W1, W3, Wtheta
  use mr_indices_mod,                  only: nummr, mr_names
  use moist_dyn_mod,                   only: num_moist_factors, gas_law
  implicit none

  private
  public :: init_gungho_prognostics_alg

contains

  !> @details An algorithm for initialising prognostic fields for
  !>          all solvers.
  !> @param[in,out] prognostic_fields the collection of prognostics
  !> @param[in,out] mr Field bundle containing the moisture mixring ratios
  !> @param[in,out] moist_dyn Auxilliary fields for moist dynamics
  subroutine init_gungho_prognostics_alg(prognostic_fields, mr, moist_dyn)

    implicit none

    ! Prognostic fields
    type( field_collection_type ), intent(inout) :: prognostic_fields
    type( field_type ),            intent(inout) :: mr(nummr), &
                                                    moist_dyn(num_moist_factors)

    type( quadrature_xyoz_type )          :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule
    type( field_type )                    :: r_u, r_psi, psi, r_rho
    ! Coordinate fields
    type( field_type ), pointer           :: chi_sph(:) => null()
    type( field_type ), pointer           :: panel_id => null()
    type( field_type ), pointer           :: height_wth => null()
    type( field_type ), pointer           :: height_w3 => null()

    ! Pointers to fields
    type( field_type ), pointer   :: u => null()
    type( field_type ), pointer   :: rho => null()
    type( field_type ), pointer   :: theta => null()
    type( field_type ), pointer   :: exner => null()

    ! Operators
    type(operator_type), pointer  :: m3_inv => null()

    integer(kind=i_def)  :: i, mesh_id
    real(kind=r_def)     :: initial_time

    theta => prognostic_fields%get_field('theta')
    u => prognostic_fields%get_field('u')
    rho => prognostic_fields%get_field('rho')
    exner => prognostic_fields%get_field('exner')

    mesh_id = u%get_mesh_id()

    call r_rho%initialise( vector_space =  rho%get_function_space() )

    qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)
    chi_sph => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)
    m3_inv => get_inverse_w3_mass_matrix(mesh_id)

    ! Default is dry dynamics - set moist dynamics factors to one
    do i = 1, num_moist_factors
      call invoke( setval_c( moist_dyn(i), 1.0_r_def) )
    end do

    !=== Initialise global prognostic fields ==================================!

    call log_event( "Gungho: Initialising prognostic fields", LOG_LEVEL_INFO )

    ! Initialise theta
    call invoke( initial_theta_kernel_type( theta, chi_sph, panel_id ) )

    initial_time = 0.0_r_def

    ! Initialise U according to formulation
    if (smp_init_wind) then
      if ( geometry /= geometry_planar ) then
        call log_event('Sampling initial wind only implemented for planar geometry', &
                       LOG_LEVEL_ERROR)
      end if
      call invoke( name = "get_u_from_sampling", &
                   setval_c( u, 0.0_r_def ),     &
                   sample_initial_u_kernel_type( u, chi_sph ) )
    else
      if ( profile == profile_sbr_streamfunction .or.  &
           profile == profile_dcmip301_streamfunction .or. &
           profile == profile_eternal_fountain .or. &
           profile == profile_div_free_reversible .or. &
           profile == profile_rotational ) then
        call log_event( "Gungho: Initialising winds from stream function", LOG_LEVEL_INFO )
        call psi%initialise( vector_space =                                           &
                    function_space_collection%get_fs(mesh_id, element_order, W1) )
        call r_psi%initialise( vector_space =                                         &
                    function_space_collection%get_fs(mesh_id, element_order, W1) )
        call invoke( name = "initialise_streamfunction", &
                     setval_c(psi, 0.0_r_def),           &
                     setval_c(r_psi, 0.0_r_def),         &
                     initial_streamfunc_kernel_type(r_psi, chi_sph, panel_id, &
                                                    initial_time, qr) )
        ! We do not want to force zero stream function at boundaries
        call mass_matrix_solver_alg(psi, r_psi, bc_flag=.false.)
        call invoke( name = "get_u_from_curl_of_psi", &
                     strong_curl_kernel_type(u, psi) )
        ! Prevent any flux out from the domain
        ! However for spherical domains this could prevent the resulting
        ! wind from being divergence-free, so only do this for Cartesian domains
        if (geometry /= geometry_spherical) then
          call invoke( name = "apply_bcs_to_u", &
                       enforce_bc_kernel_type( u ) )
        end if

      else
        call log_event("Initialise u with projection", LOG_LEVEL_INFO)
        call r_u%initialise( vector_space =  u%get_function_space() )
        call invoke( name = "get_u_from_projection",  &
                     setval_c( u,   0.0_r_def ),      &
                     setval_c( r_u, 0.0_r_def ),      &
                     initial_u_kernel_type( r_u, chi_sph, panel_id, initial_time, qr ), &
                     enforce_bc_kernel_type( r_u ) )
        call mass_matrix_solver_alg(u, r_u)
      end if
    end if

    ! Initialise Exner pressure according to formulation
    select case(method)
      case(method_balanced)
        height_w3 => get_height(W3, mesh_id)
        height_wth => get_height(Wtheta, mesh_id)

        ! Initialise exner assuming hydrostatic balance
        call invoke( hydrostatic_exner_kernel_type( exner, theta, moist_dyn, height_wth, &
                                                    height_w3, chi_sph, panel_id ) )
      case(method_sampled)
        ! Initialise exner through sampling analytic solution
        call invoke (initial_exner_sample_kernel_type( exner, chi_sph, panel_id, initial_time ) )
      case(method_projected)
        ! Initialise exner by projecting analytic solution
        call invoke( set_exner_kernel_type ( exner, chi_sph, panel_id, initial_time, qr ) )
      case default
        call log_event( "Gungho: Unrecognised method in initial_pressure", LOG_LEVEL_ERROR )
    end select

    if (transport_only) then
      ! Initialise rho analytically if transport-only. Either sampled or projected
      select case(method)
        case(method_sampled, &
             method_balanced)
          call invoke( initial_rho_sample_kernel_type( rho, chi_sph, panel_id, initial_time ) )
        case(method_projected)
          qr = quadrature_xyoz_type( nqp_exact, quadrature_rule )
          call invoke( set_rho_kernel_type( rho, chi_sph, panel_id, initial_time, qr ) )
        case default
          call log_event( "Gungho: Unrecognised method in initial_pressure", LOG_LEVEL_ERROR )
      end select
    else
      ! Initialise rho using equation of state, either sampled or projected
      select case(eos_method)
        case(eos_method_sampled)
          ! Diagnose density from equation of state by sampling
          call invoke( sample_eos_rho_kernel_type( rho, exner, theta,      &
                                                   moist_dyn(gas_law) ) )
        case(eos_method_projected)
          qr = quadrature_xyoz_type( nqp_exact, quadrature_rule )
          ! Diagnose density from equation of state by projection
          call invoke(   setval_c( r_rho, 0.0_r_def ),                           &
                         project_eos_rho_kernel_type( r_rho, exner, theta,       &
                                                    moist_dyn(gas_law), chi_sph, &
                                                    panel_id, qr ),              &
                         dg_matrix_vector_kernel_type(rho, r_rho, m3_inv) )
        case default
          call log_event( "Gungho: Unrecognised method used for equation of state", LOG_LEVEL_ERROR )
      end select
    end if

    if (use_moisture) then
      if (transport_only) then
        ! Set up moisture variables to be the same as theta
        do i = 1, nummr
          call invoke( setval_X(mr(i), theta) )
        end do
        call invoke( moist_dyn_factors_kernel_type( moist_dyn, mr ) )
      else
        ! Initialise moisture and update factors for moist dynamics
        call invoke( initial_mr_kernel_type( theta, exner, rho, mr ), &
                     moist_dyn_factors_kernel_type( moist_dyn, mr )   )
        ! Recalculate hydrostatic pressure and dry density
        height_w3 => get_height(W3, mesh_id)
        height_wth => get_height(Wtheta, mesh_id)
        call invoke( hydrostatic_exner_kernel_type( exner, theta, moist_dyn, &
                                                    height_wth, height_w3,   &
                                                    chi_sph, panel_id ) )
        select case(eos_method)
          case(eos_method_sampled)
            call invoke( sample_eos_rho_kernel_type( rho, exner, theta,      &
                                                     moist_dyn(gas_law) ) )
          case(eos_method_projected)
            qr = quadrature_xyoz_type( nqp_exact, quadrature_rule )
            call invoke(   setval_c( r_rho, 0.0_r_def ),                           &
                           project_eos_rho_kernel_type( r_rho, exner, theta,       &
                                                      moist_dyn(gas_law), chi_sph, &
                                                      panel_id, qr ),              &
                           dg_matrix_vector_kernel_type(rho, r_rho, m3_inv) )
          case default
            call log_event( "Gungho: Unrecognised method used for equation of state", LOG_LEVEL_ERROR )
        end select
      end if
    else
      call set_bundle_scalar(0.0_r_def, mr, nummr)
    end if

    call log_event( "Gungho: Initialised prognostic fields", LOG_LEVEL_INFO )

    !==========================================================================!
    nullify( m3_inv, chi_sph, panel_id, height_wth, height_w3 )
    nullify( theta, rho, u, exner)

  end subroutine init_gungho_prognostics_alg

end module init_gungho_prognostics_alg_mod
