!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
module w3_solver_kernel_mod_test

  use constants_mod,  only : i_def, r_def
  use pFUnit_Mod
  use quadrature_mod, only : quadrature_type, GAUSSIAN

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: w3_solver_test_type
    private
    real(kind=r_def), allocatable :: basis(:,:,:,:)
    real(kind=r_def), allocatable :: diff_basis(:,:,:,:)
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type w3_solver_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(w3_solver_test_type), intent(inout) :: this

    type(quadrature_type) :: qr

    integer(i_def) :: nqp_h, nqp_v

    qr = quadrature_type(3, GAUSSIAN)

    nqp_h = qr%get_nqp_h()
    nqp_v = qr%get_nqp_v()

    allocate( this%basis(1,8,nqp_h,nqp_v), &
              this%diff_basis(3,8,nqp_h,nqp_v) )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(w3_solver_test_type), intent(inout) :: this

    deallocate( this%basis, this%diff_basis )

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_all( this )

    use w3_solver_kernel_mod,    only : solver_w3_code

    implicit none

    class(w3_solver_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-14_r_def

    integer :: num_layers, ndf, map(1),undf
    type(quadrature_type) :: qr
    real(kind=r_def) :: xdata(1)
    real(kind=r_def) :: rhsdata(1)
    real(kind=r_def) :: answer

    integer :: ndf_w0, map_w0(8), undf_w0
    real(kind=r_def) :: chi(8,3)
    real(kind=r_def) :: x_vert(8,3)
    real(kind=r_def), pointer :: xqp_h(:,:), xqp_v(:) => null()
    real(kind=r_def), pointer :: wh(:), wv(:) => null()
    integer(i_def) :: nqp_h, nqp_v
    real(kind=r_def) :: fx, fy, fz
    integer :: df, dim, qp1, qp2

    qr = quadrature_type(3, GAUSSIAN)

    xqp_h => qr%get_xqp_h()
    xqp_v => qr%get_xqp_v()
    wh    => qr%get_wqp_h()
    wv    => qr%get_wqp_v()
    nqp_h = qr%get_nqp_h()
    nqp_v = qr%get_nqp_v()

    x_vert(1,:) = (/ 0.0_r_def, 0.0_r_def, 0.0_r_def /)
    x_vert(2,:) = (/ 1.0_r_def, 0.0_r_def, 0.0_r_def /)
    x_vert(3,:) = (/ 1.0_r_def, 1.0_r_def, 0.0_r_def /)
    x_vert(4,:) = (/ 0.0_r_def, 1.0_r_def, 0.0_r_def /)
    x_vert(5,:) = (/ 0.0_r_def, 0.0_r_def, 1.0_r_def /)
    x_vert(6,:) = (/ 1.0_r_def, 0.0_r_def, 1.0_r_def /)
    x_vert(7,:) = (/ 1.0_r_def, 1.0_r_def, 1.0_r_def /)
    x_vert(8,:) = (/ 0.0_r_def, 1.0_r_def, 1.0_r_def /)

    ndf_w0 = 8
    do df = 1,ndf_w0
      map_w0(df) = df
      do qp2 = 1,nqp_v
        do qp1 = 1,nqp_h
          fx = (1.0_r_def - x_vert(df,1)) + (-1.0_r_def)**(int(x_vert(df,1))+1)*xqp_h(qp1,1)
          fy = (1.0_r_def - x_vert(df,2)) + (-1.0_r_def)**(int(x_vert(df,2))+1)*xqp_h(qp1,2)
          fz = (1.0_r_def - x_vert(df,3)) + (-1.0_r_def)**(int(x_vert(df,3))+1)*xqp_v(qp2)
          this%diff_basis(1,df,qp1,qp2) = fy*fz
          this%diff_basis(2,df,qp1,qp2) = fx*fz
          this%diff_basis(3,df,qp1,qp2) = fx*fy
        end do
      end do
      do dim = 1,3
        if ( x_vert(df,dim) < 1.0_r_def ) &
          this%diff_basis(dim,df,:,:) = -this%diff_basis(dim,df,:,:)
      end do
    end do
    chi(:,:) = x_vert(:,:)

    this%basis=1.0_r_def
    map(1)=1
    num_layers=1
    ndf=1
    undf=1
    rhsdata(1)=1.0_r_def
    undf_w0=8
    call solver_w3_code(num_layers,   &
                        xdata,rhsdata, &
                        chi(:,1),chi(:,2),chi(:,3), &
                        ndf,undf,map,this%basis, &
                        ndf_w0,undf_w0,map_w0,this%diff_basis, &
                        nqp_h, nqp_v, wh, wv )
! Answer for hardwired jacobian
!    answer = 1.0_r_def / ( 6000.0_r_def * 1000.0_r_def * 2000.0_r_def )
    answer = 1.0_r_def / ( 1.0_r_def * 1.0_r_def * 1.0_r_def )

    @assertEqual( answer, xdata(1), tol )

  end subroutine test_all

end module w3_solver_kernel_mod_test
