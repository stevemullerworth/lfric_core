!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> An algorithm for computing the galerkin projection 
!> As a first step fields are projected into a continuous space

module galerkin_projection_algorithm_mod

  use constants_mod,                   only: r_def, i_def
  use function_space_collection_mod,   only: function_space_collection
  use field_mod,                       only: field_type
  use finite_element_config_mod,       only: element_order
  use fs_continuity_mod,               only: W2, W3
  use gp_rhs_kernel_mod,               only: gp_rhs_kernel_type
  use gp_vector_rhs_kernel_mod,        only: gp_vector_rhs_kernel_type
  use log_mod,                         only: log_event, log_scratch_space, LOG_LEVEL_INFO
  use operator_mod,                    only: operator_type
  use psykal_lite_mod,                 only: invoke_copy_field_data, invoke_set_field_scalar
  use quadrature_mod,                  only: quadrature_type
  use solver_mod,                      only: solver_algorithm
  use runtime_constants_mod,           only: get_coordinates

  implicit none

  private 
  public :: galerkin_projection_algorithm

contains
!> @brief An algorithm to compute the galerkin projection of a field
!> @details Computes the Galerkin projection of a field f_in into the space
!>          of field f_out. Solves M*f_out = rhs where rhs = int(gamma*f_in)
!>          and gamma is a test function from the same space as f_out and M is 
!>          the mass matrix for the space of f_out.
!>          If f_in is in a vector space then it is decomposed into
!>          orthogonal components and the galerkin projection of each
!>          component is computed.
!> @param[out] f_out A field to project to
!> @param[in]  f_in  Field to project
!> @param[in]  mesh id of the mesh object the model for fields
!> @param[in]  space_dimension Dimension of the space f_in (scalar or vector)
!> @param[in]  qr Quadrature rule to perform integrations
  subroutine galerkin_projection_algorithm( f_out,          &
                                            f_in,           &
                                            mesh,           &
                                            space_dimension, &
                                            qr)
    
    implicit none

! Dimension of space to project
    integer,            intent(in)    :: space_dimension
! Field to output
    type( field_type ), intent(inout) :: f_out(space_dimension)
! Field to intput
    type( field_type ), intent(inout) :: f_in  
    integer( i_def ),   intent(in)    :: mesh
    type( quadrature_type ), intent(in) :: qr
! Coordinate fields
    type( field_type ), pointer :: chi(:) => null()

    integer                          :: out_fs
    type( field_type )               :: rhs(space_dimension)
    type( field_type )               :: w2_field
    integer                          :: dir

    chi => get_coordinates()  


! Create continuous fields to project data into
    out_fs = f_out(1)%which_function_space()
    do dir = 1,space_dimension
      rhs(dir) = field_type( vector_space = f_out(1)%get_function_space() )
      call invoke( set_field_scalar(0.0_r_def, rhs(dir)) )
    end do
    
! Project field into continuous space
    write( log_scratch_space, '(A)' ) 'Computing Galerkin projection...'
    call log_event( log_scratch_space, LOG_LEVEL_INFO )  
    if ( f_in%which_function_space() == out_fs ) then
       write( log_scratch_space, '(A)' ) '   function spaces match, no projection needed'
       call log_event( log_scratch_space, LOG_LEVEL_INFO )
       call invoke( copy_field(f_in, f_out(1)) )
    else
       if ( space_dimension == 1 ) then
          write( log_scratch_space, '(A)' ) '    scalar field ... '
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          call invoke( gp_rhs_kernel_type(rhs(1), f_in, chi, qr) )
       else
          write( log_scratch_space, '(A)' ) '    vector field ... '
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          ! Create dummy W2 field for kernel to perform check again
          w2_field = field_type( vector_space =  &
                              function_space_collection%get_fs(mesh, element_order, W2) ) 

          call invoke( gp_vector_rhs_kernel_type(rhs, f_in, chi, w2_field, qr) )
       end if
       do dir = 1,space_dimension
         call solver_algorithm( f_out(dir), rhs(dir) )
       end do
    end if

  end subroutine galerkin_projection_algorithm
  
end module galerkin_projection_algorithm_mod
