!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!
!> @brief A module providing various run time constants
!>
!> @details A module holding various objects that are created at
!>         setup and are not changed thereafter but are needed
!>         throughout the algorithm layers

module runtime_constants_mod

  use constants_mod,                     only: i_def, r_def  
  use log_mod,                           only: log_event, &
                                               LOG_LEVEL_INFO, &
                                               LOG_LEVEL_ERROR
  ! Configuration
  use finite_element_config_mod,         only: element_order, wtheta_on, coordinate_order
  use formulation_config_mod,            only: transport_only
  use transport_config_mod,              only: scheme,                     &
                                               transport_scheme_cusph_cosmic

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use fs_continuity_mod,                 only: W0, W1, W2, W3, Wtheta, Wchi
  use mesh_mod,                          only: mesh_type
  use operator_mod,                      only: operator_type
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN

  use assign_coordinate_field_mod,       only: assign_coordinate_field

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                   only: invoke_compute_geopotential_kernel_type, &
                                               invoke_raise_field,                      &
                                               invoke_mpi_calc_cell_orientation

  ! PsyKAl PSYClone kernels
  use compute_mass_matrix_kernel_w0_mod,     only: compute_mass_matrix_kernel_w0_type
  use compute_mass_matrix_kernel_w1_mod,     only: compute_mass_matrix_kernel_w1_type
  use compute_mass_matrix_kernel_w2_mod,     only: compute_mass_matrix_kernel_w2_type
  use compute_mass_matrix_kernel_w3_mod,     only: compute_mass_matrix_kernel_w3_type
  use compute_mass_matrix_kernel_wtheta_mod, only: compute_mass_matrix_kernel_wtheta_type
  use compute_geopotential_kernel_mod,       only: compute_geopotential_kernel_type
  use mm_diagonal_kernel_mod,                only: mm_diagonal_kernel_type
  use invert_local_operator_kernel_mod,      only: invert_local_operator_kernel_type
  use compute_grad_operator_kernel_mod,      only: compute_grad_operator_kernel_type
  use compute_curl_operator_kernel_mod,      only: compute_curl_operator_kernel_type
  use compute_div_operator_kernel_mod,       only: compute_div_operator_kernel_type
  use matrix_vector_kernel_mod,              only: matrix_vector_kernel_type
  use matrix_vector_nobc_kernel_mod,         only: matrix_vector_nobc_kernel_type

  use output_config_mod,                     only: subroutine_timers 
  use timer_mod,                             only: timer
  implicit none

  private

  ! variables private to this module that can only be accessed by public
  ! functions returning pointers to them 

  type(field_type), target        :: mm0_diag 
  type(field_type), target        :: mm1_diag
  type(field_type), target        :: mm2_diag
  type(field_type), target        :: mm3_diag
  type(field_type), target        :: eye
  type(field_type), target        :: mmtheta_diag
  type(operator_type), target     :: mm_w0
  type(operator_type), target     :: mm_w1
  type(operator_type), target     :: mm_w2
  type(operator_type), target     :: mm_w3
  type(operator_type), target     :: mm_w3_inv
  type(operator_type), target     :: mm_wtheta
  type(field_type), target        :: geopotential
  type(field_type), target        :: temp_w2_field
  type(field_type), target        :: cell_orientation
  type(operator_type), target     :: grad, curl, div
  type(quadrature_type), target   :: qr
  type(field_type), target        :: m0_lumped_inv
  type(field_type), target        :: m1_lumped_inv
  type(field_type), target        :: mt_lumped_inv
  type(field_type), target, dimension(3) :: chi

  ! Enumerated types
  integer(i_def), parameter, public :: w0_id    = 0_i_def
  integer(i_def), parameter, public :: w1_id    = 1_i_def
  integer(i_def), parameter, public :: w2_id    = 2_i_def
  integer(i_def), parameter, public :: w3_id    = 3_i_def
  integer(i_def), parameter, public :: wt_id    = 4_i_def
  integer(i_def), parameter, public :: w3inv_id = 5_i_def
  integer(i_def), parameter, public :: eye_id   = 6_i_def
  integer(i_def), parameter, public :: theta_space_id = 7_i_def


  ! Public functions to create and access the module contents

  public :: create_runtime_constants
  public :: get_coordinates
  public :: get_geopotential
  public :: get_cell_orientation
  public :: get_mass_matrix
  public :: get_mass_matrix_diagonal
  public :: get_grad
  public :: get_curl
  public :: get_div
  public :: get_qr
  public :: get_inverse_lumped_mass_matrix

contains
  !> Subroutine to create the runtime constants
  !> @param[in] mesh_id Mesh_id
  subroutine create_runtime_constants( mesh_id)
    implicit none

    integer(i_def),           intent(in)            :: mesh_id

    type(function_space_type), pointer :: w0_fs     => null()
    type(function_space_type), pointer :: w1_fs     => null()
    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()
    type(function_space_type), pointer :: wtheta_fs => null()
    type(field_type)                   :: ones
    integer(i_def)                     :: chi_space
    integer(i_def)                     :: coord

    if ( subroutine_timers ) call timer('runtime_constants_alg')
    call log_event( "Gungho: creating runtime_constants", LOG_LEVEL_INFO )


    !=========== Create function spaces required for setup ===================!

    w0_fs     => function_space_collection%get_fs( mesh_id, element_order, W0 )
    w1_fs     => function_space_collection%get_fs( mesh_id, element_order, W1 )
    w2_fs     => function_space_collection%get_fs( mesh_id, element_order, W2 )
    w3_fs     => function_space_collection%get_fs( mesh_id, element_order, W3 )
    wtheta_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )

    !================= Compute coordinates =====================!
    ! Compute coordinates
    if ( coordinate_order == 0 ) then
      chi_space = W0
      call log_event( "Gungho: Computing W0 coordinate fields", LOG_LEVEL_INFO )
    else
      chi_space = Wchi
      call log_event( "Gungho: Computing Wchi coordinate fields", LOG_LEVEL_INFO )
    end if
    do coord = 1,3
      chi(coord) = field_type (vector_space =                                    &
                   function_space_collection%get_fs(mesh_id, coordinate_order, chi_space) )
    end do
    call assign_coordinate_field(chi, mesh_id)

    !================= Create quadrature object =====================!
    qr = quadrature_type(element_order+3, GAUSSIAN)


    !=================== Create geopotential field ============================!

    geopotential = field_type( vector_space = w0_fs )
    call invoke_compute_geopotential_kernel_type( geopotential, chi )

    !=================== Create cell orientation field ========================!
    if ( transport_only .and. scheme == transport_scheme_cusph_cosmic ) then
      temp_w2_field = field_type( vector_space = w2_fs )
      cell_orientation = field_type( vector_space = w3_fs )
      call invoke( set_field_scalar(9999.0_r_def, temp_w2_field), &
                   set_field_scalar(9999.0_r_def, cell_orientation) )
      call invoke_mpi_calc_cell_orientation( temp_w2_field, cell_orientation )
    end if

    !=================== Create mass matrix operators =========================!

    mm_w0 = operator_type( w0_fs, w0_fs )
    mm_w1 = operator_type( w1_fs, w1_fs )
    mm_w2 = operator_type( w2_fs, w2_fs )
    mm_w3 = operator_type( w3_fs, w3_fs )
    mm_w3_inv = operator_type( w3_fs, w3_fs )
    mm_wtheta = operator_type( wtheta_fs, wtheta_fs )

    call invoke( compute_mass_matrix_kernel_w0_type(mm_w0, chi, qr),         &
                 compute_mass_matrix_kernel_w1_type(mm_w1, chi, qr),         &
                 compute_mass_matrix_kernel_w2_type(mm_w2, chi, qr),         &
                 compute_mass_matrix_kernel_w3_type(mm_w3, chi, qr),         &
                 compute_mass_matrix_kernel_wtheta_type(mm_wtheta, chi, qr), &
                 invert_local_operator_kernel_type(mm_w3_inv, mm_w3) )

    !=================== Create grad, div, curl operators =====================!

    grad = operator_type( w1_fs, w0_fs )
    curl = operator_type( w2_fs, w1_fs )
    div  = operator_type( w3_fs, w2_fs )

    ! These are seperate invokes as chi is defined as any space and psyclone
    ! does not support multiple any_spaces in the same invoke
    call invoke( compute_grad_operator_kernel_type(grad, chi, qr) )
    call invoke( compute_curl_operator_kernel_type(curl, chi, qr) )
    call invoke( compute_div_operator_kernel_type (div,  chi, qr) )


    !================= Create mass matrix diagonal fields =====================!

    mm0_diag       = field_type( vector_space = w0_fs )
    mm1_diag       = field_type( vector_space = w1_fs )
    mm2_diag       = field_type( vector_space = w2_fs )
    mm3_diag       = field_type( vector_space = w3_fs )
    mmtheta_diag   = field_type( vector_space = wtheta_fs )
    eye            = field_type( vector_space = w3_fs )

    ! Initialise fields
    call invoke( set_field_scalar(0.0_r_def, mm0_diag), &
                 set_field_scalar(0.0_r_def, mm1_diag), &
                 set_field_scalar(0.0_r_def, mm2_diag), &
                 set_field_scalar(0.0_r_def, mmtheta_diag) )

    call invoke( mm_diagonal_kernel_type(mm0_diag, mm_w0) )
    call invoke( mm_diagonal_kernel_type(mm1_diag, mm_w1) )
    call invoke( mm_diagonal_kernel_type(mm2_diag, mm_w2) )
    call invoke( mm_diagonal_kernel_type(mm3_diag, mm_w3) )
    call invoke( mm_diagonal_kernel_type(mmtheta_diag, mm_wtheta) )

    ! W3 equations are solved pointwise and so the mass matrix is inverted
    ! exactly, therefore the diagonal, where used should be 1
    call invoke( set_field_scalar(1.0_r_def, eye) )


    !================= Create inverse lumped mass matrices =====================!
    ones           = field_type( vector_space = w1_fs )
    m1_lumped_inv  = field_type( vector_space = w1_fs )
    call invoke( set_field_scalar(1.0_r_def, ones), &
                 set_field_scalar(0.0_r_def, m1_lumped_inv) )
    ! Use a special version of matrix vector to avoid psyclone generating the
    ! enforce_bc call, otherwise the invoke_divide_field below will divide by zero
    ! See #678
    call invoke( matrix_vector_nobc_kernel_type( m1_lumped_inv, ones, mm_w1 ) )
    call invoke_raise_field( m1_lumped_inv, -1_i_def)

    ones           = field_type( vector_space = w0_fs )
    m0_lumped_inv  = field_type( vector_space = w0_fs )
    call invoke( set_field_scalar(1.0_r_def, ones), &
                 set_field_scalar(0.0_r_def, m0_lumped_inv) )
    call invoke( matrix_vector_kernel_type(m0_lumped_inv, ones, mm_w0) )
    call invoke_raise_field( m0_lumped_inv, -1_i_def)

    ones           = field_type( vector_space = wtheta_fs )
    mt_lumped_inv  = field_type( vector_space = wtheta_fs )
    call invoke( set_field_scalar(1.0_r_def, ones), &
                 set_field_scalar(0.0_r_def, mt_lumped_inv) )
    call invoke( matrix_vector_kernel_type(mt_lumped_inv, ones, mm_wtheta) )
    call invoke_raise_field( mt_lumped_inv, -1_i_def )
 
    call log_event( "Gungho: created runtime_constants", LOG_LEVEL_INFO )
    if ( subroutine_timers ) call timer('runtime_constants_alg')

  end subroutine create_runtime_constants


  !> Function to return a pointer to the coordinate array
  !> @return The coordinate field array
  function get_coordinates() result(coords)

    type(field_type), pointer :: coords(:)
    coords => chi

  end function get_coordinates

  !> Function to return a pointer to the geopotential field
  !> @return The geopotential field
  function get_geopotential() result(phi)

    type(field_type), pointer :: phi
    phi => geopotential

  end function get_geopotential

  !> Function to return a pointer to the cell_orientation field
  !> @return The cell_orientation field
  function get_cell_orientation() result(orientation)

    type(field_type), pointer :: orientation
    if ( transport_only .and. scheme == transport_scheme_cusph_cosmic ) then
      orientation => cell_orientation
    else
      call log_event( "Cell orientation variable has not been created", LOG_LEVEL_ERROR )
    end if

  end function get_cell_orientation

  !> Function to return a pointer to a mass matrix
  !> @param[in] i the index of the desired mass matrix field
  !> @return The mass matrix operator
  function get_mass_matrix(i) result(mm)

    integer, intent(in) :: i
    type(operator_type), pointer :: mm 

    select case (i)
      case (w0_id)
        mm => mm_w0
      case (w1_id)
        mm => mm_w1
      case (w2_id)
        mm => mm_w2
      case (w3_id)
        mm => mm_w3
      case (w3inv_id)
        mm => mm_w3_inv
      case (wt_id)
        mm => mm_wtheta
      case (theta_space_id)
        if (wtheta_on)then
          mm => mm_wtheta
        else
          mm => mm_w0
        end if
      case default
        mm => null()
        call log_event( "Mass matrix operator does not exist", LOG_LEVEL_ERROR)
        stop
    end select

  end function get_mass_matrix

  !> Function to return a pointer to a mass matrix diagonal
  !> @param[in] i Index of the desired mass matrix diagonal field
  !> @return The mass matrix diagonal field
  function get_mass_matrix_diagonal(i) result(mmd)

    integer, intent(in) :: i
    type(field_type), pointer :: mmd  

    select case (i)
      case (w0_id)
        mmd => mm0_diag
      case (w1_id)
        mmd => mm1_diag
      case (w2_id)
        mmd => mm2_diag
      case (eye_id)
        mmd => eye
      case (wt_id)
        mmd => mmtheta_diag
      case (w3_id)
        mmd => mm3_diag
      case (theta_space_id)
        if (wtheta_on) then
          mmd => mmtheta_diag
        else  
          mmd => mm0_diag
        end if
      case default
        mmd => null()
        call log_event( "Mass matrix diagonal does not exist", LOG_LEVEL_ERROR)
        stop
    end select

  end function get_mass_matrix_diagonal

  !> Function to return a pointer to the grad operator
  !> @return The grad operator
  function get_grad() result(grad_op)

    type(operator_type), pointer :: grad_op
    grad_op => grad

  end function get_grad

  !> Function to return a pointer to the curl operator
  !> @return The curl operator
  function get_curl() result(curl_op)

    type(operator_type), pointer :: curl_op
    curl_op => curl

  end function get_curl

  !> Function to return a pointer to the div operator
  !> @return The grad operator
  function get_div() result(div_op)

    type(operator_type), pointer :: div_op
    div_op => div

  end function get_div

  !> Function to return a pointer to the quadrature object
  !> @return The quadrature object
  function get_qr() result(qr_obj)

    type(quadrature_type), pointer :: qr_obj
    qr_obj => qr

  end function get_qr

  !> Function to return a pointer to a inverse lumped mass matrix
  !> @param[in] i Index of the desired lumped mass matrix inverse field
  !> @return The lumped inverse mass matrix 
  function get_inverse_lumped_mass_matrix(i) result(mm)

    integer, intent(in) :: i
    type(field_type), pointer :: mm

    select case (i)
      case (w0_id)
        mm => m0_lumped_inv
      case (w1_id)
        mm => m1_lumped_inv
      case (wt_id)
        mm => mt_lumped_inv
      case (theta_space_id)
        if (wtheta_on) then
          mm => mt_lumped_inv
        else  
          mm => m0_lumped_inv
        end if
      case default
        mm => null()
        call log_event( "Lumped inverse mass matrix does not exist", LOG_LEVEL_ERROR)
        stop
    end select

  end function get_inverse_lumped_mass_matrix

end module runtime_constants_mod
