!-----------------------------------------------------------------------------
! (c) Crown copyright 2019 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Compute the flux F of a variable rho by a wind U: F = rho*U
!> @todo There are number of workarounds in this algorithm for aspects which
!!       aren't yet supported by PSyclone/LFRic:
!!       1. Issue #868 Multidata fields are not natively supported in PSyclone.
!!                     Currently we treat these as normal fields but need to
!!                     additionally pass in ndata_h or ndata_v to the kernels
!!                     as extra integer arguments.
!!       2. Issue #1246 Region stencils require both the global maximum size of
!!                      the stencil and local column size of the stencil.
!!                      PSyclone currently only passes in the local size and so
!!                      until this is resolved we also pass in the global maximum
!!                      size as an integer argument.
!!       3. Issue #1248 There is no PSyclone support for passing logical types
!!                      to kernels and so as an itermediate solution we create
!!                      an integer argument that = 1 (.true.) or = 0 (.false.).
module flux_shifted_alg_mod

  use constants_mod,                  only: r_def, i_def
  use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
  use geometric_constants_mod,        only: get_coordinates,  &
                                            get_panel_id
  use fem_constants_mod,              only: get_mass_matrix,          &
                                            get_mass_matrix_diagonal
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order,          &
                                            nqp_exact,              &
                                            spherical_coord_system, &
                                            spherical_coord_system_xyz
  use fs_continuity_mod,              only: W2, W3
  use function_space_mod,             only: function_space_type
  use operator_mod,                   only: operator_type
  use poly1d_flux_kernel_mod,         only: poly1d_flux_kernel_type
  use poly1d_vert_flux_kernel_mod,    only: poly1d_vert_flux_kernel_type
  use poly1d_flux_coeffs_kernel_mod,  only: poly1d_flux_coeffs_kernel_type
  use poly1d_vert_flux_coeffs_kernel_mod, &
                                      only: poly1d_vert_flux_coeffs_kernel_type
  use poly2d_flux_kernel_mod,         only: poly2d_flux_kernel_type
  use poly2d_flux_coeffs_kernel_mod,  only: poly2d_flux_coeffs_kernel_type
  use quadrature_rule_gaussian_mod,   only: quadrature_rule_gaussian_type
  use quadrature_xyoz_mod,            only: quadrature_xyoz_type
  use quadrature_face_mod,            only: quadrature_face_type
  use flux_rhs_kernel_mod,            only: flux_rhs_kernel_type
  use mass_matrix_solver_alg_mod,     only: mass_matrix_solver_alg
  use transport_config_mod,           only: operators,            &
                                            fv_flux_order,        &
                                            operators_fv,         &
                                            operators_fem,        &
                                            oned_reconstruction
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_ERROR,   &
                                            LOG_LEVEL_INFO
  use io_config_mod,                  only: subroutine_timers
  use timer_mod,                      only: timer

  implicit none

  private

  integer(i_def)      :: flux_stencil_extent, &
                         flux2d_stencil_size
  ! Interpolation coefficients needed for nonuniform fv operators
  type( field_type )  :: flux_coeffs, &
                         vert_flux_coeffs
  integer(i_def)      :: nfaces_re_h, nfaces_re_v
  integer(i_def)      :: ndata_h, ndata_v

  public  :: flux_shifted_alg
  public  :: flux_shifted_alg_init
  public  :: flux_shifted_alg_final

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !> @brief Initialises the system for running computing the flux
  !>
  !> @details Initializes system required for FV flux computation.
  !>          FV aspects currently only support lowest order elements.
  !>
  !> @param[in] mesh_id Identity of the mesh to create all fields on
  !>
  subroutine flux_shifted_alg_init( mesh_id )

    use fs_continuity_mod,                 only: W3
    use function_space_collection_mod,     only: function_space_collection
    use reference_element_mod,             only: reference_element_type
    use mesh_mod,                          only: mesh_type
    implicit none

    integer(i_def),  intent(in) :: mesh_id

    integer(i_def)              :: flux_stencil_size,  &
                                   polynomial
    type( field_type ), pointer :: chi_sph(:) => null()
    type( field_type ), pointer :: panel_id => null()
    type( field_type ), pointer :: md_w3 => null()

    type( quadrature_rule_gaussian_type )  :: gaussian_quadrature

    type( quadrature_xyoz_type )           :: qr
    type( quadrature_face_type )           :: qrf
    type( function_space_type ), pointer   :: w3_fs => null()
    type( field_type )                     :: w3_field
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type),               pointer :: mesh => null()
    integer(i_def)                         :: face_quad_order
    integer(i_def)                         :: nqp_xy, nqp_z, nqp_xyz
    real(r_def)                            :: transform_radius, chi3_max
    type( function_space_type ),   pointer :: multidata_fs => null()

    if ( operators == operators_fv ) then
      ! This setup is only needed for FV methods
      if ( element_order == 0 ) then
        ! Compute stencil extents
        flux_stencil_extent = fv_flux_order/2_i_def
        !======================================================================!
        ! Compute stencil for nonuniform polynomial fit
        ! Initialise PSy layer arrays (this will not be needed when
        ! multi-dimensional field arrays are supported)
        ! This needs some temporary fields for computing undf in the PSy layer
        w3_fs => function_space_collection%get_fs( mesh_id, element_order, W3 )
        call w3_field%initialise( vector_space = w3_fs )

        ! Get topology information from the reference element
        mesh              => w3_field%get_mesh()
        reference_element => mesh%get_reference_element()
        ! Number of horizontal neighbours from the reference element
        nfaces_re_h = reference_element%get_number_horizontal_faces()
        ! Number of vertical neighbours from the reference element
        nfaces_re_v = reference_element%get_number_vertical_faces()

        if ( oned_reconstruction ) then
          flux_stencil_size = fv_flux_order + 1
        else
          ! Compute the maximum number of cells in the flux stencil
          ! This occurs on a uniform mesh
          ! (this computation is only correct for quadrilateral meshes)
          flux2d_stencil_size = 1
          do polynomial = 1, fv_flux_order
            if ( mod(polynomial, 2) == 0 ) then
              flux2d_stencil_size = flux2d_stencil_size + nfaces_re_h
            else
              flux2d_stencil_size = flux2d_stencil_size + nfaces_re_h*polynomial
            end if
          end do
          flux_stencil_size = flux2d_stencil_size
        end if
        chi_sph => get_coordinates(mesh_id)
        panel_id => get_panel_id(mesh_id)

        if ( spherical_coord_system == spherical_coord_system_xyz ) then
          transform_radius = 0.0_r_def
        else
          ! Compute the smallest surface height of chi(3)
          ! (this is only needed for spherically-based coordinates
          ! Transform radius is minimum height + 1
          call chi_sph(3)%field_minmax(transform_radius, chi3_max)
          transform_radius = 1.0_r_def + abs(transform_radius)
        end if

        nqp_xyz = fv_flux_order+1
        qr = quadrature_xyoz_type(nqp_xyz, gaussian_quadrature)
        if ( oned_reconstruction ) then
          face_quad_order = 1
        else
          face_quad_order = fv_flux_order+1
        end if
        ! Quadrature rule on lateral faces with 1 point in the vertical
        nqp_xy = face_quad_order
        nqp_z  = 1
        qrf = quadrature_face_type(nqp_xy, nqp_z, .true., .false., &
                                   reference_element, gaussian_quadrature)

        call log_event( "Gungho: computing horizontal flux coeffs", LOG_LEVEL_INFO )
        md_w3 => get_mass_matrix_diagonal(W3, mesh_id)
        ! Create multi-data space and field for the vertical flux coefficients
        ndata_h = nfaces_re_h*flux_stencil_size
        multidata_fs => function_space_collection%get_fs( mesh_id, element_order, W3, ndata_h )
        call flux_coeffs%initialise( vector_space = multidata_fs, ndata_first = .true. )
        if ( oned_reconstruction ) then
          call invoke( poly1d_flux_coeffs_kernel_type(                             &
                                          flux_coeffs, md_w3, flux_stencil_extent, &
                                          chi_sph, flux_stencil_extent,            &
                                          panel_id, flux_stencil_extent,           &
                                          ndata_h, fv_flux_order,                  &
                                          transform_radius, qr, qrf ) )
        else
          call invoke(poly2d_flux_coeffs_kernel_type( flux_coeffs, md_w3, flux_stencil_extent, &
                                          chi_sph, flux_stencil_extent, panel_id,              &
                                          flux_stencil_extent, ndata_h, fv_flux_order,         &
                                          flux2d_stencil_size, transform_radius,               &
                                          qr, qrf) )
        end if
        ! Vertical flux coeffs
        call log_event( "Gungho: computing vertical flux coeffs", LOG_LEVEL_INFO )
        ! Create multi-data space and field for the vertical flux coefficients
        ndata_v = nfaces_re_v*(fv_flux_order+1)
        multidata_fs => function_space_collection%get_fs( mesh_id, element_order, W3, ndata_v )
        call vert_flux_coeffs%initialise( vector_space = multidata_fs, ndata_first = .true. )
        ! Quadrature rule on vertical faces with 1 point in both horizontal and
        ! vertical directions
        nqp_xyz = 1
        qrf = quadrature_face_type(nqp_xyz, .false., .true.,                   &
                                   reference_element, gaussian_quadrature)
        call invoke( poly1d_vert_flux_coeffs_kernel_type(                      &
                            vert_flux_coeffs, md_w3, chi_sph, ndata_v,         &
                            fv_flux_order, qr, qrf ) )

        !======================================================================!
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high &
                         order elements", LOG_LEVEL_ERROR )
      end if
    end if  ! No setup is necessary for operators = operator_fem

    nullify( chi_sph, panel_id, md_w3, w3_fs, reference_element, mesh )

  end subroutine flux_shifted_alg_init

  !=============================================================================
  !> @details Finalises allocatable arrays and calls finalising routines for
  !>          kernels that this algorithm initialised.
  subroutine flux_shifted_alg_final()

    implicit none

  end subroutine flux_shifted_alg_final

  !=============================================================================!
  !> @brief Compute the mass flux, f = rho*u using desired spatial reconstruction.
  !>        Options for this are either FE or FV reconstructions.
  !> @param[in,out] mass_flux Mass flux field: f = density*wind
  !> @param[in]     density Field to advect
  !> @param[in]     wind Advecting wind field
  !> @param[in]     logspace Carry out interpolation in log space
  subroutine flux_shifted_alg(mass_flux, density, wind, logspace)

  implicit none

  type(field_type), intent(in)    :: density, wind
  type(field_type), intent(inout) :: mass_flux
  logical, optional, intent(in) :: logspace

  type(field_type),    pointer :: chi_sph(:) => null()
  type(field_type),    pointer :: panel_id => null()
  type(operator_type), pointer :: mm_w2 => null()
  type(field_type),    pointer :: mmd_w2 => null()

  type(quadrature_xyoz_type)          :: qr
  type(quadrature_rule_gaussian_type) :: quadrature_rule
  type(field_type)                    :: rhs_f

  type(function_space_type), pointer  :: u_fs  => null()

  integer(kind=i_def) :: mesh_id
  integer(i_def) :: logspace_loc
  integer(i_def) :: stencil_extent

  ! Psyclone doesn't support the passing of logicals to kernels
  ! so we have to set up an integer instead
  logspace_loc = 0_i_def
  if ( present(logspace) ) then
    if ( logspace ) logspace_loc = 1_i_def
  end if

  mesh_id = mass_flux%get_mesh_id()

  select case(operators)

    case default
      call log_event( "Gungho: Unrecognized option for operator.", LOG_LEVEL_ERROR )

    case(operators_fv)
      ! Set default value to be 0 and then update the mass flux
      ! in cases where the wind is nonzero using an upwind reconstruction
      call invoke( setval_c( mass_flux, 0.0_r_def) )
     if ( oned_reconstruction ) then
       ! Use 1d flux reconstruction
       call invoke( poly1d_flux_kernel_type( mass_flux, wind, density, flux_stencil_extent, &
                                             flux_coeffs, fv_flux_order, ndata_h ) )
     else
       ! Use 2d flux reconstruction
       stencil_extent = fv_flux_order/2
       call invoke( poly2d_flux_kernel_type( mass_flux, wind, density, stencil_extent, &
                                flux_coeffs, ndata_h, flux2d_stencil_size) )
     end if
     ! Compute vertical components of mass flux
     call invoke( poly1d_vert_flux_kernel_type( mass_flux, wind, density,   &
                                                vert_flux_coeffs,           &
                                                ndata_v, fv_flux_order,     &
                                                logspace_loc) )

    case(operators_fem)
      ! Project density*wind into the mass flux space
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

      mm_w2    => get_mass_matrix(W2, mesh_id)
      mmd_w2   => get_mass_matrix_diagonal(W2, mesh_id)
      chi_sph  => get_coordinates(mesh_id)
      panel_id => get_panel_id(mesh_id)
      u_fs     => wind%get_function_space()
      call rhs_f%initialise( vector_space = u_fs )
      call invoke( name = "Transport operators fem",            &
                   setval_c(rhs_f, 0.0_r_def),                  &
                   flux_rhs_kernel_type(rhs_f, wind, density,   &
                                        chi_sph, panel_id, qr), &
                   enforce_bc_kernel_type(rhs_f),               &
                   setval_c(mass_flux, 0.0_r_def) )
      call mass_matrix_solver_alg( mass_flux, rhs_f, .true.)
      nullify( mm_w2, chi_sph, panel_id, mmd_w2, u_fs )
  end select

end subroutine flux_shifted_alg

end module flux_shifted_alg_mod
