!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Remap a field from the standard cubed sphere mesh into one
!!        where the panels have been extended
module remap_on_extended_mesh_alg_mod

  use constants_mod,                 only: i_def, l_def, r_tran
  use r_tran_field_mod,              only: r_tran_field_type
  use field_mod,                     only: field_type
  use integer_field_mod,             only: integer_field_type
  use mesh_mod,                      only: mesh_type
  use geometric_constants_mod,       only: get_coordinates,          &
                                           get_extended_coordinates, &
                                           get_panel_id
  use psykal_lite_mod,               only: invoke_init_remap_on_extended_mesh_kernel_type, &
                                           invoke_remap_on_extended_mesh_kernel_type
  use io_config_mod,                 only: subroutine_timers
  use timer_mod,                     only: timer
  use function_space_mod,            only: function_space_type
  use log_mod,                       only: log_event, LOG_LEVEL_ERROR, LOG_LEVEL_INFO
  use mesh_collection_mod,           only: mesh_collection
  use extrusion_mod,                 only: PRIME_EXTRUSION
  use check_configuration_mod,       only: get_required_stencil_depth

  implicit none

  private

  ! Stencil depth is set to some large number to ensure it contains
  ! enough points for a centred interpolation. The deeper the halo
  ! is the larger the stencil needs to be. A depth 6 stencil is
  ! generally enough for cubic interpolation in a depth 4 halo
  integer(kind=i_def), parameter :: stencil_depth = 6
  ! Use linear (=true) or cubic (=false) interpolation
  logical(kind=l_def), public, parameter :: linear_remap = .true.

  public :: remap_field_on_extended_mesh
  public :: initialise_remap_on_extended_mesh

contains

  !> @brief Compute remap weights an extended cubed sphere mesh
  !> @param[in] mesh Mesh object to compute remapping weights on
  subroutine initialise_remap_on_extended_mesh(remap_weights, remap_indices)

    implicit none

    type(r_tran_field_type),  intent(inout) :: remap_weights
    type(integer_field_type), intent(inout) :: remap_indices

    type(field_type),          pointer :: chi(:) => null(), &
                                          chi_ext(:) => null(), &
                                          panel_id => null()
    type(mesh_type),           pointer :: mesh => null()
    type(mesh_type),           pointer :: twod_mesh => null()
    type(function_space_type), pointer :: fs => null()

    integer(kind=i_def) :: ndata

    if ( subroutine_timers ) call timer('transport.init_extended_mesh')

    call log_event('Setting up remapping weights', &
                   LOG_LEVEL_INFO)

    twod_mesh => remap_weights%get_mesh()
    mesh => mesh_collection%get_mesh(twod_mesh, PRIME_EXTRUSION)

    chi => get_coordinates(mesh%get_id())
    chi_ext => get_extended_coordinates(mesh%get_id())
    panel_id => get_panel_id(mesh%get_id())

    fs => remap_weights%get_function_space()
    ndata = fs%get_ndata()

    call invoke_init_remap_on_extended_mesh_kernel_type(            &
                                           remap_weights,           &
                                           remap_indices,           &
                                           chi_ext,                 &
                                           chi, stencil_depth,      &
                                           panel_id, stencil_depth, &
                                           linear_remap,            &
                                           ndata )

    nullify( chi, chi_ext, panel_id, twod_mesh, mesh, fs )

    if ( subroutine_timers ) call timer('transport.init_extended_mesh')

  end subroutine initialise_remap_on_extended_mesh

  !> @brief Remap a field to remap_field on an extended cubed sphere mesh
  !> @param[in,out] remap_field      Field on extended cubed sphere mesh
  !> @param[in]     field            Field on standard cubed sphere mesh
  !> @param[in]     remap_weights    Interpolation weights for remapping
  !> @param[in]     remap_indices    Index of interpolation points used for remapping
  !> @param[in]     monotone         Force the extended field to be monotone
  !> @param[in]     enforce_minvalue Enforce a minimum value of the extended field
  !> @param[in]     minvalue         Minimum value to set the field to
  !> @param[in]     depth_in         Halo depth to remap field to
  subroutine remap_field_on_extended_mesh(remap_field, field, &
                                          remap_weights, remap_indices, &
                                          monotone,           &
                                          enforce_minvalue,   &
                                          minvalue,           &
                                          depth_in)

    implicit none

    type(r_tran_field_type),  intent(inout) :: remap_field
    type(r_tran_field_type),  intent(in)    :: field
    type(r_tran_field_type),  intent(in)    :: remap_weights
    type(integer_field_type), intent(in)    :: remap_indices
    logical(kind=l_def),      intent(in)    :: monotone
    logical(kind=l_def),      intent(in)    :: enforce_minvalue
    real(kind=r_tran),        intent(in)    :: minvalue
    integer(kind=i_def),      intent(in)    :: depth_in

    type(mesh_type),           pointer :: mesh => null()
    type(field_type),          pointer :: panel_id => null()
    type(function_space_type), pointer :: fs => null()

    integer(kind=i_def) :: ndata
    integer(kind=i_def) :: depth
    type(r_tran_field_type) :: field_to_remap


    if ( subroutine_timers ) call timer('transport.remap_extended_mesh')

    fs => remap_weights%get_function_space()
    ndata = fs%get_ndata()

    mesh => field%get_mesh()
    panel_id => get_panel_id(mesh%get_id())

    ! Ensure remapping depth is not larger than the halo depth
    depth = min( depth_in, get_required_stencil_depth() )
    ! Both the field to be remapped and the remapped field need to be
    ! created with the full size halo. For the field to be remapped
    ! this is due to the interpolation parallel to a panel boundary
    ! potentially needing many points in order to compute the correct
    ! stencil. For the remapped field the need to use the full halo
    ! depth is due to the possibility of it being needed to a larger
    ! halo depth (than that expected by the depth_in arguement)
    ! in the computation of departure points for the consistent scheme.
    call remap_field%initialise( field%get_function_space(), &
                                 halo_depth = mesh%get_halo_depth() )
    call field_to_remap%initialise( field%get_function_space(), &
                                    halo_depth = mesh%get_halo_depth() )
    call invoke( setval_x( remap_field, field ), &
                 setval_x( field_to_remap, field) )
    call invoke_remap_on_extended_mesh_kernel_type(          &
                                           remap_field,      &
                                           field_to_remap,   &
                                           stencil_depth,    &
                                           remap_weights,    &
                                           remap_indices,    &
                                           panel_id,         &
                                           ndata,            &
                                           monotone,         &
                                           enforce_minvalue, &
                                           minvalue,         &
                                           depth )
    nullify(mesh, fs, panel_id)

    if ( subroutine_timers ) call timer('transport.remap_extended_mesh')

  end subroutine remap_field_on_extended_mesh

end module remap_on_extended_mesh_alg_mod
