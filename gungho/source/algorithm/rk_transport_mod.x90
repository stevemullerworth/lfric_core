!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the transport equation
!>@details An algorithm for timstepping the 3D transport equation using a
!>         multistage explicit Runge-Kutta algorithm.
module rk_transport_mod

  use constants_mod,                     only: r_def, i_def
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE

  ! Configuration and restart/checkpoint options
  use finite_element_config_mod,         only: element_order, supg
  use restart_control_mod,               only: restart_type
  use timestepping_config_mod,           only: dt
  use runge_kutta_init_mod,              only: num_rk_stage, ak
  use runtime_constants_mod,             only: get_mass_matrix, &
                                               get_mass_matrix_diagonal, &
                                               get_qr, &
                                               w2_id, w3_id, w3inv_id, &
                                               wt_id, theta_space_id, &
                                               get_coordinates

  use transport_config_mod,              only: operators,              &
                                               fv_flux_order,          &
                                               fv_advective_order,     &
                                               transport_operators_fv, &
                                               transport_operators_fem

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                   only: invoke_axpy,                   &
                                               invoke_sample_poly_flux,       &
                                               invoke_sample_poly_adv,        &
                                               invoke_divide_field
  ! PsyKAl PSYClone kernels
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use flux_rhs_kernel_mod,               only: flux_rhs_kernel_type
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use rtheta_supg_kernel_mod,            only: rtheta_supg_kernel_type


  use sample_poly_flux_kernel_mod,       only: sample_poly_flux_init
  use sample_poly_adv_kernel_mod,        only: sample_poly_adv_init

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use operator_mod,                      only: operator_type

  ! Algorithms
  use solver_mod,                        only: solver_algorithm
  ! Log
  use log_mod,                           only: log_event,         &
                                               LOG_LEVEL_ERROR
  use output_config_mod,                 only: subroutine_timers 
  use timer_mod,                         only: timer
  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type )              :: rho_n, r_u, r_rho, rho_inc, mass_flux, &
                                     theta_n, r_theta, theta_inc
  type( field_type ), allocatable :: rr_prediction(:), rt_prediction(:)
  type( field_type )              :: mt_lumped
  type( field_type )              :: rho0, theta0
  type( field_type )              :: ones

  integer(i_def) :: flux_stencil_extent, &
                    advective_stencil_extent

  public :: rk_transport_init
  public :: rk_transport_step
  public :: rk_transport_final

contains

  !> @brief Init routine for rk transport timestepping algorithm
  !> @details Rho and u fields are initialised before
  !>          this algorithm is called. State items are created,
  !> @param[in]    mesh_id Mesh id of mesh on which the model runs
  !> @param[in]    u 3D wind field
  !> @param[inout] rho Density like field
  !> @param[inout] theta Temperature like field
  subroutine rk_transport_init( mesh_id, u, rho, theta)
    use mesh_mod,                          only: mesh_type
    use mesh_collection_mod,               only: mesh_collection
    use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
    implicit none

    ! Mesh id
    integer(i_def),  intent(in) :: mesh_id
    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta

    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: theta_fs => null()
    type( mesh_type ),         pointer :: mesh     => null()

    ! Timestepping variables
    integer :: stage
    type(operator_type), pointer :: mm_wt => null()

    if ( subroutine_timers ) call timer('rk_transport_alg')

    allocate ( rr_prediction(num_rk_stage) )
    allocate ( rt_prediction(num_rk_stage) )

    !=== Section 1: Create field objects =====================================!
    ! Local fields
    u_fs     => u%get_function_space()
    rho_fs   => rho%get_function_space()
    theta_fs => theta%get_function_space()

    rho_n        = field_type( vector_space = rho_fs )
    r_rho        = field_type( vector_space = rho_fs )
    rho_inc      = field_type( vector_space = rho_fs )
    r_u          = field_type( vector_space = u_fs )
    mass_flux    = field_type( vector_space = u_fs )
    theta_n      = field_type( vector_space = theta_fs )
    r_theta      = field_type( vector_space = theta_fs )
    theta_inc    = field_type( vector_space = theta_fs )


    do stage = 1,num_rk_stage
      rr_prediction(stage) = field_type( vector_space = rho_fs )
      rt_prediction(stage) = field_type( vector_space = theta_fs )
    end do

    call invoke( set_field_scalar(0.0_r_def, mass_flux) )

    if ( operators == transport_operators_fv ) then
      if ( element_order == 0 ) then
        mesh => mesh_collection%get_mesh( mesh_id )
        call sample_poly_flux_init(fv_flux_order, mesh%get_nlayers())
        call sample_poly_adv_init (fv_advective_order, mesh%get_nlayers())
        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high order elements", LOG_LEVEL_ERROR )
      end if
      mm_wt => get_mass_matrix(wt_id)
      ones  = field_type( vector_space = theta_fs )
      mt_lumped  = field_type( vector_space = theta_fs )
      call invoke( set_field_scalar(1.0_r_def, ones), &
                   set_field_scalar(0.0_r_def, mt_lumped) )
      call invoke( matrix_vector_kernel_type(mt_lumped, ones, mm_wt) )
    else
      ones  = field_type( vector_space = rho_fs)
      call invoke( set_field_scalar(1.0_r_def, ones) )
    end if

    ! Store initial values for computing errors
    rho0   = rho
    theta0 = theta
    if ( subroutine_timers ) call timer('rk_transport_alg')

  end subroutine rk_transport_init

  !> @brief A Runge-Kutta time-discretisation of the transport equation
  !> @details An algorithm for timstepping the transport equation using the
  !>          Runge-Kutta algorithm. theta, rho and u fields are initialised before
  !>          this algorithm is called.
  !>          If fem advection is used theta must be in W0,
  !>          If fv advection is used theta must be in Wtheta
  !> @param[in]    u 3D wind field
  !> @param[inout] rho Density like tracer
  !> @param[inout] theta Temperature like tracer

  subroutine rk_transport_step( u, rho, theta)

    implicit none

    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta

    ! the quadrature object
    type( quadrature_type )          :: qr
    ! Coordinate fields
    type( field_type ), pointer :: chi(:) => null()

    integer(i_def) :: stage, st


    ! temps for retrieving objects back from runtime constants
    type(operator_type), pointer :: mm_w3_inv => null()
    if ( subroutine_timers ) call timer('rk_transport_alg')

    qr = get_qr()
    chi => get_coordinates()

    ! Create operators needed for timestepping
    mm_w3_inv => get_mass_matrix(w3inv_id)
    call invoke( copy_field(rho,   rho_n), &
                 copy_field(theta, theta_n) )


    ! Runge-Kutta algorithm
    do stage = 1,num_rk_stage
      ! Compute advection terms
      ! mass flux ( F = rho * u )
      select case(operators)
        case(transport_operators_fv)
          ! Use polynomial reconstruction
          call invoke_sample_poly_flux( mass_flux, u, rho, &
                                        flux_stencil_extent )
          call invoke_sample_poly_adv( rt_prediction(stage), theta, u, &
                                       advective_stencil_extent )
        case(transport_operators_fem)      
          ! Use FEM projection
          ! Initialise fields
          call invoke( set_field_scalar(0.0_r_def, r_u),       &
                       set_field_scalar(0.0_r_def, mass_flux), &
                       set_field_scalar(0.0_r_def, rt_prediction(stage)) )

          ! Rho advection, compute mass flux 
          call invoke( flux_rhs_kernel_type(r_u, u, rho, chi, qr) )
          call invoke( enforce_bc_kernel_type(r_u) )
          call solver_algorithm( mass_flux, r_u) 

          ! theta advection
          call invoke( rtheta_kernel_type( rt_prediction(stage), theta, u, qr) )
          if ( supg ) &
            call invoke( rtheta_supg_kernel_type(rt_prediction(stage),     &
                                theta, theta_n, u, ones, chi, qr) )
        case default
          call log_event( "Gungho: Invalid advection method", LOG_LEVEL_ERROR )
      end select
      ! Compute rrho = div(F)
      call invoke( rrho_kernel_type  ( rr_prediction(stage), mass_flux, qr ) )

      call invoke( set_field_scalar(0.0_r_def, r_rho), &
                   set_field_scalar(0.0_r_def, r_theta) )

      do st = 1, stage
        call invoke_axpy(ak(stage,st), rr_prediction(st), r_rho,   r_rho)
        call invoke_axpy(ak(stage,st), rt_prediction(st), r_theta, r_theta)
      end do

      ! Invert mass matrices and add increments
      ! Rho
      call invoke( set_field_scalar(0.0_r_def, rho_inc) )
      call invoke( matrix_vector_kernel_type( rho_inc, r_rho, mm_w3_inv) )
      call invoke_axpy(dt, rho_inc, rho_n,   rho)

      ! Theta
      select case(operators)
        case(transport_operators_fv) ! theta in Wtheta
          call invoke_divide_field(r_theta, mt_lumped, r_theta)
          call invoke_axpy(-dt,r_theta, theta_n, theta)
        case(transport_operators_fem)
          call solver_algorithm( theta_inc, r_theta)
          call invoke_axpy(-dt, theta_inc, theta_n, theta)
      end select      
    end do


  end subroutine rk_transport_step

  !> @brief Final routine for rk transport timestepping algorithm

  !> @param[in] rho Density
  !> @param[in] theta Potential temperature field
  subroutine rk_transport_final( rho, theta)
    use psykal_lite_mod,          only: invoke_minus_field_data, &
                                        invoke_inner_prod
    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type

   implicit none

    type( field_type ), intent(in) :: rho, theta
 
    type( field_type )                 :: drho, dtheta, l2_rho, l2_theta
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: theta_fs => null()
    type(operator_type),       pointer :: mm_wt, mm_w3 => null()
    real(kind=r_def)                   :: l2

    ! Compute L errors
    rho_fs   => rho%get_function_space()
    theta_fs =>  theta%get_function_space()

    drho   = field_type( vector_space = rho_fs )
    dtheta = field_type( vector_space = theta_fs )
    call invoke_minus_field_data(rho,   rho0,   drho)
    call invoke_minus_field_data(theta, theta0, dtheta)
    
    ! L2 error
    mm_w3 => get_mass_matrix(w3_id)
    mm_wt => get_mass_matrix(theta_space_id)
    l2_theta = field_type( vector_space = theta_fs )
    l2_rho   = field_type( vector_space = rho_fs )
    call invoke( set_field_scalar(0.0_r_def, l2_theta), &
                 set_field_scalar(0.0_r_def, l2_rho) )
    call invoke( matrix_vector_kernel_type(l2_theta, dtheta, mm_wt) )
    call invoke( matrix_vector_kernel_type(l2_rho,   drho,   mm_w3) )

    call invoke_inner_prod(dtheta, l2_theta, l2)
    write( log_scratch_space, '(A, E15.8)' ) "L2 theta = ", sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_info )

    call invoke_inner_prod(drho, l2_rho, l2)
    write( log_scratch_space, '(A, E15.8)' ) "L2 rho   = ", sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_info )
    if ( subroutine_timers ) call timer('rk_transport_alg')

  end subroutine rk_transport_final

end module rk_transport_mod
