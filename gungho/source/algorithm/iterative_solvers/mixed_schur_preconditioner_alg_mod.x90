!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Preconditioner for the Euler equations system.
!>
!> @details This type is derived from the abstract preconditioner type and
!!  implements a preconditioner for the mixed system in the
!!  variables \f$(\mathbf{u'},\theta',\rho',\Pi')\f$.
!!  More details of the solver forumulation can be found in the solver section of:
!!  https://code.metoffice.gov.uk/trac/lfric/wiki/GhaspSupport/Documentation
!!
!!  The discretised mixed system for the velocity
!!  (\f$\textbf{u}\f$), pressure (\f$\Pi\f$), density (\f$\rho\f$) and  potential
!!  temperature (\f$\theta\f$) unknowns is:
!!
!!  \f[ \delta\mathbf{u} = \left(M_2 + M_\mu + \tau_u C\right)\mathbf{u}' - \tau_u\Delta t(D^* \Pi' + P_{2\theta} \theta') \f]
!!  \f[ \delta\rho       = \rho'  + \tau_\rho\Delta t M_3^{-1} D \left(\rho^*\mathbf{u}'\right)  \f]
!!  \f[ \delta\theta     = M_{\theta} \theta' + \tau_\theta\Delta t P_{\theta2} \mathbf{u}'  \f]
!!  \f[ \delta\Pi        = M_3^{\Pi}\Pi' - M_3^{\rho}\rho' - P_{3\theta}\theta' \f]
!!
!!
!!  Given the right hand side \f$(\mathbf{R}_u,R_t,R_r,R_p)\f$ this needs to be
!!  solved for the state \f$(\mathbf{u'},\theta',\rho',\Pi')\f$.
!!
!!  To construct a preconditioner, proceed as follows:
!!
!!  * Approximately (via lumping the temperature mass matrix) eliminate potential
!!    temperature to obtain an equation for velocity, density and pressure:
!!
!!    \f[ \textbf{R}^*_u = H_B \textbf{u} - \tau_u\Delta t D^* \Pi'        \f]
!!    \f[            R_r = \rho'  + \tau_\rho\Delta t M_3^{-1} D \left(\rho^*\mathbf{u}'\right)  \f]
!!    \f[            R_p =  M_3^{\Pi}\Pi' - M_3^{\rho}\rho' \f]
!!    \f[                - P_{3\theta}\tilde{M}_\theta^{-1}\left(R_t - \tau_\theta\Delta t P_{\theta2}\mathbf{u}'\right) \f]
!!
!!    where
!!    \f[ \textbf{R}^*_u=\textbf{R}_u+\tau_u\Delta t P_{2\theta} \tilde{M}_\theta^{-1} R_t  \f]
!!    \f[ H_B=\tilde{M}_2 + M_{\mu} + \tau_u\tau_{\theta}(\Delta t)^2 \tilde{P_{2\theta}\tilde{M}_\theta^{-1}P_{theta2}\f]
!!
!!    and \f$\tilde{A}\f$ is the lumped version of a matrix \f$A\f$. Note that
!!    any lumped matrix is diagonal, so inversion is straightforward. The lumped
!!    matrices are represented as fields.
!!
!!  * Eliminate the density to obtain an equation for velocity and the pressure only:
!!
!!    \f[ \textbf{R}^*_u = H_B \textbf{u} - \tau_u\Delta t D^* \Pi'        \f]
!!    \f[          R^*_p =  M_3^{\Pi}\Pi' + \tau_\rho\Delta t M_3^{\rho}M_3^{-1} D\left(\rho^*\mathbf{u}'\right) \f]
!!    \f[                + \tau_\theta\Delta t P_{3\theta}\tilde{M}_\theta^{-1} P_{\theta2}\mathbf{u}'\right)  \f]
!!
!!    where
!!    \f[ R^*_p= R_p + P_{3\theta}\tilde{M}_\theta^{-1}R_t + \tau_\rho\Delta t M_3^{\rho}M_3^{-1}R_r \f]
!!
!!  * Eliminate velocity to obtain a Helmholtz-equation for pressure only:
!!
!!    \f[ \mathcal{R} = H \Pi \f]
!!
!!    where
!!
!!    \f[ \mathcal{R}= R^*_p - \tau_\rho\Delta t M_3^{\rho}M_3^{-1} D\left(\rho^*H_B^{-1}\mathbf{R}^*_u\right) \f]
!!    \f[                    + \tau_\theta\Delta t P_{3\theta}\tilde{M}_\theta^{-1} P_{\theta2}H_B^-1\mathbf{R}^*_u\right) \f]
!!
!!    and the Helmholtz operator is given as
!!
!!    \f[ H =  M_3^{\Pi} + \tau_u\tau_\rho\Delta t*2 M_3^{\rho}M_3^{-1} D\left(\rho^*\mathbf{X}\right)
!!                       + \tau_u\tau_\theta\Delta t*2 P_{3\theta}\tilde{M}_\theta^{-1} P_{\theta2}\mathbf{X}\right) \f]
!!
!!    with \f[ X \equiv H_B^-1 D^*\Pi' \f]
!!
!!  * Given the solution \f$\Pi'\f$ of the Helmholtz-system, the velocity, density and
!!    potential temperature are reconstructed as
!!
!!    \f[ \textbf{u} = H_B^{-1} (\mathbf{R}^*_u + \tau_u\Delta t D^* \Pi)     \f]
!!    \f[ \theta     = \tilde{M}_\theta^{-1}(R_t - \tau_\theta\Delta t P_{\theta2} \textbf{u}) \f]
!!    \f[ \rho       = R_r - \tau_\rho\Delta t M_3^-1 D u \f]
!!
!!  More specifically, the preconditioner proceeds along the following steps
!!
!!  1. Calculate \f$\textbf{R})u^*\f$ and then \f$R^*_p\f$
!!  2. Approximately solve the Helmholtz-system \f$R^*_p = H \Pi\f$ with an iterative
!!     solver
!!  3. Given \f$\Pi\f$, reconstruct the velocity \f$\textbf{u}\f$, density \f$\rho\f$ and
!!     potential temperature \f$\theta\f$
!!
!!  The Helmholtz system is solved with an iterative solver which is passed
!!  in the constructor.

module mixed_schur_preconditioner_alg_mod

  use vector_mod,                      only: abstract_vector_type
  use field_mod,                       only: field_type
  use field_vector_mod,                only: field_vector_type
  use r_solver_field_mod,              only: r_solver_field_type
  use r_solver_field_vector_mod,       only: r_solver_field_vector_type
  use constants_mod,                   only: i_def, r_def, r_solver
  use preconditioner_mod,              only: abstract_preconditioner_type
  use iterative_solver_mod,            only: abstract_iterative_solver_type
  use field_indices_mod,               only: isol_u, isol_t, isol_d, isol_p, &
                                             isol_uv, isol_w
  use io_config_mod,                   only: subroutine_timers
  use timer_mod,                       only: timer
  use mixed_solver_config_mod,         only: split_w
  use log_mod,                         only: log_event,       &
                                             LOG_LEVEL_ERROR, &
                                             LOG_LEVEL_INFO,  &
                                             LOG_LEVEL_DEBUG, &
                                             log_scratch_space
  use mesh_mod,                        only: mesh_type
  use si_operators_alg_mod,            only: get_m3_rho_star, &
                                             get_compound_div, &
                                             get_div_star, &
                                             get_ptheta2v, &
                                             get_p2theta, &
                                             get_p3theta, &
                                             get_rho_at_u, &
                                             get_helm_diag, &
                                             get_Hb_lumped_inv, &
                                             get_eliminated_q32
  use fem_constants_mod,               only: get_inverse_w3_mass_matrix_r_solver, &
                                             get_div_r_solver, &
                                             get_normalisation_r_solver
  use limited_area_constants_mod,      only: get_mask_r_solver
  use fs_continuity_mod,               only: W2, W3, Wtheta
  use boundaries_config_mod,           only: limited_area
  use mixed_solver_config_mod,         only: eliminate_variables,          &
                                             eliminate_variables_none,     &
                                             eliminate_variables_discrete, &
                                             eliminate_variables_analytic
  implicit none

  private

  !> @brief Mixed preconditioner type.
  !>
  !> @details Implements mixed preconditioner which can be used in the
  !!          iterative solver algorithms.
  type, public, extends(abstract_preconditioner_type) :: &
                        mixed_schur_preconditioner_type

     private

     !> modified right-hand \f$R_p^*\f$
     type(r_solver_field_type) :: rhs_p
     !> modified right-hand \f$\textbf{R}_u^*\f$
     type(r_solver_field_type) :: rhs_u
     !> Temporary RHS for thermodynamic and continuity equations
     type(r_solver_field_type) :: rhs_t, rhs_d
     !> 1-component field vector for right hand side in pressure system
     type(r_solver_field_vector_type) :: pressure_b
     !> 1-component field vector for solution of pressure system
     type(r_solver_field_vector_type) :: pressure_x
     !> Pressure (Helmholtz) solver object
     class(abstract_iterative_solver_type), pointer :: &
        pressure_solver

     contains
     ! Override the (abstract interface) for application of
     ! a preconditioner \f$y = P.x\f$
     procedure, public :: apply => apply_mixed_schur_preconditioner
     procedure, private :: apply_mixed_schur_preconditioner

     !> Private methods
     !> Build the right-hand-side for the Helmholtz equation
     procedure, private :: build_pressure_rhs
     !> Reconstruct the velocity and buoyancy from the solution of the
     !> Helmholtz equation
     procedure, private :: back_substitute

     !> Destructor
     final :: destroy_mixed_schur_preconditioner
  end type mixed_schur_preconditioner_type

  ! Overload the default structure constructor
  interface mixed_schur_preconditioner_type
     module procedure mixed_schur_preconditioner_constructor
  end interface

contains
  !> @brief Construct a <code> mixed_schur_preconditioner_type</code> object.
  !>
  !> @details This constructs all required fields and builds operators such as
  !!          the lumped buoyancy mass matrix \f$\tilde{M}_b\f$ and the matrix
  !!          \f$H_B\f$. The current state is passed in as a field vector to
  !!          be able to extract the relevant function spaces.
  !!
  !!          The matrix \f$\tilde{H}_b^{-1}\f$ is passed in as an argument
  !!          since this matrix is already required for and constructed in
  !!          the pressure operator.
  !>
  !> @param [in] mesh            Mesh to create function spaces on
  !> @param [in] p               Element order for function spaces
  !> @param [in] pressure_solver Solver object for Helmholtz system
  !> @return self the constructed preconditioner object
  function mixed_schur_preconditioner_constructor(mesh, p,      &
                                                  pressure_solver) &
                                                  result(self)

    use function_space_mod,            only: function_space_type
    use function_space_collection_mod, only: function_space_collection
    use fs_continuity_mod,             only: W2

    implicit none

    integer(i_def),                                intent(in) :: p
    type(mesh_type),                       target, intent(in) :: mesh
    class(abstract_iterative_solver_type), target, intent(in) :: pressure_solver

    type(mixed_schur_preconditioner_type)  :: self

    type(mesh_type), pointer :: mesh_ptr => null()

    call log_event( 'Constructing approximate Schur mixed preconditioner...', &
                    LOG_LEVEL_INFO )

    mesh_ptr => mesh
    call self%rhs_u%initialise( vector_space = function_space_collection%get_fs( mesh_ptr, p, W2 ) )
    call self%rhs_t%initialise( vector_space = function_space_collection%get_fs( mesh_ptr, p, Wtheta ) )
    call self%rhs_d%initialise( vector_space = function_space_collection%get_fs( mesh_ptr, p, W3 ) )
    call self%rhs_p%initialise( vector_space = function_space_collection%get_fs( mesh_ptr, p, W3 ) )
    nullify( mesh_ptr )

    ! right hand side and solution as a one-component field-vector in
    ! pressure space
    self%pressure_b = r_solver_field_vector_type(1)
    self%pressure_x = r_solver_field_vector_type(1)

    ! Set pressure solver
    self%pressure_solver => pressure_solver

    call log_event( 'done', LOG_LEVEL_INFO )

  end function mixed_schur_preconditioner_constructor

  !> @brief Apply the preconditioner to calculate \f$y = P.x\f$ for the mixed
  !!        system in velocity, pressure, density and potential temperature.
  !>
  !> @details Apply the preconditioner in three steps, as described above:
  !!          1. Construct right-hand side for Helmholtz system
  !!          2. Approximately solve Helmholtz-system
  !!          3. Reconstruct velocity and buoyancy from pressure
  !>
  !> @param[in,out] self Instance of type mixed_schur_preconditioner_type
  !> @param[in] x Field vector containing the residuals
  !!              \f$(\textbf{R}_u, R_t, R_r, R_t)\f$
  !> @param[in,out] y Field vector containing the solution
  !!                  \f$(\textbf{U},\theta,\rho,\Pi)\f$ to be calculated
  subroutine apply_mixed_schur_preconditioner(self, x, y)
    implicit none
    class(mixed_schur_preconditioner_type), intent(inout) :: self
    class(abstract_vector_type),                     intent(in)    :: x
    class(abstract_vector_type),                     intent(inout) :: y

    type(r_solver_field_type) :: exner_inc
    type(r_solver_field_type), pointer :: y_uv => null(), &
                                          y_t => null(),  &
                                          y_d => null(),  &
                                          y_p => null(),  &
                                          y_w => null(),  &
                                          x_p => null()

    if ( subroutine_timers ) call timer('mixed_schur_preconditioner_alg')

    select type(x)
    type is(r_solver_field_vector_type)
       select type(y)
       type is(r_solver_field_vector_type)
         y_p =>  y%get_field_from_position(isol_p)
         call invoke( setval_c( y_p, 0.0_r_solver ) )
         if ( eliminate_variables == eliminate_variables_none ) then
           y_t =>  y%get_field_from_position(isol_t)
           y_d =>  y%get_field_from_position(isol_d)
           call invoke( setval_c( y_t, 0.0_r_solver ),  &
                        setval_c( y_d, 0.0_r_solver ) )
         end if

         if (split_w)then
           y_uv =>  y%get_field_from_position(isol_uv)
           y_w  =>  y%get_field_from_position(isol_w)
           call invoke( setval_c( y_uv, 0.0_r_solver ),  &
                        setval_c( y_w, 0.0_r_solver ) )
         else
           y_uv =>  y%get_field_from_position(isol_u)
           call invoke( setval_c( y_uv, 0.0_r_solver ) )
         end if

         ! STEP 1: Build RHS for Helmholtz system
         call self%build_pressure_rhs(x)

         ! STEP 2: Solve Helmholtz system
         ! Krylov solver to obtain pressure increment
         if ( subroutine_timers ) call timer('mixed_schur solve')

         ! Create exner_inc r_def field
         x_p => self%pressure_x%get_field_from_position(1)
         call x_p%initialise( vector_space = y%vector(isol_p)%get_function_space() )
         call invoke( setval_c(x_p, 0.0_r_solver) )

         ! Create RHS r_def field and copy values from r_solver rhs
         ! (import required to initialise field)
         call self%pressure_b%import_field(self%rhs_p,1)

         ! Solve pressure system in r_def
         call log_event('Schur preconditioner pressure solve:', LOG_LEVEL_INFO)
         call self%pressure_solver%apply(self%pressure_x,self%pressure_b)

         ! Copy out solution to r_solver field
         call exner_inc%initialise( vector_space = y%vector(isol_p)%get_function_space() )
         call self%pressure_x%vector(1)%copy_field(exner_inc)
         if ( subroutine_timers ) call timer('mixed_schur solve')

          ! STEP 3: Back substitute to obtain other fields
          call self%back_substitute(y, x, exner_inc)
       class default
          write(log_scratch_space, '(a)') &
               "mixed_schur_preconditioner_mod: incorrect vector_type argument y"
          call log_event(log_scratch_space, log_level_error)
       end select

    class default
      write(log_scratch_space, '(A)') &
            "mixed_schur_preconditioner_mod: incorrect vector_type argument x"
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

    nullify( x_p, y_w, y_uv, y_p, y_t, y_d )

    if ( subroutine_timers ) call timer('mixed_schur_preconditioner_alg')

  end subroutine apply_mixed_schur_preconditioner

  !> @brief Compute the right-hand-side for the Helmholtz-equation.
  !>
  !> @details Given the right-hand side \f$(\textbf{R}_u,R_t,R_d,R_p)\f$
  !!          for the mixed system, build the right hand side \f$R^*_p\f$
  !!          for the Helmholtz equation.
  !>
  !> @param[in,out] self Instance of type mixed_schur_preconditioner_type
  !> @param[in]     rhs0 Initial residuals \f$(\textbf{R}_u,R_t,R_d,R_p)\f$
  !!                     of the mixed system
  subroutine build_pressure_rhs(self, rhs0)

    use matrix_vector_kernel_mod,         only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod,      only: dg_matrix_vector_kernel_type
    use dg_inc_matrix_vector_kernel_mod,  only: dg_inc_matrix_vector_kernel_type
    use apply_variable_hx_kernel_mod,     only: apply_variable_hx_kernel_type
    use opt_apply_variable_hx_kernel_mod, only: opt_apply_variable_hx_kernel_type
    use operator_mod,                     only: r_solver_operator_type
    use enforce_bc_kernel_mod,            only: enforce_bc_kernel_type
    use finite_element_config_mod,        only: element_order
    use helmholtz_solver_config_mod,      only: normalise
    use fs_continuity_mod,                only: W2, W2h, W2v
    use combine_w2_field_kernel_mod,      only: combine_w2_field_kernel_type

    implicit none

    class( mixed_schur_preconditioner_type ),   intent( inout ) :: self
    type( r_solver_field_vector_type ), target, intent(in)      :: rhs0

    type( r_solver_operator_type ), pointer :: m3_rho_star => null(),    &
                                               p2theta => null(),        &
                                               ptheta2 => null(),        &
                                               p3theta => null(),        &
                                               compound_div => null(),   &
                                               q32_op => null()
    type( r_solver_field_type ),    pointer :: mt_lumped_inv => null(),  &
                                               u_normalisation => null(),&
                                               h_diag => null(),         &
                                               Hb_lumped_inv => null()
    type( r_solver_field_type )             :: u_term, r_p
    real( kind=r_solver ), parameter        :: minus_one = -1.0_r_solver
    type( r_solver_field_type )             :: rhs_uvw
    type( r_solver_field_type ), pointer    :: w2_mask => null(), &
                                               w3_mask => null()
    integer( kind=i_def )                   :: mesh_id
    type( r_solver_field_type ), pointer :: rhs_uv => null(), &
                                            rhs_t => null(), &
                                            rhs_d => null(), &
                                            rhs_p => null(), &
                                            rhs_w => null()

    if ( subroutine_timers ) call timer('mixed_schur rhs')

    rhs_uv => rhs0%vector(isol_uv)
    rhs_p  => rhs0%vector(isol_p)
    if ( eliminate_variables == eliminate_variables_none ) then
      rhs_t  => rhs0%vector(isol_t)
      rhs_d  => rhs0%vector(isol_d)
    end if
    if ( split_w ) then
      rhs_w  => rhs0%vector(isol_w)
    end if

    mesh_id = rhs_uv%get_mesh_id()

    call rhs_uvw%initialise( vector_space = self%rhs_u%get_function_space() )
    if ( split_w )then
      call invoke( name="combine_wind", &
                   combine_w2_field_kernel_type( rhs_uvw, rhs_uv, rhs_w ) )
    else
      call invoke( setval_X( rhs_uvw, rhs_uv ) )
    end if

    call u_term%initialise( vector_space = self%rhs_u%get_function_space() )

    if ( limited_area ) then
      w2_mask => get_mask_r_solver(W2, mesh_id)
      w3_mask => get_mask_r_solver(W3, mesh_id)
    endif

    p2theta         => get_p2theta()
    ptheta2         => get_ptheta2v()
    p3theta         => get_p3theta()
    m3_rho_star     => get_m3_rho_star()
    compound_div    => get_compound_div()
    u_normalisation => get_normalisation_r_solver(W2, mesh_id)
    Hb_lumped_inv   => get_Hb_lumped_inv()

    if ( subroutine_timers ) call timer('mixed_schur rhs:helm_ru')
    if ( eliminate_variables == eliminate_variables_none ) then
      call invoke( name = "compute_helmholtz_ru",                                &
                   setval_X( self%rhs_t, rhs_t ),                                &
                   setval_X( self%rhs_d, rhs_d ),                                &
                   setval_c( u_term, 0.0_r_solver ),                             &
                   matrix_vector_kernel_type( u_term, self%rhs_t, p2theta ),     &
                   inc_X_times_Y( u_term, u_normalisation ),                     &
                   inc_X_plus_Y( u_term, rhs_uvw ),                              &
                   enforce_bc_kernel_type( u_term ),                             &
                   X_times_Y( self%rhs_u, u_term, Hb_lumped_inv ) )
    else
      call invoke( name = "compute_elim_helmholtz_ru",           &
                   setval_c( self%rhs_t, 0.0_r_solver ),         &
                   setval_c( self%rhs_d, 0.0_r_solver ),         &
                   X_times_Y( self%rhs_u, rhs_uvw, Hb_lumped_inv ) )
    end if
    if ( subroutine_timers ) call timer('mixed_schur rhs:helm_ru')

    if ( limited_area ) &
      call invoke( inc_X_times_Y(self%rhs_u, w2_mask) )

    ! Compute H(rhs_u)
    if ( subroutine_timers ) call timer('mixed_schur rhs:helm_rx')
    if ( eliminate_variables == eliminate_variables_analytic ) then
      ! r_pi = rhs_pi - Q32*rhs_u
      q32_op => get_eliminated_q32()
      call r_p%initialise( self%rhs_p%get_function_space() )
      call invoke( dg_matrix_vector_kernel_type(r_p, self%rhs_u, q32_op), &
                   X_minus_Y(self%rhs_p, rhs_p, r_p ) )
    else
      ! r_pi = rhs_pi + P03*M0^-1*rhs_t + M3rho*M3^-1*rhs_r
      ! r_rho already contains M3^-1 factor
      mt_lumped_inv => get_normalisation_r_solver(Wtheta, mesh_id)
      if ( element_order == 0 ) then
        call invoke( opt_apply_variable_hx_kernel_type(                       &
                           self%rhs_p, self%rhs_u, mt_lumped_inv, self%rhs_d, &
                           compound_div, p3theta, ptheta2, m3_rho_star,       &
                           minus_one),                                        &
                     inc_X_plus_Y(self%rhs_p, rhs_p) )
      else
        call invoke( apply_variable_hx_kernel_type(                           &
                           self%rhs_p, self%rhs_u, mt_lumped_inv, self%rhs_d, &
                           compound_div, p3theta, ptheta2, m3_rho_star,       &
                           minus_one),                                        &
                     inc_X_plus_Y(self%rhs_p, rhs_p) )
      end if
      if ( eliminate_variables == eliminate_variables_none ) then
        call invoke( matrix_vector_kernel_type(self%rhs_p, self%rhs_t, p3theta) )
      end if
    end if
    if ( subroutine_timers ) call timer('mixed_schur rhs:helm_rx')

    if ( limited_area ) then
      call invoke( inc_X_times_Y(self%rhs_p, w3_mask) )
    end if

    if ( normalise ) then
       h_diag => get_helm_diag()
       call invoke( inc_X_times_Y(self%rhs_p, h_diag) )
    end if

    call self%rhs_p%log_minmax(LOG_LEVEL_DEBUG, 'helmholtz_rhs')

    nullify( m3_rho_star, p2theta, ptheta2, p3theta, &
             compound_div, mt_lumped_inv, u_normalisation, h_diag, &
             Hb_lumped_inv )

    if ( limited_area ) then
      nullify( w2_mask, w3_mask )
    end if
    if ( subroutine_timers ) call timer('mixed_schur rhs')

  end subroutine build_pressure_rhs

  !> @brief Reconstruct velocity and buoyancy from pressure.
  !>
  !> @details Given the pressure \f$\Pi\f$ from the solution of the Helmholtz
  !!          equation, reconstruct the velocity \f$\textbf{U}\f$, density
  !!          \f$\rho\f$ and potential temperature \f$\theta\f$.
  !>
  !> @param[in,out] self Instance of type mixed_schur_preconditioner_type
  !> @param[in,out] state Solution \f$(\textbf{U},\theta,\rho,\Pi)\f$ of the mixed system
  !> @param[in]     rhs Initial right hand side \f$(\textbf{R}_u,R_t,R_r,R_p)\f$
  !> @param[in]     exner_inc Pressure increment returned from the pressure solver
  subroutine back_substitute(self, state, rhs, exner_inc)

    use matrix_vector_kernel_mod,        only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod,     only: dg_matrix_vector_kernel_type
    use operator_mod,                    only: r_solver_operator_type
    use enforce_bc_kernel_mod,           only: enforce_bc_kernel_type
    use timestepping_config_mod,         only: tau_r, dt
    use split_w2_field_kernel_mod,       only: split_w2_field_kernel_type
    use fs_continuity_mod,               only: W2
    use scaled_matrix_vector_kernel_mod, only: scaled_matrix_vector_kernel_type

    implicit none
    class( mixed_schur_preconditioner_type ), intent( inout ) :: self
    type( r_solver_field_vector_type ),                intent( inout ) :: state
    type( r_solver_field_vector_type ),                intent( in )    :: rhs
    type( r_solver_field_type ),                       intent( in )    :: exner_inc

    type( r_solver_field_type ),    pointer :: rho_at_u => null(),        &
                                               t_normalisation => null(), &
                                               u_normalisation => null(), &
                                               Hb_lumped_inv => null()
    type( r_solver_operator_type ), pointer :: div_star => null(), &
                                               ptheta2 => null(),  &
                                               div => null(),      &
                                               m3_inv => null()
    type( r_solver_field_type )             :: u_inc, theta_inc, rho_inc, &
                                               ru_inc, rr_inc, flux
    real( kind=r_solver ), parameter        :: minus_one = -1.0_r_solver
    real( kind=r_solver )                   :: tau_dt
    type(r_solver_field_type),      pointer :: w3_mask     => null(), &
                                               w2_mask     => null(), &
                                               wtheta_mask => null()
    integer( kind=i_def )                   :: mesh_id

    type(r_solver_field_type), pointer :: rhs_t => null(), &
                                          rhs_d => null()
    type(r_solver_field_type), pointer :: state_uv => null(), &
                                          state_t => null(),  &
                                          state_d => null(),  &
                                          state_p => null(),  &
                                          state_w => null()

    if ( subroutine_timers ) call timer('Schur back substitute')

    mesh_id = self%rhs_u%get_mesh_id()

    ! Create increment fields

    ! u increment
    call u_inc%initialise( vector_space = self%rhs_u%get_function_space() )
    call ru_inc%initialise( vector_space = self%rhs_u%get_function_space() )
    u_normalisation => get_normalisation_r_solver(W2, mesh_id)
    div_star        => get_div_star()
    Hb_lumped_inv   => get_Hb_lumped_inv()
! u' = ru + BC[HB * unorm * D * p']
    call invoke( name = "compute_increments",                                &
                 setval_c(ru_inc, 0.0_r_solver),                             &
                 scaled_matrix_vector_kernel_type(ru_inc, exner_inc,         &
                                                  div_star, u_normalisation, &
                                                  Hb_lumped_inv),            &
                 enforce_bc_kernel_type(ru_inc),                             &
                 X_plus_Y(u_inc, self%rhs_u, ru_inc) )
    if ( limited_area ) then
      w2_mask     => get_mask_r_solver(W2, mesh_id)
      call invoke( inc_X_times_Y(u_inc, w2_mask) )
    end if
    if ( eliminate_variables == eliminate_variables_none ) then
      ! theta & rho increment
      ptheta2  => get_ptheta2v()
      rho_at_u => get_rho_at_u()
      div      => get_div_r_solver(mesh_id)
      m3_inv   => get_inverse_w3_mass_matrix_r_solver(mesh_id)
      t_normalisation => get_normalisation_r_solver(Wtheta, mesh_id)
      call rho_inc%initialise( vector_space = self%rhs_d%get_function_space() )
      call theta_inc%initialise( vector_space = self%rhs_t%get_function_space() )
      call rr_inc%initialise( vector_space = self%rhs_d%get_function_space() )
      call flux%initialise( vector_space = self%rhs_u%get_function_space() )
      rhs_t => rhs%get_field_from_position(isol_t)
      rhs_d => rhs%get_field_from_position(isol_d)
      tau_dt = -real(tau_r*dt, kind=r_solver)
      call invoke( setval_c(theta_inc,  0.0_r_solver),                          &
                   dg_inc_matrix_vector_kernel_type(theta_inc, u_inc, ptheta2), &
                   inc_X_times_Y(theta_inc, t_normalisation),                   &
                   inc_aX_plus_Y(minus_one, theta_inc, rhs_t),                  &
                   X_times_Y(flux, rho_at_u, u_inc),                            &
                   dg_matrix_vector_kernel_type(rr_inc, flux, div),             &
                   dg_matrix_vector_kernel_type(rho_inc, rr_inc, m3_inv),       &
                   inc_aX_plus_Y(tau_dt, rho_inc, rhs_d) )

      ! Increment state array
      if ( limited_area ) then
        w3_mask     => get_mask_r_solver(W3, mesh_id)
        wtheta_mask => get_mask_r_solver(Wtheta, mesh_id)
        call invoke( inc_X_times_Y(theta_inc, wtheta_mask), &
                     inc_X_times_Y(rho_inc,   w3_mask) )
      end if
      state_t => state%get_field_from_position(isol_t)
      state_d => state%get_field_from_position(isol_d)
      call invoke( setval_X(state_t, theta_inc), &
                   setval_X(state_d, rho_inc) )
    end if

    state_p => state%get_field_from_position(isol_p)
    call invoke( setval_X(state_p, exner_inc) )

    if ( split_w )then
      state_uv => state%get_field_from_position( isol_uv )
      state_w  => state%get_field_from_position( isol_w )
      call invoke( name="split_wind", &
                   split_w2_field_kernel_type( state_uv, state_w, u_inc ) )
    else
      state_uv => state%get_field_from_position( isol_u )
      call invoke( setval_X( state_uv, u_inc ) )
    end if

    nullify( div_star, ptheta2, div, m3_inv, rho_at_u, &
             t_normalisation, u_normalisation,         &
             rhs_t, rhs_d, state_uv, state_t, state_d, &
             state_p, state_w )

    if ( subroutine_timers ) call timer('Schur back substitute')

  end subroutine back_substitute

  !> @brief Destructor
  !>
  !> @param[in,out] self Instance of type to be destroyed
  subroutine destroy_mixed_schur_preconditioner(self)
    implicit none
    type(mixed_schur_preconditioner_type), intent(inout) :: self

  end subroutine destroy_mixed_schur_preconditioner

end module mixed_schur_preconditioner_alg_mod
