!-----------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! For further details please refer to the file LICENCE which you should have
! received as part of this distribution.
!-----------------------------------------------------------------------------
!>@brief Routines for solving the semi-implicit equation set by
!!       eliminating all variables in favour of the pressure increment

module gw_pressure_solver_alg_mod
  use field_mod,                          only: field_type
  use constants_mod,                      only: i_def, r_def
  use runtime_constants_mod,              only: get_coordinates, &
                                                get_mass_matrix, &
                                                get_div, &
                                                w0_id, w2_id, w3_id, &
                                                w3inv_id, wt_id
  use initial_temperature_config_mod,     only: bvf_square  
  use timestepping_config_mod,            only: dt
  use gw_miniapp_constants_config_mod,    only: cs_square,                       &
                                                b_space,                         &
                                                gw_miniapp_constants_b_space_w0, &
                                                gw_miniapp_constants_b_space_w3, &
                                                gw_miniapp_constants_b_space_wtheta
  use operator_mod,                       only: operator_type
  use field_indices_mod,                  only: igw_u, igw_p, igw_b
  use output_config_mod,                  only: subroutine_timers 
  use timer_mod,                          only: timer
  implicit none

  private
  real(kind=r_def), private, parameter :: tau_u = 0.5_r_def
  real(kind=r_def), private, parameter :: tau_p = 0.5_r_def
  real(kind=r_def), private, parameter :: tau_b = 0.5_r_def
  integer(kind=i_def), private :: bundle_size = 3
  
  ! Q matrix
  type(operator_type), private :: Q
  
  type(field_type), private :: pressure_rhs
  
  ! Fields for bicgstab (all W3)
  type(field_type), private :: res, p, v, s, t, z, y

  ! Increments
  type(field_type), private :: p_inc, b_inc, u_inc

  ! For building the rhs
  type(field_type), private :: rhs_u, rhs_p, mb_rb, hb_ru

  ! For building the lhs
  type(field_type), private :: grad_p, div_grad_p

  type(field_type), private :: Mb_lumped_inv, Hb_lumped_inv

  ! Sub algorithms used for solving the gw_pressure equation
  public  :: gw_pressure_solver_init
  public  :: gw_pressure_solver_alg
  private :: build_gw_pressure_rhs
  private :: apply_gw_pressure_lhs
  private :: bicgstab
  private :: back_substitute 
  private :: gw_pressure_precondition

contains
!=============================================================================!
!>@brief Create all the required fields for the Helmholtz solver
  subroutine gw_pressure_solver_init(state)
    use function_space_mod,            only: function_space_type
    use finite_element_config_mod,     only: element_order
    use quadrature_mod,                only: quadrature_type, GAUSSIAN
    use compute_q_operator_kernel_mod, only: compute_q_operator_type
    use matrix_vector_nobc_kernel_mod, only: matrix_vector_nobc_kernel_type
    use matrix_vector_kernel_mod,      only: matrix_vector_kernel_type
    use transpose_matrix_vector_kernel_mod, &
                                       only: transpose_matrix_vector_kernel_type
    use log_mod,                       only: log_event,         &
                                             LOG_LEVEL_INFO

    use psykal_lite_mod,               only: invoke_multiply_field_data, &   
                                             invoke_divide_field,        &
                                             invoke_scale_field_data
    implicit none

    type(field_type), intent(in)       :: state(bundle_size)
    type(function_space_type), pointer :: wp => null(), wu => null(), wb => null()
    type(field_type)                   :: ones, M_lumped, QT1
    type(operator_type), pointer       :: Mb => null(), Mu => null()
    type(quadrature_type)              :: qr
    call log_event( 'Constructing pressure solver...', LOG_LEVEL_INFO )

    ! Get needed function spaces
    wu => state(igw_u)%get_function_space()
    wp => state(igw_p)%get_function_space()
    wb => state(igw_b)%get_function_space()

    pressure_rhs = field_type(vector_space = wp)
    p_inc        = field_type(vector_space = wp)
    b_inc        = field_type(vector_space = wb)
    u_inc        = field_type(vector_space = wu)

    ! For building the rhs
    rhs_u = field_type(vector_space = wu)
    rhs_p = field_type(vector_space = wp)
    mb_rb = field_type(vector_space = wb)
    hb_ru = field_type(vector_space = wu)

    ! Create bicgstab fields
    v   = field_type( vector_space = wp)
    z   = field_type( vector_space = wp)
    p   = field_type( vector_space = wp)
    t   = field_type( vector_space = wp)
    s   = field_type( vector_space = wp)
    y   = field_type( vector_space = wp)
    res = field_type( vector_space = wp)
    
    ! Apply lhs
    grad_p     = field_type(vector_space = wu)
    div_grad_p = field_type(vector_space = wp)

    ! Back substitute

    ! Compute inverse approximate Mt
    ones          = field_type(vector_space = wb)
    M_lumped      = field_type(vector_space = wb)
    Mb_lumped_inv = field_type(vector_space = wb)
    select case(b_space)
      case(gw_miniapp_constants_b_space_w0)  
        Mb => get_mass_matrix(w0_id)
      case(gw_miniapp_constants_b_space_w3)  
        Mb => get_mass_matrix(w3_id)
      case(gw_miniapp_constants_b_space_wtheta)  
        Mb => get_mass_matrix(wt_id)
    end select
    call invoke( set_field_scalar(1.0_r_def, ones), &
                 set_field_scalar(0.0_r_def, M_lumped) )
    call invoke( matrix_vector_kernel_type(M_lumped, ones, Mb) )
    call invoke_divide_field(ones, M_lumped, Mb_lumped_inv)
    
    ! Compute Q operator 
    Q = operator_type( wu, wb )
    qr = quadrature_type(element_order+2, GAUSSIAN)
    call invoke( compute_q_operator_type(Q, qr) )

   ! Compute inverse approximate HB
    ones          = field_type(vector_space = wu)
    M_lumped      = field_type(vector_space = wu)
    QT1           = field_type(vector_space = wb)
    Hb_lumped_inv = field_type(vector_space = wu)
    Mu => get_mass_matrix(w2_id)

    call invoke( set_field_scalar(1.0_r_def, ones),     &
                 set_field_scalar(0.0_r_def, M_lumped), & 
                 set_field_scalar(0.0_r_def, QT1) )
    call invoke( transpose_matrix_vector_kernel_type(QT1, ones, Q) )
    call invoke_multiply_field_data(QT1, Mb_lumped_inv, QT1)
    call invoke( matrix_vector_nobc_kernel_type(M_lumped, QT1, Q) )
    call invoke_scale_field_data(tau_u*tau_b*dt**2*bvf_square,M_lumped)    
    call invoke( matrix_vector_nobc_kernel_type(M_lumped, ones, Mu) )
    call invoke_divide_field(ones, M_lumped, HB_lumped_inv)

    call log_event( 'done', LOG_LEVEL_INFO )

  end subroutine gw_pressure_solver_init

!=============================================================================!
!>@brief Control routine for the gw_pressure solver
!>@details Control routine for the gw_pressure solver:
!>         1) Builds the gw_pressure rhs 
!>         2) Solves for the presssure increment using a Krylov method
!>         3) Back substitutes to find remaining field increments

  subroutine gw_pressure_solver_alg(x0, rhs0)
    implicit none

    type(field_type), intent(inout) :: x0(bundle_size)
    type(field_type), intent(in)    :: rhs0(bundle_size)

    if ( subroutine_timers ) call timer('gw_pressure_solver_alg')
    ! Build Helmholtz RHS
    call build_gw_pressure_rhs(pressure_rhs, rhs0)

    ! Krylov solver to obtain pressure increment
    call bicgstab(p_inc, pressure_rhs)

    ! Back substitution to obtain other fields
    call back_substitute(x0, rhs0)
    if ( subroutine_timers ) call timer('gw_pressure_solver_alg')

  end subroutine gw_pressure_solver_alg

!=============================================================================!
!>@brief Compute the rhs to the gw_pressure equation for the pressure increment
  subroutine build_gw_pressure_rhs(gw_pressure_rhs, rhs0)
    use psykal_lite_mod,             only: invoke_multiply_field_data, &
                                           invoke_inc_axpy
    use matrix_vector_kernel_mod,    only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use log_mod,                     only: LOG_LEVEL_DEBUG
    use enforce_bc_kernel_mod,       only: enforce_bc_kernel_type

    implicit none
    type(field_type),                intent(inout) :: gw_pressure_rhs
    type(field_type),                intent(in)    :: rhs0(bundle_size)

    type(operator_type), pointer :: div, M3_inv => null()

    ! rhs = Rp - tau_p * dt * cs^2 * M3^-1 * D * HB^-1 * rhs_u
    ! rhs_u = Ru + tau_u * dt * Q * Mb^-1 * Rb

    ! Compute rhs_u    
    call invoke_multiply_field_data(rhs0(igw_b), Mb_lumped_inv, mb_rb)
    call invoke( set_field_scalar(0.0_r_def, rhs_u) )
    call invoke( matrix_vector_kernel_type(rhs_u, mb_rb, Q) )
    call invoke_inc_axpy(tau_u*dt, rhs_u ,rhs0(igw_u))
    call invoke( enforce_bc_kernel_type(rhs_u) )

    ! Compute rhs
    div    => get_div()
    M3_inv => get_mass_matrix(w3inv_id)
    call invoke_multiply_field_data(rhs_u, Hb_lumped_inv, hb_ru)
    call invoke( dg_matrix_vector_kernel_type(rhs_p, hb_ru, div), &
                 dg_matrix_vector_kernel_type(gw_pressure_rhs, rhs_p, M3_inv) )
    call invoke_inc_axpy(-tau_p*dt*cs_square, gw_pressure_rhs, rhs0(igw_p))

    call gw_pressure_rhs%log_minmax(LOG_LEVEL_DEBUG,  'gw_pressure_rhs ')

  end subroutine build_gw_pressure_rhs

!=============================================================================!
!>@brief Apply the full Helmholtz lhs to a pressure field p, this is the Ax
!>       routine called from the Krylov solver 
  subroutine apply_gw_pressure_lhs(Hp, p)
    use dg_matrix_vector_kernel_mod,        only: dg_matrix_vector_kernel_type
    use transpose_matrix_vector_kernel_mod, only: transpose_matrix_vector_kernel_type
    use psykal_lite_mod,                    only: invoke_multiply_field_data, &
                                                  invoke_inc_axpy
    use enforce_bc_kernel_mod,              only: enforce_bc_kernel_type

    implicit none
    type(field_type),                intent(inout) :: Hp
    type(field_type),                intent(inout) :: p

    type(operator_type), pointer :: div, M3_inv => null()

    ! lhs = (I + tau_p*tau_u*dt^2*cs^2*M3^-1 * D * HB^-1 * D^T)*p
    div    => get_div()
    M3_inv => get_mass_matrix(w3inv_id)
    call invoke( set_field_scalar(0.0_r_def, grad_p) )
    call invoke( transpose_matrix_vector_kernel_type(grad_p, p, div) )
    call invoke( enforce_bc_kernel_type(grad_p) )
    
    call invoke_multiply_field_data(grad_p, Hb_lumped_inv, grad_p)
    call invoke( dg_matrix_vector_kernel_type(div_grad_p, grad_p, div), &
                 dg_matrix_vector_kernel_type(Hp, div_grad_p, M3_inv) )
    call invoke_inc_axpy(tau_p*tau_u*dt**2*cs_square, Hp, p)
    
  end subroutine apply_gw_pressure_lhs

!=============================================================================!
!>@brief Krylov solver specifically for solving the Helmholtz equation 
  subroutine bicgstab(lhs, rhs)
    use solver_config_mod,     only: maximum_iterations, &
                                     si_tolerance
    use psykal_lite_mod,       only: invoke_inner_prod,  &
                                     invoke_axpy,        &
                                     invoke_inc_axpy,    &
                                     invoke_inc_xpby
    use log_mod,               only: log_event,          &
                                     log_scratch_space,  &
                                     LOG_LEVEL_ERROR,    &
                                     LOG_LEVEL_INFO,     &
                                     LOG_LEVEL_DEBUG,    &
                                     LOG_LEVEL_TRACE
    implicit none
    type(field_type),             intent(inout) :: lhs
    type(field_type),             intent(in)    :: rhs

    ! The scalars
    real(kind=r_def)                   :: rho,alpha,omega,beta, norm
    real(kind=r_def)                   :: ts,tt
    ! Others
    real(kind=r_def)                   :: err,sc_err, init_err
    integer(kind=i_def)                :: iter
    
    ! Compute the residual this is a global sum to the PSy ---
    call invoke_inner_prod(rhs,rhs,sc_err)
    sc_err = max(sqrt(sc_err), 0.001_r_def)
    write( log_scratch_space, '(A,E15.8)' ) &
         "solver_algorithm: bicgstab starting ... ||b|| = ", sc_err
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    alpha  = 1.0_r_def
    omega  = 1.0_r_def
    norm   = 1.0_r_def

    call invoke( set_field_scalar(0.0_r_def, lhs), &
                 copy_field(rhs,res) )

    call invoke_inner_prod(res,res,err)
    err = sqrt(err)/sc_err
    init_err=err
    if (err < si_tolerance) then
      write( log_scratch_space, '(A, I2,A,E12.4,A,E15.8)') &
           "gw_pressure solver_algorithm:converged in ", 0,  &
           " iters, init=", init_err,                      &
           " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      return
    end if

    call invoke( set_field_scalar(0.0_r_def, v), &
                 set_field_scalar(0.0_r_def, p) )

    do iter = 1, maximum_iterations

      call invoke_inner_prod(res,rhs,rho)
      beta = (rho/norm) * (alpha/omega)
      ! p = r + beta*(p - omega*v)
      call invoke_inc_axpy(beta, p, res)
      call invoke_inc_xpby(p, -beta*omega, v)
      call gw_pressure_precondition( y, p)
      call apply_gw_pressure_lhs( v, y)
      
      call invoke_inner_prod(rhs,v,norm)
      alpha = rho/norm
      call invoke_axpy(-alpha,v,res,s)
      call gw_pressure_precondition( z, s )
      call apply_gw_pressure_lhs( t, z )

      call invoke_inner_prod(t,t,tt)
      call invoke_inner_prod(t,s,ts)

      omega = ts/tt

      ! lhs = lhs + omega * z + alpha * y
      call invoke_inc_xpby(lhs, omega, z)
      call invoke_inc_xpby(lhs, alpha, y)
      call invoke_axpy(-omega,t,s,res)

      norm = rho

      ! check for convergence
      call invoke_inner_prod(res,res,err)
      err = sqrt(err)/sc_err

      write( log_scratch_space, '(A,I2,A, E15.8)' ) "solver_algorithm[", iter, &
                                                    "]: res = ", err
      call log_event(log_scratch_space, LOG_LEVEL_DEBUG)

      if (err < si_tolerance) then
        write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
             "Helmholtz solver_algorithm:converged in ", iter,    &
             " iters, init=", init_err,                           &
             " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if
    end do

    if(iter >= maximum_iterations) then
      write(log_scratch_space, '(A, I3, A, E15.8)') &
           "Helmholtz solver_algorithm: NOT converged in", iter, " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if
  end subroutine bicgstab

!=============================================================================!
!>@brief Obtain the increments to each field from the pressure field given by
!>       the gw_pressure equation
  subroutine back_substitute( state, rhs)

    use psykal_lite_mod,          only: invoke_inc_axpy,            &
                                        invoke_multiply_field_data, &
                                        invoke_increment_field
    use transpose_matrix_vector_kernel_mod, &
                                  only: transpose_matrix_vector_kernel_type
    use log_mod,                  only: LOG_LEVEL_DEBUG
    use enforce_bc_kernel_mod,    only: enforce_bc_kernel_type

    implicit none
    type(field_type),                intent(inout) :: state(bundle_size)
    type(field_type),                intent(in)    :: rhs(bundle_size)

    type(operator_type), pointer :: div => null()

    ! Initialise increment fields
    call invoke( set_field_scalar(0.0_r_def, u_inc), &
                 set_field_scalar(0.0_r_def, b_inc) )
    ! U increment
    div => get_div()
    call invoke( transpose_matrix_vector_kernel_type(u_inc, p_inc, div) )
    call invoke_inc_axpy(tau_u*dt, u_inc, rhs_u)
    call invoke_multiply_field_data( u_inc, Hb_lumped_inv, u_inc )
    call invoke( enforce_bc_kernel_type(u_inc) )

    ! b increment
    call invoke( transpose_matrix_vector_kernel_type(b_inc, u_inc, Q) )
    call invoke_inc_axpy(-tau_b*dt*bvf_square, b_inc, rhs(igw_b))
    call invoke_multiply_field_data( b_inc, Mb_lumped_inv, b_inc )

    call u_inc%log_minmax(LOG_LEVEL_DEBUG,  'u increment')
    call p_inc%log_minmax(LOG_LEVEL_DEBUG,  'p increment')
    call b_inc%log_minmax(LOG_LEVEL_DEBUG,  'b increment')

    call invoke_increment_field(u_inc, state(igw_u))
    call invoke_increment_field(p_inc, state(igw_p))
    call invoke_increment_field(b_inc, state(igw_b))
  
  end subroutine back_substitute
!=============================================================================!
!>@brief Preconditioner for the gw_pressure equation 
!>@details Options to precondition the gw_pressure equation, currently allows only
!>         preconditioning with the inverse mass matrix or no preconditioner
  subroutine gw_pressure_precondition( y, x, prec)

    implicit none
    type(field_type),             intent(inout) :: y
    type(field_type),             intent(in)    :: x
    integer, intent(in), optional :: prec
    integer                       :: precon

    if ( present(prec) ) precon = prec

    call invoke( copy_field(x, y) )

  end subroutine gw_pressure_precondition
!=============================================================================!

end module gw_pressure_solver_alg_mod

