!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Tests parallel log level handling.
!>
!> @todo pFUnit does not seem very flexible around mixing MPI and none MPI
!>       tests or MPI and parameterised tests. Hence doing it manually.
!>
module log_mod_parallel_level_test

  use constants_mod, only: i_def, str_long
  use log_mod,       only: finalise_logging, initialise_logging, log_event, &
                           log_level_debug, log_level_error,                &
                           log_level_info, log_level_trace,                 &
                           log_level_warning, log_set_alert_stream,         &
                           log_set_level, log_set_info_stream,              &
                           log_forget_timestep
  use pfunit

  implicit none

  private

  public log_level_test_single_trace, log_level_test_single_debug,    &
         log_level_test_single_info, log_level_test_single_warning,   &
         log_level_test_trace, log_level_test_debug,                  &
         log_level_test_info, log_level_test_warning,                 &
         log_output_test_single_trace, log_output_test_single_debug,  &
         log_output_test_single_info, log_output_test_single_warning, &
         log_output_test_trace, log_output_test_debug,                &
         log_output_test_info, log_output_test_warning
  !
  ! pFUnit requires symbol spill
  !
  public :: MPITestCase, MPITestParameter

  integer(i_def), parameter :: log_unit   = 11
  integer(i_def), parameter :: info_unit  = 12
  integer(i_def), parameter :: alert_unit = 13

  @testCase
  type, public, extends(MpiTestCase) :: log_test_type
    character(:), allocatable :: pet_file
  contains
    procedure :: setUp
    procedure :: tearDown
  end type log_test_type

  character(*), parameter :: name = 'log_mod_unit_test'

contains

  subroutine setUp( this )

    implicit none

    class(log_test_type), intent(inout) :: this

    character(str_long) :: filename
    integer(i_def)      :: status

    if (this%getNumProcesses() > 1) then
      write( filename, &
             '("PET", I0, ".", A, ".Log")') this%getProcessRank(), name
      this%pet_file = filename

      open( log_unit, file=this%pet_file, action='write', iostat=status )
      if (status == 0) close( log_unit, status='delete' )
    end if

  end subroutine setUp


  subroutine tearDown( this )

    implicit none

    class(log_test_type), intent(inout) :: this

    integer(i_def) :: status

    if (allocated(this%pet_file)) then
      open( log_unit, file=this%pet_file, action='write', iostat=status )
      if (status == 0) close( log_unit, status='delete' )
    end if

  end subroutine tearDown


  @test(npes=[1])
  subroutine log_output_test_single_trace( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_output_test_serial( log_level_trace, ':TRACE:' )
    call finalise_logging()

  end subroutine log_output_test_single_trace


  @test(npes=[1])
  subroutine log_output_test_single_debug( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_output_test_serial( log_level_debug, ':DEBUG:' )
    call finalise_logging()

  end subroutine log_output_test_single_debug


  @test(npes=[1])
  subroutine log_output_test_single_info( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_output_test_serial( log_level_info, ':INFO :' )
    call finalise_logging()

  end subroutine log_output_test_single_info


  @test(npes=[1])
  subroutine log_output_test_single_warning( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_output_test_serial( log_level_warning, ':WARN :' )
    call finalise_logging()

  end subroutine log_output_test_single_warning


  @test(npes=[2, 3, 4])
  subroutine log_output_test_trace( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_output_test( context%getProcessRank(), log_level_trace, ':TRACE:' )

  end subroutine log_output_test_trace


  @test(npes=[2, 3, 4])
  subroutine log_output_test_debug( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_output_test( context%getProcessRank(), log_level_debug, ':DEBUG:' )

  end subroutine log_output_test_debug


  @test(npes=[2, 3, 4])
  subroutine log_output_test_info( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_output_test( context%getProcessRank(), log_level_info, ':INFO :' )

  end subroutine log_output_test_info


  @test(npes=[2, 3, 4])
  subroutine log_output_test_warning( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_output_test( context%getProcessRank(), log_level_warning, ':WARN :' )

  end subroutine log_output_test_warning


  !> Test the default behaviour of the logger.
  !>
  !> As part of the test system redirecting the output to alternate units is
  !> also tested.
  !>
  subroutine log_output_test( thread, level, expected_tag )

    use, intrinsic :: iso_fortran_env, only : iostat_end

    implicit none

    integer(i_def), intent(in) :: thread
    integer(i_def), intent(in) :: level
    character(*),   intent(in) :: expected_tag

    ! Must hold 14 digits:
    integer(i_def), parameter :: i_time = selected_int_kind( 14 )

    integer(i_time)   :: current_stamp
    character(28)     :: current_date_string
    integer(i_def)    :: current_subseconds
    integer(i_def)    :: current_zone
    character(3)      :: expected_proc
    integer(i_time)   :: found_stamp
    character         :: found_point
    integer(i_def)    :: found_subseconds
    integer(i_def)    :: found_zone
    character(3)      :: found_proc
    character(8)      :: found_tag
    character(80)     :: found_message
    integer(i_def)    :: status
    character(40)     :: filename

    call date_and_time( date=current_date_string(1:8), &
                        time=current_date_string(9:18), &
                        zone=current_date_string(19:) )
    read( current_date_string, "(I14,1X,I3,I5)" ) current_stamp, &
                                                  current_subseconds, &
                                                  current_zone

    call log_set_level( log_level_info )

    call log_event('cheese', level)

    call finalise_logging()

    write( filename, '("PET", I0, ".", A, ".Log")') thread, name
    open( log_unit, file=filename, action='read', iostat=status )
    @assertEqual( 0, status )
    rewind(log_unit)

    write( expected_proc, '(":P", I0)' ) thread

    read( log_unit, '(I14,A1,I3,I5,A3,A8,A)', iostat = status ) &
        found_stamp, found_point, found_subseconds, found_zone, &
        found_proc, found_tag, found_message
    if ( level >= LOG_LEVEL_INFO ) then
      @assertEqual( 0,             status )
      @assertEqual( '.',           found_point )
      @assertEqual( expected_proc, found_proc )
      @assertEqual( expected_tag,  found_tag )
      @assertEqual( 'cheese',      found_message )
      @assertTrue( current_stamp <= found_stamp )
      @assertEqual( current_zone,  found_zone )
    else
      @assertEqual( iostat_end,   status )
    end if

    close( log_unit, status='delete' )

  end subroutine log_output_test


  !> Test the default behaviour of the logger.
  !>
  !> As part of the test system redirecting the output to alternate units is
  !> also tested.
  !>
  subroutine log_output_test_serial( level, expected_tag )

    use, intrinsic :: iso_fortran_env, only : iostat_end

    implicit none

    integer(i_def), intent(in) :: level
    character(*),      intent(in) :: expected_tag

    integer(i_def), parameter :: date_kind = selected_int_kind( 14 )

    integer( kind=date_kind ) :: current_stamp
    character(28)             :: current_date_string
    integer(i_def)            :: current_subseconds
    integer(i_def)            :: current_zone
    integer( kind=date_kind)  :: found_stamp
    character(1)              :: found_point
    integer(i_def)            :: found_subseconds
    integer(i_def)            :: found_zone
    character(8)              :: found_tag
    character(80)             :: found_message
    integer(i_def)         :: status

    open( INFO_UNIT, status='scratch', action='readwrite', iostat=status )
    @assertEqual( 0, status )

    open( ALERT_UNIT, status='scratch', action='readwrite', iostat=status )
    @assertEqual( 0, status )

    call date_and_time( date=current_date_string(1:8), &
                        time=current_date_string(9:18), &
                        zone=current_date_string(19:) )
    read( current_date_string, "(I14,1X,I3,I5)" ) current_stamp, &
                                                  current_subseconds, &
                                                  current_zone

    call log_set_info_stream(INFO_UNIT)
    call log_set_alert_stream(ALERT_UNIT)

    call log_set_level( log_level_info )

    call log_event('cheese', level)

    rewind(INFO_UNIT)
    read( INFO_UNIT, '(I14,A1,I3,I5,A8,A)', iostat = status ) &
        found_stamp, found_point, found_subseconds, found_zone, &
        found_tag, found_message
    if ( ( level >= LOG_LEVEL_INFO ) &
         .and. ( level < LOG_LEVEL_WARNING ) ) then
      @assertEqual( 0,            status )
      @assertEqual( '.',          found_point )
      @assertEqual( expected_tag, found_tag )
      @assertEqual( 'cheese',     found_message )
      @assertTrue( current_stamp <= found_stamp )
      @assertEqual( current_zone, found_zone )
    else
      @assertEqual( iostat_end,        status )
    end if

    rewind( ALERT_UNIT )
    read( ALERT_UNIT, '(I14,A1,I3,I5,A8,A)', iostat = status ) &
        found_stamp, found_point, found_subseconds, found_zone, &
        found_tag, found_message
    if ( level >= LOG_LEVEL_WARNING ) then
      @assertEqual( 0,            status )
      @assertEqual( '.',          found_point )
      @assertEqual( expected_tag, found_tag )
      @assertEqual( 'cheese',     found_message )
      @assertTrue( current_stamp <= found_stamp )
      @assertEqual( current_zone, found_zone )
    else
      @assertEqual( iostat_end,        status )
    end if

    close( ALERT_UNIT, iostat=status )
    @assertEqual( 0, status )
    close( INFO_UNIT, iostat=status )
    @assertEqual( 0, status )

  end subroutine log_output_test_serial


  !> Test the correct things are logged for each log level.
  !>
  subroutine log_level_test_serial( level )

    use, intrinsic :: iso_fortran_env, only : iostat_end

    implicit none

    integer(i_def), intent(in) :: level

    integer(i_def), parameter :: number_of_levels = 4

    integer(i_def)    :: levels( number_of_levels )
    character( 22 )   :: messages( number_of_levels )
    integer(i_def)    :: level_index
    character(  8 )   :: info_tag, alert_tag
    character( 80 )   :: info_message, alert_message
    integer(i_def)    :: info_status, alert_status
    integer(i_def) :: condition

    levels  = [ LOG_LEVEL_TRACE, LOG_LEVEL_DEBUG, &
                LOG_LEVEL_INFO, LOG_LEVEL_WARNING ]
    messages  = [ 'kraft cheeselike slice', &
                  'generic cheddar       ', &
                  'wensleydale           ', &
                  'double gloucester     ']

    open( INFO_UNIT, status='scratch', action='readwrite', &
          iostat=condition )
    @assertEqual( 0, condition )

    open( ALERT_UNIT, status='scratch', action='readwrite', &
          iostat=condition )
    @assertEqual( 0, condition )

    call log_set_info_stream( INFO_UNIT )
    call log_set_alert_stream( ALERT_UNIT )

    call log_set_level( level )

    log_loop: do level_index = 1, number_of_levels
      call log_event( trim( messages(level_index) ), levels(level_index) )
    end do log_loop

    rewind( INFO_UNIT )
    rewind( ALERT_UNIT )
    read_loop: do level_index = 1, number_of_levels
      if ( levels(level_index) >= level ) then
        info_tag = ""
        info_message = ""
        read( INFO_UNIT,  '(23X,A8,A)', iostat = info_status ) info_tag, &
                                                              info_message
        read( ALERT_UNIT, '(23X,A8,A)', iostat = alert_status ) alert_tag, &
                                                                alert_message

        select case (levels(level_index))
          case (LOG_LEVEL_TRACE)
            @assertEqual( ':TRACE:', info_tag )
            @assertEqual( messages(level_index), info_message )
          case (LOG_LEVEL_DEBUG)
            @assertEqual( ':DEBUG:', info_tag )
            @assertEqual( messages(level_index), info_message )
          case (LOG_LEVEL_INFO)
            @assertEqual( ':INFO :', info_tag )
            @assertEqual( messages(level_index), info_message )
          case (LOG_LEVEL_WARNING)
            @assertEqual( ':WARN :', alert_tag )
            @assertEqual( messages(level_index), alert_message )
          case default
            @assertTrue( .false. )
        end select
      end if
    end do read_loop

    close( ALERT_UNIT, iostat=condition )
    @assertEqual( 0, condition )
    close( INFO_UNIT, iostat=condition )
    @assertEqual( 0, condition )

  end subroutine log_level_test_serial


  @test(npes=[1])
  subroutine log_level_test_single_trace( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_level_test_serial( log_level_trace )
    call finalise_logging()

  end subroutine log_level_test_single_trace


  @test(npes=[1])
  subroutine log_level_test_single_debug( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_level_test_serial( log_level_debug )
    call finalise_logging()

  end subroutine log_level_test_single_debug


  @test(npes=[1])
  subroutine log_level_test_single_info( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_level_test_serial( log_level_info )
    call finalise_logging()

  end subroutine log_level_test_single_info


  @test(npes=[1])
  subroutine log_level_test_single_warning( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_level_test_serial( log_level_warning )
    call finalise_logging()

  end subroutine log_level_test_single_warning


  @test(npes=[2, 3, 4])
  subroutine log_level_test_trace( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_level_test( context%getProcessRank(), log_level_trace )

  end subroutine log_level_test_trace


  @test(npes=[2, 3, 4])
  subroutine log_level_test_debug( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_level_test( context%getProcessRank(), log_level_debug )

  end subroutine log_level_test_debug


  @test(npes=[2, 3, 4])
  subroutine log_level_test_info( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_level_test( context%getProcessRank(), log_level_info )

  end subroutine log_level_test_info


  @test(npes=[2, 3, 4])
  subroutine log_level_test_warning( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name )
    call log_forget_timestep()
    call log_level_test( context%getProcessRank(), log_level_warning )

  end subroutine log_level_test_warning


  !> Test the correct things are logged for each log level.
  !>
  subroutine log_level_test( thread, level )

    use, intrinsic :: iso_fortran_env, only : iostat_end

    implicit none

    integer(i_def), intent(in) :: thread
    integer(i_def), intent(in) :: level

    character(110)    :: buffer
    character(3)      :: expected_process
    integer(i_def)    :: level_index
    character(3)      :: process
    character(7)      :: tag
    character(80)     :: message
    integer(i_def)    :: status
    character(40)     :: filename
    integer(i_def), allocatable :: levels(:)
    character(22),  allocatable :: messages(:)

    levels  = [ LOG_LEVEL_TRACE, LOG_LEVEL_DEBUG, &
                LOG_LEVEL_INFO, LOG_LEVEL_WARNING ]
    messages  = [ 'kraft cheeselike slice', &
                  'generic cheddar       ', &
                  'wensleydale           ', &
                  'double gloucester     ']

    call log_set_level( level )

    log_loop: do level_index = 1, size(levels)
      call log_event( trim( messages(level_index) ), levels(level_index) )
    end do log_loop

    call finalise_logging()

    write( filename, '("PET", I0, ".", A, ".Log")') thread, name
    open( log_unit, file=filename, action='read', iostat=status )
    @assertEqual( 0, status )

    write( expected_process, '(":P", I0)' ) thread

    read_loop: do level_index = 1, size(levels)
      if ( levels(level_index) >= level ) then
        process = ""
        tag = ""
        message = ""
        read( log_unit, '(A)' ) buffer
        read( buffer, '(23X,A3,A7,A)', iostat=status ) process, tag, message

        @assertEqual( expected_process, process )
        select case (levels(level_index))
          case (LOG_LEVEL_TRACE)
            @assertEqual( ':TRACE:', tag )
          case (LOG_LEVEL_DEBUG)
            @assertEqual( ':DEBUG:', tag )
          case (LOG_LEVEL_INFO)
            @assertEqual( ':INFO :', tag )
          case (LOG_LEVEL_WARNING)
            @assertEqual( ':WARN :', tag )
          case default
            @assertTrue( .false., "Unexpected logging level" )
        end select
        @assertEqual( messages(level_index), message )
      end if
    end do read_loop

    close( log_unit, status='delete' )

  end subroutine log_level_test

! This test should be instated once we have refactored the logging framework
! to allow it. Currently logging an error calls the "exit" intrinsic which
! stops everything including the unit testing framework. This is a shortcoming
! in the unit testing framework but not one anyone seems in a rush to fix.
!
!   !> Test error logging behaviour. Because errors cause a "STOP" they can not
!   !> be tested with the others. Or at all at the moment.
!   @test
!   subroutine error_test( context )
!
!     implicit none
!
!     class ( log_test_type ), intent( inout ) :: context
!
!     character(  8 ) :: tag
!     character( 80 ) :: message
!
!     call log_set_info_stream( INFO_UNIT )
!     call log_set_alert_stream( ALERT_UNIT )
!
!     call log_event( 'stilton', LOG_LEVEL_ERROR )
!
!     rewind( INFO_UNIT )
!     read( INFO_UNIT, '(23X,A8,A)' ) tag, message
!     @assertEqual( ':ERROR:', tag )
!     @assertEqual( 'stilton', message )
!
!     rewind( ALERT_UNIT )
!     read( ALERT_UNIT, '(23X,A8,A)' ) tag, message
!     @assertEqual( ':ERROR:', tag )
!     @assertEqual( 'stilton', message )
!
!   end subroutine error_test

end module log_mod_parallel_level_test
