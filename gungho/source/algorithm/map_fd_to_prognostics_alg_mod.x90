!-----------------------------------------------------------------------------
! (C) Crown copyright 2019 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Set prognostic fields from FD start dump
module map_fd_to_prognostics_alg_mod
  use constants_mod,                   only: r_def, i_def
  use log_mod,                         only: log_event,         &
                                             log_scratch_space, &
                                             LOG_LEVEL_INFO,    &
                                             LOG_LEVEL_TRACE
  use base_mesh_config_mod,            only: geometry,          &
                                             geometry_spherical
  ! Derived Types
  use field_mod,                       only: field_type
  use field_collection_mod,            only: field_collection_type
  use operator_mod,                    only: operator_type


  use quadrature_xyoz_mod,             only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,    only: quadrature_rule_gaussian_type
  use fem_constants_mod,               only: get_rmultiplicity
  use geometric_constants_mod,         only: get_height,          &
                                             get_coordinates_xyz, &
                                             get_coordinates,     &
                                             get_panel_id
  use physical_op_constants_mod,       only: get_coriolis
  use fs_continuity_mod,               only: W3, W2
  use initialization_config_mod,       only: ancil_option,                &
                                             ancil_option_aquaplanet,     &
                                             hydro_coriolis
  use sort_ref_kernel_mod,             only: sort_ref_kernel_type
  use io_config_mod,                   only: subroutine_timers
  use timer_mod,                       only: timer

  implicit none

  private
  public :: map_fd_to_prognostics, hydrostatic_balance, set_wind

contains

  !> @details Setting FE prognostic fields from FD fields
  !> @param[in,out] prognostic_fields  Collection of prognostic fields
  !> @param[in,out] mr                 Array of moisture mixing ratios
  !> @param[in]     fd_fields          Collection of input Finite Difference
  !>                                    fields
  subroutine map_fd_to_prognostics(prognostic_fields, mr, moist_dyn,          &
                                   fd_fields)

    use mr_indices_mod,             only : imr_v, imr_cl, imr_ci, imr_r, &
                                           imr_s, imr_g
    use moist_dyn_mod,              only : num_moist_factors
    use moist_dyn_factors_alg_mod,  only : moist_dyn_factors_alg

    implicit none

    ! FE Prognostic fields
    type(field_collection_type), intent( inout ) :: prognostic_fields
    type(field_type),            intent( inout ) :: mr(:)
    type(field_type),            intent( inout ) :: moist_dyn(num_moist_factors)

    type( field_collection_type), intent( in ) :: fd_fields

    !Local dereferenced fields
    type( field_type ), pointer :: theta                  => null()
    type( field_type ), pointer :: rho                    => null()
    type( field_type ), pointer :: u                      => null()
    type( field_type ), pointer :: exner                  => null()

    ! FD  fields
    type( field_type ), pointer :: ew_wind_in_w3          => null()
    type( field_type ), pointer :: ns_wind_in_w3          => null()
    type( field_type ), pointer :: dry_rho_in_w3          => null()
    type( field_type ), pointer :: upward_wind_in_wtheta  => null()
    type( field_type ), pointer :: theta_in_wtheta        => null()
    type( field_type ), pointer :: mv_in_wtheta           => null()
    type( field_type ), pointer :: mcl_in_wtheta          => null()
    type( field_type ), pointer :: mcf_in_wtheta          => null()
    type( field_type ), pointer :: mr_in_wtheta           => null()

    !FD (source) fields
    ew_wind_in_w3         => fd_fields%get_field('ew_wind_in_w3')
    ns_wind_in_w3         => fd_fields%get_field('ns_wind_in_w3')
    dry_rho_in_w3         => fd_fields%get_field('dry_rho_in_w3')
    upward_wind_in_wtheta => fd_fields%get_field('upward_wind_in_wtheta')
    theta_in_wtheta       => fd_fields%get_field('theta_in_wtheta')
    mv_in_wtheta          => fd_fields%get_field('mv_in_wtheta')
    mcl_in_wtheta         => fd_fields%get_field('mcl_in_wtheta')
    mcf_in_wtheta         => fd_fields%get_field('mcf_in_wtheta')
    mr_in_wtheta          => fd_fields%get_field('mr_in_wtheta')

    !Prognostic (target) fields
    u                     => prognostic_fields%get_field('u')
    theta                 => prognostic_fields%get_field('theta')
    exner                 => prognostic_fields%get_field('exner')
    rho                   => prognostic_fields%get_field('rho')

    ! Some variables should coming in from the restart file, but currently
    ! they are not output by UM2LFRIC and are set to zero or a default value
    ! This will need to be reviewed if this becomes a checkpoint-restart
    ! routine and/or um2lfric is updated for GAL physics
    call invoke( setval_x(theta, theta_in_wtheta),    &
                 setval_x(rho, dry_rho_in_w3),        &
                 setval_x(mr(imr_v), mv_in_wtheta),   &
                 setval_x(mr(imr_cl), mcl_in_wtheta), &
                 setval_x(mr(imr_ci), mcf_in_wtheta), &
                 setval_x(mr(imr_r), mr_in_wtheta),   &
                 setval_c(mr(imr_s), 0.0_r_def),      &
                 setval_c(mr(imr_g), 0.0_r_def),      &
                 setval_c(exner, 0.0_r_def),          &
                 setval_c(upward_wind_in_wtheta, 0.0_r_def))

    call set_wind( u, ew_wind_in_w3, ns_wind_in_w3, upward_wind_in_wtheta )

    ! Update factors for moist dynamics
    call moist_dyn_factors_alg( moist_dyn, mr )
    ! Remove any static instability
    call invoke( sort_ref_kernel_type(theta) )
    ! Initialize hydrostatically balanced exner field
    call hydrostatic_balance( exner, rho, theta, u, moist_dyn )

    call log_event( "Gungho: Set prognostic fields from FD fields", LOG_LEVEL_INFO )

  end subroutine map_fd_to_prognostics

  !> @param[in,out] u Wind (FE)
  !> @param[in] u_lon Zonal Wind (FD)
  !> @param[in] u_lat Meridional Wind (FD)
  !> @param[in] u_up Upward Wind (FD)
  subroutine set_wind(u, u_lon, u_lat, u_up)

    use map_u_kernel_mod,            only: map_u_kernel_type
    use enforce_bc_kernel_mod,       only: enforce_bc_kernel_type
    use mass_matrix_solver_alg_mod,  only: mass_matrix_solver_alg
    implicit none

    type( field_type ), intent( inout ) :: u
    type( field_type ), intent( in ) :: u_lat, u_lon, u_up

    type( quadrature_xyoz_type )          :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule
    type( field_type )                    :: r_u
    type( field_type ), pointer           :: chi_sph(:) => null()
    type( field_type ), pointer           :: panel_id => null()

    integer(kind=i_def) :: mesh_id

    if ( subroutine_timers ) call timer("set_wind")

    call u%copy_field_properties(r_u)

    mesh_id = u%get_mesh_id()

    qr = quadrature_xyoz_type(3, quadrature_rule)
    chi_sph  => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)
    call invoke( setval_c( u,   0.0_r_def ),      &
                 setval_c( r_u, 0.0_r_def ),      &
                 map_u_kernel_type( r_u, u_lon, u_lat, u_up, &
                                    chi_sph, panel_id, qr ), &
                 enforce_bc_kernel_type( r_u ) )
    call mass_matrix_solver_alg(u, r_u)

    if ( subroutine_timers ) call timer("set_wind")

  end subroutine set_wind

  !> @param[in,out] exner Exner pressure
  !> @param[in] theta     Theta
  !> @param[in] rho       Dry density
  !> @param[in] u         Wind
  !> @param[in] moist_dyn Moisture arrays for dynamics
  subroutine hydrostatic_balance(exner, rho, theta, u, moist_dyn)

    use hydrostatic_eos_exner_kernel_mod,  only : hydrostatic_eos_exner_kernel_type
    use hydrostatic_coriolis_kernel_mod,   only : hydrostatic_coriolis_kernel_type
    use moist_dyn_mod,                     only : num_moist_factors
    use matrix_vector_kernel_mod,          only : matrix_vector_kernel_type
    use convert_hdiv_field_kernel_mod,     only : convert_hdiv_field_kernel_type
    use nodal_xyz_coordinates_kernel_mod,  only : nodal_xyz_coordinates_kernel_type
    use psykal_builtin_light_mod,          only : invoke_convert_cart2sphere_vector
    use mass_matrix_solver_alg_mod,        only : mass_matrix_solver_alg

    implicit none

    type( field_type ), intent( inout ) :: exner
    type( field_type ), intent( in )    :: theta, rho, u
    type( field_type ), intent( in )    :: moist_dyn(num_moist_factors)

    type(field_type)               :: c_terms(3)
    type(field_type)               :: physical_chi(3)
    type(field_type )              :: coriolis_term, r_c
    type(field_type),      pointer :: w2_rmultiplicity => null()
    type(field_type),      pointer :: chi_xyz(:) => null()
    type(field_type),      pointer :: chi_sph(:) => null()
    type(field_type),      pointer :: panel_id => null()
    type(field_type),      pointer :: height_w3 => null()
    type(operator_type),   pointer :: coriolis => null()
    integer(i_def)                 :: i, mesh_id

    mesh_id = exner%get_mesh_id()

    height_w3 => get_height(W3, mesh_id)

    if (hydro_coriolis) then

      chi_xyz          => get_coordinates_xyz(mesh_id)
      chi_sph          => get_coordinates(mesh_id)
      panel_id         => get_panel_id(mesh_id)
      coriolis         => get_coriolis()
      w2_rmultiplicity => get_rmultiplicity( W2, mesh_id )

      ! Create intermediate fields.
      do i = 1,3
        call u%copy_field_properties(c_terms(i))
        call u%copy_field_properties(physical_chi(i))
        call invoke( setval_c(c_terms(i), 0.0_r_def) )
      end do
      call coriolis_term%initialise( vector_space=u%get_function_space() )
      call r_c%initialise( vector_space=u%get_function_space() )

      ! Apply Coriolis mass matrix.
      call invoke( setval_c(r_c, 0.0_r_def) )
      call invoke( matrix_vector_kernel_type( r_c, u, coriolis ) )

      ! Calculate Coriolis values.
      call invoke( setval_c( coriolis_term, 0.0_r_def ),      &
                   enforce_bc_kernel_type( r_c ) )
      call mass_matrix_solver_alg(coriolis_term, r_c)

      ! Convert Coriolis term to 3 components (XYZ) in physical space.
      call invoke( convert_hdiv_field_kernel_type( c_terms, coriolis_term, &
                                                   chi_sph, panel_id ) )

      do i = 1,3
        call invoke( inc_X_times_Y(c_terms(i), w2_rmultiplicity) )
      end do

      ! Convert coordinate field to physical space, i.e. to chi at W2 nodes.
      call invoke( nodal_xyz_coordinates_kernel_type(physical_chi, chi_sph, panel_id) )

      ! Convert to standard SI units (m/s) in spherical coordinates.
      if ( geometry == geometry_spherical ) then
        call invoke_convert_cart2sphere_vector(c_terms, physical_chi)
      end if

      ! Initialize working up from theta distro and hydrostatic balance
      ! with Coriolis terms.
      call invoke( hydrostatic_coriolis_kernel_type( exner, rho, theta, &
                                                     c_terms(3),        &
                                                     moist_dyn, height_w3 ) )

    else

      ! Initialize working up from theta distro and hydrostatic balance.
      call invoke( hydrostatic_eos_exner_kernel_type( exner, rho, theta, &
                                                      moist_dyn, height_w3 ) )
    end if

  end subroutine hydrostatic_balance

end module map_fd_to_prognostics_alg_mod
