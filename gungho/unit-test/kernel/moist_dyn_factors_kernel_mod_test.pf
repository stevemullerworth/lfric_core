!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the pressure gradient computation
!>
module moist_dyn_factors_kernel_mod_test

  use constants_mod,                 only: i_def, r_def
  use pFUnit_Mod
  use yaxt,                          only: xt_initialize, xt_finalize
  use mpi_mod,                       only: store_comm, clear_comm

  implicit none

  private
  public :: moist_dyn_factors_test_type, test_all

  @TestCase
  type, extends(MPITestCase) :: moist_dyn_factors_test_type
    private
    integer(i_def), allocatable         :: map_wtheta(:)
    real(r_def), allocatable            :: mr(:,:)
    real(r_def), allocatable            :: moist_dyn(:,:)
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type moist_dyn_factors_test_type

  real(r_def), parameter :: gravity  = 10.0_r_def
  real(r_def), parameter :: radius   = 6000000_r_def
  real(r_def), parameter :: omega    = 8.0E-5_r_def
  real(r_def), parameter :: p_zero   = 100000.0_r_def
  real(r_def), parameter :: rd       = 300.0_r_def
  real(r_def), parameter :: cp       = 1000.0_r_def
  real(r_def), parameter :: scaling  = 1.0_r_def

  integer(i_def), parameter :: nummr = 6
  integer(i_def), parameter :: num_moist_factors = 3
  integer(i_def), parameter :: nlayers = 5
  integer(i_def), parameter :: ndf_wtheta = 2
  integer(i_def), parameter :: undf_wtheta = nlayers * ndf_wtheta

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use feign_config_mod,        only: feign_planet_config

    implicit none

    class(moist_dyn_factors_test_type), intent(inout) :: this

    integer(i_def) :: i

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())

    ! Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    ! Ratio of water/dry air molecular weights read from namelist
    call feign_planet_config(gravity = gravity,        &
                             radius = radius,          &
                             omega = omega,            &
                             rd = rd,                  &
                             cp=cp,                    &
                             p_zero = p_zero,          &
                             scaling_factor = scaling )

    allocate(this%map_wtheta(ndf_wtheta))
    allocate(this%mr(undf_wtheta, nummr))
    allocate(this%moist_dyn(undf_wtheta, num_moist_factors))

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(moist_dyn_factors_test_type), intent(inout) :: this

    deallocate(this%map_wtheta)
    deallocate(this%mr)
    deallocate(this%moist_dyn)

    ! Finalise YAXT
    call xt_finalize()

    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[1] )
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env, only : real64
    use moist_dyn_factors_kernel_mod,  only : moist_dyn_factors_code

    implicit none

    class(moist_dyn_factors_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-9_r_def   ! r_def 64bit
    real(r_def)            :: answer, use_tol

    integer(i_def)         :: i, k, df
    real(r_def)            :: z_factor
    real(r_def), parameter :: epsilon = 0.65004008580529138_r_def

    ! Single column with nlayers
    ! Fields are p/wise linear discontinuous functions
    this%map_wtheta = (/ 1_i_def, 1_i_def + nlayers /)

    ! Create the data
    do k = 0, nlayers - 1
      do df = 1, ndf_wtheta
        z_factor = 1.0_r_def - real(k + df - 1_i_def, kind = r_def) /   &
                               real(nlayers, kind = r_def)
        do i = 1, nummr
          this%mr(this%map_wtheta(df) + k, i) = 0.01_r_def * z_factor / &
                                                real(i, kind = r_def)
        end do
      end do
    end do

    ! Test kernel
    call moist_dyn_factors_code(nlayers,                      &
                                this%moist_dyn(:,1),          &
                                this%moist_dyn(:,2),          &
                                this%moist_dyn(:,3),          &
                                this%mr(:,1),                 &
                                this%mr(:,2),                 &
                                this%mr(:,3),                 &
                                this%mr(:,4),                 &
                                this%mr(:,5),                 &
                                this%mr(:,6),                 &
                                1.0_r_def/epsilon,            &
                                ndf_wtheta, undf_wtheta,      &
                                this%map_wtheta )

    ! Check continuity at internal cell boundaries
    do k = 1, nlayers - 1
      do i = 1, num_moist_factors
        answer =  this%moist_dyn(this%map_wtheta(2) + k - 1, i)
        @assertEqual(this%moist_dyn(this%map_wtheta(1) + k, i), answer, tol)
      end do
    end do

    ! Check gas law factor
    do k = 1, nlayers - 1
      do df = 1, ndf_wtheta
        z_factor = 1.0_r_def - real(k + df - 1_i_def, kind = r_def) / &
                               real(nlayers, kind = r_def)
        answer = 1.0_r_def + 0.01_r_def * z_factor / epsilon
        @assertEqual(this%moist_dyn(this%map_wtheta(df) + k, 1), answer, tol)
      end do
    end do

    ! Check total mass factor
    ! For r_def 64bit
    do k = 1, nlayers - 1
      do df = 1, ndf_wtheta
        z_factor = 1.0_r_def - real(k + df - 1_i_def, kind = r_def) / &
                               real(nlayers, kind = r_def)
        answer = 0.0_r_def
        do i = 1, nummr
          answer = answer + 1.0_r_def / real(i, kind = r_def)
        end do
        answer = 1.0_r_def + 0.01_r_def * z_factor * answer
        if ( r_def == real64 ) then
          use_tol = tol
        else
          use_tol = 10.0_r_def * spacing( answer )
        end if
        @assertEqual( this%moist_dyn( this%map_wtheta(df) + k, 2 ), answer, use_tol )
      end do
    end do

    ! Check water factor (1.0 for ENDGame-style moist dynamics)
    do k = 0, nlayers - 1
      do df = 1, ndf_wtheta
        @assertEqual(this%moist_dyn(this%map_wtheta(df) + k, 3), 1.0_r_def, tol)
      end do
    end do

  end subroutine test_all

end module moist_dyn_factors_kernel_mod_test
