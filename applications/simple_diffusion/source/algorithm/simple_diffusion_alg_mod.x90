!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Module containing simple_diffusion_alg
module simple_diffusion_alg_mod

  use constants_mod,                       only: i_def, r_def
  use driver_modeldb_mod,                  only: modeldb_type
  use log_mod,                             only: log_event,         &
                                                 LOG_LEVEL_INFO,    &
                                                 LOG_LEVEL_TRACE
  use mesh_mod,                            only: mesh_type
  use field_mod,                           only: field_type
  use fs_continuity_mod,                   only: Wtheta, W2
  use function_space_collection_mod,       only: function_space_collection
  use function_space_mod,                  only: function_space_type
  use operator_mod,                        only: operator_type
  use matrix_vector_kernel_mod,            only: matrix_vector_kernel_type
  use simple_diffusion_constants_mod,      only: get_dx_at_w2
  use tracer_tutorial_diff_kernel_mod,     only: tracer_tutorial_diff_kernel_type
  use sci_field_minmax_alg_mod,            only: log_field_minmax

  implicit none

  private

  public :: simple_diffusion_alg

contains

  !> @details Calculates the diffusion increment for a field, and adds it to said field.
  !> @param[in]    modeldb   Application state object
  !> @param[inout] field_in  Input Wtheta field
  subroutine simple_diffusion_alg( modeldb, field_in )

    implicit none

    type(modeldb_type), intent( in ) :: modeldb

    ! Prognostic fields
    type( field_type ), intent( inout ) :: field_in

    ! Diagnostic fields
    type( field_type )                  :: dfield_in
    type( field_type )                  :: visc

    real(r_def), parameter              :: visc_val = 100000.0_r_def
    type(mesh_type), pointer            :: mesh
    integer(kind=i_def), parameter      :: stencil_depth = 1_i_def
    type( field_type ), pointer         :: dx_at_w2

    type(function_space_type), pointer :: fs

    integer(i_def) :: order_h, order_v

    call log_event( "simple_diffusion: Running algorithm", LOG_LEVEL_TRACE )

    nullify(dx_at_w2)
    nullify(mesh)

    order_h = modeldb%config%finite_element%element_order_h()
    order_v = modeldb%config%finite_element%element_order_v()

    mesh     => field_in%get_mesh()
    dx_at_w2 => get_dx_at_w2(mesh)

    fs => function_space_collection%get_fs(mesh, order_h, order_v, Wtheta)

    call dfield_in%initialise(fs)
    call visc%initialise(fs)

    call invoke( name = "compute_diffusion", &
                 setval_c(visc, visc_val), &
                 setval_c(dfield_in, 0.0_r_def), &
                 tracer_tutorial_diff_kernel_type(dfield_in, &
                                                  field_in, &
                                                  stencil_depth, &
                                                  visc, &
                                                  dx_at_w2) )

    ! Printing the min/max values in field_in and dfield_in
    call log_field_minmax( LOG_LEVEL_INFO, 'dfield_in', dfield_in )
    call log_field_minmax( LOG_LEVEL_INFO, 'field_in', field_in )

    ! Incrementing field
    call invoke( inc_X_plus_Y( field_in, dfield_in ) )

    nullify(mesh)

    call log_event( "simple_diffusion: finished algorithm", LOG_LEVEL_TRACE )

  end subroutine simple_diffusion_alg

end module simple_diffusion_alg_mod
