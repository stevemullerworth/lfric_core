!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the key-value pair collection object
!>
module key_value_collection_mod_test

    use, intrinsic :: iso_fortran_env, &
                       only : int64, int32, real64, real32

    use constants_mod, only : i_def, r_def, l_def, &
                              str_longlong, str_def
    use key_value_collection_mod, &
                       only : key_value_collection_type
    use key_value_mod, only: int32_key_value_type,       &
                             int64_key_value_type,       &
                             int32_arr_key_value_type,   &
                             int64_arr_key_value_type,   &
                             real32_key_value_type,      &
                             real64_key_value_type,      &
                             real32_arr_key_value_type,  &
                             real64_arr_key_value_type,  &
                             logical_key_value_type,     &
                             str_key_value_type,         &
                             logical_arr_key_value_type, &
                             str_arr_key_value_type,     &
                             abstract_key_value_type,    &
                             abstract_value_type
    use funit

  implicit none

  private

  type, extends(abstract_value_type) :: test_type
    integer, public :: int_number
  contains
  end type test_type

  public :: test_all

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test
  subroutine test_all()

    implicit none

    type(key_value_collection_type) :: key_value_collection

    type(int32_key_value_type)       :: int32_key_value
    type(int64_key_value_type)       :: int64_key_value
    type(real32_key_value_type)      :: real32_key_value
    type(real64_key_value_type)      :: real64_key_value
    type(logical_key_value_type)     :: logical_key_value
    type(str_key_value_type)         :: string_key_value
    type(int32_arr_key_value_type)   :: int32_arr_key_value
    type(int64_arr_key_value_type)   :: int64_arr_key_value
    type(real32_arr_key_value_type)  :: real32_arr_key_value
    type(real64_arr_key_value_type)  :: real64_arr_key_value
    type(logical_arr_key_value_type) :: logical_arr_key_value
    type(str_arr_key_value_type)     :: string_arr_key_value
    type(abstract_key_value_type)    :: abstract_key_value

    integer(int32),             pointer :: int32_val
    integer(int64),             pointer :: int64_val
    real(real32),               pointer :: real32_val
    real(real64),               pointer :: real64_val, real64_val2
    logical,                    pointer :: logical_val
    character(str_longlong),    pointer :: string_val
    integer(int32),             pointer :: int32_arr_val(:)
    integer(int64),             pointer :: int64_arr_val(:)
    real(real32),               pointer :: real32_arr_val(:)
    real(real64),               pointer :: real64_arr_val(:)
    logical,                    pointer :: logical_arr_val(:)
    character(str_def),         pointer :: string_arr_val(:)
    class(abstract_value_type), pointer :: abstract_val

    type(test_type) :: test_object
    integer(i_def) :: length, table_length
    logical(l_def) :: exists
    character(str_longlong) :: name_str
    real(r_def), parameter :: tol = 1.0e-6_r_def

    !Create a key-value pair collection
    call key_value_collection%initialise(name = "key_value_collection", &
                                         table_len=4)

    !Check the name is as expected
    name_str = key_value_collection%get_name()
    @assertEqual("key_value_collection", name_str)

    !Check the table length is as expected
    table_length = key_value_collection%get_table_len()
    @assertEqual(4_i_def, table_length)

    ! Initialise an object that inherits from the abstract key_value_type
    test_object%int_number = 17

    !Add all different types of key-value pair to a single collection
    call int32_key_value%initialise("key_for_int32", 320_int32)
    call key_value_collection%add_key_value(int32_key_value)
    call int64_key_value%initialise("key_for_int64", 640_int64)
    call key_value_collection%add_key_value(int64_key_value)
    call real32_key_value%initialise("key_for_real32", 3200.0_real32)
    call key_value_collection%add_key_value(real32_key_value)
    call real64_key_value%initialise("key_for_real64", 6400.0_real64)
    call key_value_collection%add_key_value(real64_key_value)
    call logical_key_value%initialise("key_for_logical", .true.)
    call key_value_collection%add_key_value(logical_key_value)
    call string_key_value%initialise("key_for_string", "test_string")
    call key_value_collection%add_key_value(string_key_value)
    call int32_arr_key_value%initialise("key_for_int32_arr", [1_int32, 2_int32, 3_int32, 4_int32, 5_int32])
    call key_value_collection%add_key_value(int32_arr_key_value)
    call int64_arr_key_value%initialise("key_for_int64_arr", [9_int64, 8_int64, 7_int64, 6_int64])
    call key_value_collection%add_key_value(int64_arr_key_value)
    call real32_arr_key_value%initialise("key_for_real32_arr", [0.1_real32, 0.2_real32])
    call key_value_collection%add_key_value(real32_arr_key_value)
    call real64_arr_key_value%initialise("key_for_real64_arr", [99.9_real64, 99.8_real64, 99.7_real64])
    call key_value_collection%add_key_value(real64_arr_key_value)
    call logical_arr_key_value%initialise("key_for_logical_arr", [.true., .false., .true.])
    call key_value_collection%add_key_value(logical_arr_key_value)
    call string_arr_key_value%initialise("key_for_string_arr", ["one", "two"])
    call key_value_collection%add_key_value(string_arr_key_value)
    call abstract_key_value%initialise("key_for_abstract_obj", test_object )
    call key_value_collection%add_key_value(abstract_key_value)

    ! Extract the value of all keys and check they're correct
    call key_value_collection%get_value("key_for_int32", int32_val)
    @assertEqual(320_int32, int32_val)
    call key_value_collection%get_value("key_for_int64", int64_val)
    @assertEqual(640_int64, int64_val)
    call key_value_collection%get_value("key_for_real32", real32_val)
    @assertEqual(3200.0_real32, real32_val, real(tol, real32))
    call key_value_collection%get_value("key_for_real64", real64_val)
    @assertEqual(6400.0_real64, real64_val, real(tol, real64))
    call key_value_collection%get_value("key_for_logical", logical_val)
    @assertTrue(logical_val)
    call key_value_collection%get_value("key_for_string", string_val)
    @assertEqual("test_string", trim(string_val))
    call key_value_collection%get_value("key_for_int32_arr", int32_arr_val)
    @assertEqual([1_int32, 2_int32, 3_int32, 4_int32, 5_int32], int32_arr_val)
    call key_value_collection%get_value("key_for_int64_arr", int64_arr_val)
    @assertEqual([9_int64, 8_int64, 7_int64, 6_int64], int64_arr_val)
    call key_value_collection%get_value("key_for_real32_arr", real32_arr_val)
    @assertEqual([0.1_real32, 0.2_real32], real32_arr_val)
    call key_value_collection%get_value("key_for_real64_arr", real64_arr_val)
    @assertEqual([99.9_real64, 99.8_real64, 99.7_real64], real64_arr_val)
    !No assertEqual for arrays of logicals or strings, so test each element
    call key_value_collection%get_value("key_for_logical_arr", logical_arr_val)
    @assertTrue(logical_arr_val(1))
    @assertFalse(logical_arr_val(2))
    @assertTrue(logical_arr_val(3))
    @assertEqual(3, size(logical_arr_val))
    call key_value_collection%get_value("key_for_string_arr", string_arr_val)
    @assertEqual("one", string_arr_val(1))
    @assertEqual("two", string_arr_val(2))
    @assertEqual(2, size(string_arr_val))
    call key_value_collection%get_value("key_for_abstract_obj", abstract_val)
    select type(abstract_val)
      type is (test_type)
      @assertEqual( 17, abstract_val%int_number )
    end select

    !Change a value locally, and check the value in the collection is updated
    real64_val = 12800.0_real64
    call key_value_collection%get_value("key_for_real64", real64_val2)
    @assertEqual(12800.0_real64, real64_val2, real(tol, real64))

    !Check length of table
    length = key_value_collection%get_length()
    @assertEqual(13_i_def, length)

    !Remove an item from the collection, check it's gone and check length again
    exists = key_value_collection%key_value_exists("key_for_int32")
    @assertTrue(exists)
    call key_value_collection%remove_key_value("key_for_int32")
    exists = key_value_collection%key_value_exists("key_for_int32")
    @assertFalse(exists)
    length = key_value_collection%get_length()
    @assertEqual(12_i_def, length)

    !Tidy up collection to prevent data bleeding into other tests
    call key_value_collection%clear()

  end subroutine test_all

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

end module key_value_collection_mod_test
