!-----------------------------------------------------------------------------
! (c) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief An algorithm for calculating departure points used by Cosmic transport.
!> @details The algorithm calculates the departure points for the cell edges.
!>          The departure points are calculated in the x, y and z direction
!>          separately as 1D calculations.
!>          This is used by the dimensionally-split swept-area approach of
!>          Cosmic.
module calc_dep_pts_alg_mod

  use constants_mod,                     only: LARGE_REAL_NEGATIVE, i_def, r_def
  use io_config_mod,                     only: subroutine_timers
  use timer_mod,                         only: timer
  use field_mod,                         only: field_type
  use calc_departure_wind_kernel_mod,    only: calc_departure_wind_kernel_type
  use vertical_trapezoidal_kernel_mod,   only: vertical_trapezoidal_kernel_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use fs_continuity_mod,                 only: W3
  use finite_element_config_mod,         only: element_order
  use flux_direction_mod,                only: x_direction, y_direction, z_direction
  use biperiodic_deppt_config_mod,       only: method, n_dep_pt_iterations
  use subgrid_config_mod,                only: dep_pt_stencil_extent
  use psykal_lite_mod,                   only: invoke_calc_deppts,             &
                                               invoke_extract_xy,              &
                                               invoke_cosmic_departure_wind,   &
                                               invoke_correct_cosmic_wind
  use geometric_constants_mod,           only: get_coordinates,                &
                                               get_panel_id
  use log_mod,                           only: log_event,                      &
                                               log_scratch_space,              &
                                               LOG_LEVEL_INFO
  use cosmic_divergence_alg_mod,         only: cosmic_divergence_alg

  implicit none

  private
  public :: calc_dep_pts

contains

  !> @param[in,out] dep_pts_x         Departure points in x direction
  !> @param[in,out] dep_pts_y         Departure points in y direction
  !> @param[in,out] dep_pts_z         Departure points in z direction
  !> @param[in,out] wind_divergence   Divergence of wind field
  !> @param[in]     wind_n            Wind field at timestep n
  !> @param[in]     wind_np1          Wind field at timestep n+1
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     cell_orientation  Orientation of halo cells
  !> @param[in]     dt                The model timestep length
  subroutine calc_dep_pts( dep_pts_x,        &
                           dep_pts_y,        &
                           dep_pts_z,        &
                           wind_divergence,  &
                           wind_n,           &
                           wind_np1,         &
                           detj_at_w2,       &
                           cell_orientation, &
                           dt )

    implicit none

    type( field_type ), intent(inout) :: dep_pts_x
    type( field_type ), intent(inout) :: dep_pts_y
    type( field_type ), intent(inout) :: dep_pts_z
    type( field_type ), intent(inout) :: wind_divergence
    type( field_type ), intent(in)    :: wind_n
    type( field_type ), intent(in)    :: wind_np1
    type( field_type ), intent(in)    :: detj_at_w2
    type( field_type ), intent(in)    :: cell_orientation
    real( kind=r_def ), intent(in)    :: dt

    type( field_type ) :: u_x_fem_n, u_y_fem_n, u_x_fem_np1, u_y_fem_np1
    type( field_type ) :: dep_wind_x_n, dep_wind_y_n
    type( field_type ) :: dep_wind_x_np1, dep_wind_y_np1
    type( field_type ) :: departure_wind_n, departure_wind_np1
    type( field_type ) :: corrected_dep_wind_x_n, corrected_dep_wind_y_n
    type( field_type ) :: corrected_dep_wind_x_np1, corrected_dep_wind_y_np1
    type( field_type ) :: divergence_x, divergence_y, divergence_z

    type( field_type ), pointer :: chi_sph(:) => null()
    type( field_type ), pointer :: panel_id => null()

    type( function_space_type ), pointer :: w2_fs => null()
    type( function_space_type ), pointer :: w3_fs => null()

    integer(i_def) ::  mesh_id

    w2_fs => dep_pts_x%get_function_space()
    mesh_id = wind_n%get_mesh_id()
    w3_fs   => function_space_collection%get_fs( mesh_id, element_order, W3 )

    chi_sph => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)

    call u_x_fem_n%initialise( vector_space = w2_fs )
    call u_y_fem_n%initialise( vector_space = w2_fs )
    call u_x_fem_np1%initialise( vector_space = w2_fs )
    call u_y_fem_np1%initialise( vector_space = w2_fs )
    call dep_wind_x_n%initialise( vector_space = w2_fs )
    call dep_wind_y_n%initialise( vector_space = w2_fs )
    call dep_wind_x_np1%initialise( vector_space = w2_fs )
    call dep_wind_y_np1%initialise( vector_space = w2_fs )
    call departure_wind_n%initialise( vector_space = w2_fs )
    call departure_wind_np1%initialise( vector_space = w2_fs )
    call corrected_dep_wind_x_n%initialise( vector_space = w2_fs )
    call corrected_dep_wind_y_n%initialise( vector_space = w2_fs )
    call corrected_dep_wind_x_np1%initialise( vector_space = w2_fs )
    call corrected_dep_wind_y_np1%initialise( vector_space = w2_fs )

    call divergence_x%initialise( vector_space = w3_fs )
    call divergence_y%initialise( vector_space = w3_fs )
    call divergence_z%initialise( vector_space = w3_fs )

    if ( subroutine_timers ) call timer( 'calc_dep_pts' )

    ! Calculate vertical departure points and departure winds.
    ! Currently the trapezoidal method has been choosen for calculating departure
    ! points in the vertical.
    ! *_n and *_np1 denotes fields at timestep n and timestep n+1 with density known
    ! at timestep n.
    call invoke( setval_c( dep_pts_x, LARGE_REAL_NEGATIVE ),                    &
                 setval_c( dep_pts_y, LARGE_REAL_NEGATIVE ),                    &
                 setval_c( dep_pts_z, LARGE_REAL_NEGATIVE ),                    &
                 setval_c( departure_wind_n, LARGE_REAL_NEGATIVE ),             &
                 setval_c( departure_wind_np1, LARGE_REAL_NEGATIVE ),           &
                 setval_c( u_x_fem_n, LARGE_REAL_NEGATIVE ),                    &
                 setval_c( u_y_fem_n, LARGE_REAL_NEGATIVE ),                    &
                 setval_c( u_x_fem_np1, LARGE_REAL_NEGATIVE ),                  &
                 setval_c( u_y_fem_np1, LARGE_REAL_NEGATIVE ),                  &
                 calc_departure_wind_kernel_type( departure_wind_n, wind_n,     &
                                                  chi_sph, panel_id ),          &
                 calc_departure_wind_kernel_type( departure_wind_np1, wind_np1, &
                                                  chi_sph, panel_id ),          &
                 vertical_trapezoidal_kernel_type( dep_pts_z,                   &
                                                   departure_wind_n,            &
                                                   departure_wind_np1,          &
                                                   n_dep_pt_iterations, dt )  )

    ! Calculate horizontal departure points.

    ! Separate finite-element wind field into x and y directional components.
    call invoke_extract_xy( u_x_fem_n, u_y_fem_n, wind_n, cell_orientation )
    call invoke_extract_xy( u_x_fem_np1, u_y_fem_np1, wind_np1, cell_orientation )

    ! Divide the Piola wind coefficients, u_x_fem and u_y_fem, by detj at the W2 dofs.
    ! Returning wind coefficients, dep_wind_x and dep_wind_y, which have dimension 1/T.
    ! dep_wind_x and dep_wind_y have no length associated with them since we solve
    ! for departure points on a rescaled mesh which is dimensionless where the
    ! distance between cell edges is length 1.0.
    call invoke_cosmic_departure_wind( dep_wind_x_n, dep_wind_y_n, u_x_fem_n, u_y_fem_n, detj_at_w2, x_direction )
    call invoke_cosmic_departure_wind( dep_wind_x_n, dep_wind_y_n, u_x_fem_n, u_y_fem_n, detj_at_w2, y_direction )
    call invoke_cosmic_departure_wind( dep_wind_x_np1, dep_wind_y_np1, u_x_fem_np1, u_y_fem_np1, detj_at_w2, x_direction )
    call invoke_cosmic_departure_wind( dep_wind_x_np1, dep_wind_y_np1, u_x_fem_np1, u_y_fem_np1, detj_at_w2, y_direction )

    ! For Cosmic if the wind value is assumed positive in the x or y direction then it moves mass in the positive x or
    ! y direction. Note that Cosmic locally defines an x or y direction on each panel of the cubed sphere.
    ! The basis function in the y direction actually points in the negative direction.
    ! Therefore a negative Piola wind coefficient means that the wind is in the positive y direction.
    ! The following code corrects the wind coefficient values so that the wind has the correct sign in the x and y direction.
    call invoke_correct_cosmic_wind( corrected_dep_wind_x_n, corrected_dep_wind_y_n,                &
                                     dep_wind_x_n, dep_wind_y_n, cell_orientation, x_direction )
    call invoke_correct_cosmic_wind( corrected_dep_wind_x_n, corrected_dep_wind_y_n,                &
                                     dep_wind_x_n, dep_wind_y_n, cell_orientation, y_direction )
    call invoke_correct_cosmic_wind( corrected_dep_wind_x_np1, corrected_dep_wind_y_np1,            &
                                     dep_wind_x_np1, dep_wind_y_np1, cell_orientation, x_direction )
    call invoke_correct_cosmic_wind( corrected_dep_wind_x_np1, corrected_dep_wind_y_np1,            &
                                     dep_wind_x_np1, dep_wind_y_np1, cell_orientation, y_direction )

    ! The departure points are calculated at cell edge values.
    ! The code assumes lowest order W2 nodal points, i.e. one W2 dof per cell edge.
    call invoke_calc_deppts( corrected_dep_wind_x_n, corrected_dep_wind_x_np1, dep_pts_x,   &
                             cell_orientation, x_direction, method, dep_pt_stencil_extent )
    call invoke_calc_deppts( corrected_dep_wind_y_n, corrected_dep_wind_y_np1, dep_pts_y,   &
                             cell_orientation, y_direction, method, dep_pt_stencil_extent )

    ! Calculate the divergence of the wind field used in Cosmic.
    call cosmic_divergence_alg( divergence_x, corrected_dep_wind_x_n, detj_at_w2, &
                                cell_orientation, x_direction )

    call cosmic_divergence_alg( divergence_y, corrected_dep_wind_y_n, detj_at_w2, &
                                cell_orientation, y_direction )

    call cosmic_divergence_alg( divergence_z, departure_wind_n, detj_at_w2, &
                                cell_orientation, z_direction )

    call invoke( X_plus_Y(wind_divergence, divergence_x, divergence_y),     &
                 inc_X_plus_Y( wind_divergence, divergence_z) )

    call departure_wind_n%log_minmax( LOG_LEVEL_INFO, 'departure_wind_n' )
    call departure_wind_np1%log_minmax( LOG_LEVEL_INFO, 'departure_wind_np1' )
    call dep_pts_x%log_minmax( LOG_LEVEL_INFO, 'dep_pts_x' )
    call dep_pts_y%log_minmax( LOG_LEVEL_INFO, 'dep_pts_y' )
    call dep_pts_z%log_minmax( LOG_LEVEL_INFO, 'dep_pts_z' )

    nullify( w2_fs )

    if ( subroutine_timers ) call timer( 'calc_dep_pts' )

  end subroutine calc_dep_pts

end module calc_dep_pts_alg_mod
