!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the impose_min_flux_kernel_mod
!>
module impose_min_flux_kernel_mod_test


  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  use yaxt,          only : xt_initialize, xt_finalize
  use mpi_mod,       only : store_comm, clear_comm

  use log_mod,       only : log_event,           &
                            log_scratch_space,   &
                            LOG_LEVEL_INFO

  implicit none

  private
  public :: test_all

  @TestCase
  type, public, extends(MPITestCase) :: impose_min_flux_kernel_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type impose_min_flux_kernel_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(impose_min_flux_kernel_test_type), intent(inout) :: this
    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    ! Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,  only: final_configuration

    implicit none

    class(impose_min_flux_kernel_test_type), intent(inout) :: this

    call final_configuration()

    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test( npes=[1] )
  subroutine test_all( this )

    use impose_min_flux_kernel_mod,    only: impose_min_flux_code

    implicit none

    class(impose_min_flux_kernel_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-15_r_def

    ! Mesh and Spaces
    integer(i_def), parameter :: nlayers = 4
    integer(i_def), parameter :: ndf_w3 = 1
    integer(i_def), parameter :: ndf_w2 = 6
    integer(i_def), parameter :: nfaces_h  = 4
    integer(i_def), parameter :: undf_w3 = ndf_w3*nlayers
    integer(i_def), parameter :: undf_w2 = nfaces_h*nlayers + nlayers + 1
    integer(i_def), parameter :: ncell_3d = nlayers

    ! Maps
    integer(i_def), dimension(ndf_w3)   :: map_w3
    integer(i_def), dimension(ndf_w2)   :: map_w2

    ! Operators
    real(r_def), dimension(ndf_w3,ndf_w2,ncell_3d) :: div
    real(r_def), dimension(ndf_w3,ndf_w3,ncell_3d) :: div_multiplier

    ! Fields
    real(r_def), dimension(undf_w3) :: rho
    real(r_def), dimension(undf_w2) :: flux
    real(r_def)                     :: rho_min, dts
    real(r_def), dimension(undf_w2) :: flux_answer
    real(r_def), dimension(ndf_w2)  :: flux_cell

    integer(i_def) :: i,j,k, cell
    real(r_def)    :: edge_value

    map_w3 = (/ 1_i_def /)

    do j = 1, nfaces_h
      map_w2(j) = 1_i_def + (j-1)*nlayers
    end do
    map_w2(nfaces_h+1) = 1_i_def + nfaces_h*nlayers
    map_w2(ndf_w2)     = map_w2(nfaces_h+1) + 1_i_def
    map_w3(:) = 1_i_def

    do i = 1, ndf_w3
       do j = 1, ndf_w2
           edge_value = +1.0_r_def
           if ( mod(j,2) == 0.0_r_def ) then
               edge_value = -1.0_r_def
           end if
           div(i,j,:) = edge_value
       end do
    end do

    do k = 0, nlayers-1
      do j = 1, ndf_w2
          edge_value = 2.0_r_def
          if ( mod(j,2) == 0.0_r_def ) then
               edge_value = 1.0_r_def
          end if
          flux(map_w2(j)+k) = edge_value
      end do
    end do

    div_multiplier(:,:,:) = 1.0_r_def
    rho(:)                = 3.0_r_def

    rho_min        = 0.0_r_def
    dts            = 1.0_r_def
    flux_answer(:) = 1.0_r_def

    ! Compute the modified fluxes

    cell = 1_i_def
    call impose_min_flux_code(cell,                    &
                              nlayers,                 &
                              rho, flux,               &
                              ncell_3d,                &
                              div,                     &
                              ncell_3d,                &
                              div_multiplier,          &
                              rho_min,                 &
                              dts,                     &
                              ndf_w3, undf_w3, map_w3, &
                              ndf_w2, undf_w2, map_w2  )

    do j = 1,undf_w2
      @assertEqual(flux_answer(j), flux(j) , tol)
    end do

  end subroutine test_all

end module impose_min_flux_kernel_mod_test

