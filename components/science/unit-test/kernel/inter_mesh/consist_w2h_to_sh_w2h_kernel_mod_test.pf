!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the kernel mapping from W2h to the shifted W2h space
!>
module consist_w2h_to_sh_w2h_kernel_mod_test

  use constants_mod,         only: i_def, r_double, r_def
  use reference_element_mod, only: E, W, N, S
  use funit


  implicit none

  private
  public :: consist_w2h_to_sh_w2h_test_type, test_all

  @TestCase
  type, extends(TestCase) :: consist_w2h_to_sh_w2h_test_type
    private
  contains

    procedure setUp
    procedure tearDown
    procedure test_all

  end type consist_w2h_to_sh_w2h_test_type

contains
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(consist_w2h_to_sh_w2h_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use config_loader_mod, only: final_configuration

    implicit none

    class(consist_w2h_to_sh_w2h_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine test_all( this )

    use sci_consist_w2h_to_sh_w2h_kernel_mod, only : consist_w2h_to_sh_w2h_code

    implicit none

    class(consist_w2h_to_sh_w2h_test_type), intent(inout) :: this

    real(kind=r_double), parameter ::  tol = 1.0e-12_r_double
    real(kind=r_double), parameter ::   dx = 5.0_r_double
    real(kind=r_double), parameter ::   dy = 4.0_r_double
    real(kind=r_double), parameter ::   u_W = 7.0_r_double
    real(kind=r_double), parameter ::   u_E = 11.0_r_double
    real(kind=r_double), parameter ::   u_N = 3.0_r_double
    real(kind=r_double), parameter ::   u_S = 4.0_r_double

    ! Fields
    real(kind=r_double), allocatable :: u_sh_field(:)
    real(kind=r_double), allocatable :: u_field(:)
    real(kind=r_double), allocatable :: answer(:)
    real(kind=r_double), allocatable :: height_wt(:)
    real(kind=r_double), allocatable :: height_wt_sh(:)
    integer(kind=i_def), allocatable :: face_selector(:)

    integer(kind=i_def) :: cell, k
    real(kind=r_double) :: dz

    ! Sizes
    integer(kind=i_def) :: nlayers, nlayers_sh, ncells
    integer(kind=i_def) :: ndf_w2h_sh, ndf_wt_sh
    integer(kind=i_def) :: ndf_w2h, ndf_wt
    integer(kind=i_def) :: undf_w2h_sh, undf_wt_sh
    integer(kind=i_def) :: undf_w2h, undf_wt
    integer(kind=i_def) :: ndf_w3_2d, undf_w3_2d

    ! Dofmaps
    integer(kind=i_def), allocatable :: map_w2h(:,:), map_w2h_sh(:,:)
    integer(kind=i_def), allocatable :: map_wt(:,:), map_wt_sh(:,:), map_w3_2d(:,:)

    ! just consider a single column of three layers
    nlayers = 3
    nlayers_sh = 4
    ndf_w2h = 4
    undf_w2h = 12
    ndf_w2h_sh = 4
    undf_w2h_sh = 16
    ndf_w3_2d = 1
    undf_w3_2d = 1
    ndf_wt = 2
    undf_wt = 4
    ndf_wt_sh = 1
    undf_wt_sh = 5
    ncells = 1
    cell = 1

    ! Create the data
    allocate( u_sh_field(undf_w2h_sh) )
    allocate( u_field(undf_w2h) )
    allocate( answer(undf_w2h_sh) )
    allocate( map_w2h_sh(ndf_w2h, ncells) )
    allocate( map_w2h(ndf_w2h, ncells) )
    allocate( map_wt_sh(ndf_wt, ncells) )
    allocate( map_wt(ndf_wt, ncells) )
    allocate( map_w3_2d(ndf_w3_2d, ncells) )
    allocate( face_selector(undf_w3_2d) )

    ! Only one cell so all maps are to first cell
    map_w2h_sh(:,:) = reshape( [1_i_def, 5_i_def, 9_i_def, 13_i_def], [4,1])
    map_wt_sh(:,:)  = reshape( [1_i_def, 2_i_def], [2,1])
    map_w2h(:,:)    = reshape( [1_i_def, 4_i_def, 7_i_def, 10_i_def], [4,1])
    map_wt(:,:)     = reshape( [1_i_def, 2_i_def], [2,1])
    map_w3_2d(:,:)  = 1_i_def

    ! Do all faces
    face_selector = 2

    ! Set up the height fields for the meshes
    ! These are used for the initial conditions but not by the kernel
    ! Let's consider a quadratic extrusion
    height_wt    = (/ 0.0_r_double, 1.0_r_double, 4.0_r_double, 9.0_r_double /)
    height_wt_sh = (/ 0.0_r_double, 0.5_r_double, 2.5_r_double, 6.5_r_double, 9.0_r_double /)

    ! Now set up initial field in w2h and the answer in shifted w2h
    ! Assume a horizontal velocity that is constant in the vertical direction
    ! Vertical velocity varies linearly
    u_field(:) = 0.0_r_double
    answer(:) = 0.0_r_double

    do k = 1, nlayers
      dz = height_wt(map_wt(2, cell)+k-1) - height_wt(map_wt(1, cell)+k-1)
      u_field(map_w2h(W, cell)+k-1) = u_W * dy * dz
      u_field(map_w2h(E, cell)+k-1) = u_E * dy * dz
      u_field(map_w2h(N, cell)+k-1) = u_N * dx * dz
      u_field(map_w2h(S, cell)+k-1) = u_S * dx * dz
    end do

    ! Set up shifted w2h fields (including the answer)
    do k = 1, nlayers_sh
      dz = height_wt_sh(map_wt_sh(2, cell)+k-1) - height_wt_sh(map_wt_sh(1, cell)+k-1)
      answer(map_w2h_sh(W, cell)+k-1) = u_W * dy * dz
      answer(map_w2h_sh(E, cell)+k-1) = u_E * dy * dz
      answer(map_w2h_sh(N, cell)+k-1) = u_N * dx * dz
      answer(map_w2h_sh(S, cell)+k-1) = u_S * dx * dz
    end do

    ! Perform kernel
    u_sh_field(:) = 0.0_r_double

    call consist_w2h_to_sh_w2h_code(  nlayers_sh,        &
                                      u_sh_field,        &
                                      u_field,           &
                                      face_selector,     &
                                      face_selector,     &
                                      ndf_w2h_sh,        &
                                      undf_w2h_sh,       &
                                      map_w2h_sh(:,1),   &
                                      ndf_w2h,           &
                                      undf_w2h,          &
                                      map_w2h(:,1),      &
                                      ndf_w3_2d,         &
                                      undf_w3_2d,        &
                                      map_w3_2d(:,1)     &
                                    )

    @assertEqual(answer(:), u_sh_field(:), tol)

    deallocate( u_sh_field )
    deallocate( u_field )
    deallocate( answer )
    deallocate( face_selector )
    deallocate( map_w3_2d )
    deallocate( map_w2h_sh )
    deallocate( map_w2h )
    deallocate( map_wt_sh )
    deallocate( map_wt )

  end subroutine test_all

end module consist_w2h_to_sh_w2h_kernel_mod_test
