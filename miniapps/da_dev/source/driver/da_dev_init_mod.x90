!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Initialisation functionality for the da_dev miniapp

!> @details Handles init of prognostic fields and through the call to
!>          runtime_contants the coordinate fields and fem operators

module da_dev_init_mod

  use constants_mod,                  only : r_def, i_native
  use driver_model_data_mod,          only : model_data_type
  use field_mod,                      only : field_type
  use field_parent_mod,               only : write_interface, &
                                             read_interface
  use finite_element_config_mod,      only : element_order
  use function_space_collection_mod,  only : function_space_collection
  use fs_continuity_mod,              only : W2, W3, Wtheta
  use log_mod,                        only : log_event,      &
                                             LOG_LEVEL_INFO
  use mesh_mod,                       only : mesh_type
  use lfric_xios_read_mod,            only : read_field_face, &
                                             read_field_edge
  use lfric_xios_write_mod,           only : write_field_face, &
                                             write_field_edge

  implicit none

  contains

  !> @brief  Initialise the da_dev miniapp
  !>
  !> @param[in] mesh        Mesh to use for field initialisation
  !> @param[in] model_data  model_data to store miniapp fields in
  subroutine init_da_dev( mesh, model_data)

    implicit none

    type(mesh_type), intent(in), pointer        :: mesh
    type( model_data_type ), intent(inout)      :: model_data

    call log_event( 'da_dev: Initialising miniapp ...', LOG_LEVEL_INFO )

    call model_data%depository%initialise(name = 'depository', table_len=100)

    ! Create fields and add them to model_data
    call add_real_field( model_data, mesh, Wtheta, "theta" )
    call add_real_field( model_data, mesh, W3,     "rho"   )
    call add_real_field( model_data, mesh, W3,     "exner" )

    call log_event( 'da_dev: Miniapp initialised', LOG_LEVEL_INFO )

  end subroutine init_da_dev

  !> @brief  Create and add a real-valued field to the model_data
  !>
  !> @param[in] model_data  The model data object to add a field to
  !> @param[in] mesh        The mesh to build the field on
  !> @param[in] fs          The function space to build the field on
  !> @param[in] field_name  The name of the new field
  subroutine add_real_field(model_data, mesh, fs, field_name)
    implicit none

    type(model_data_type), intent(inout)  :: model_data
    type(mesh_type), intent(in), pointer  :: mesh
    integer(i_native), intent(in)         :: fs
    character(*), intent(in)              :: field_name

    type(field_type), allocatable :: field
    procedure(read_interface), pointer    :: tmp_read_ptr
    procedure(write_interface), pointer   :: tmp_write_ptr

    allocate(field)

    call field%initialise( &
      vector_space = function_space_collection%get_fs(mesh, element_order, fs), &
      name = field_name )

    if (fs == W2) then
      tmp_read_ptr => read_field_edge
      tmp_write_ptr => write_field_edge
    else
      tmp_read_ptr => read_field_face
      tmp_write_ptr => write_field_face
    end if

    call field%set_read_behaviour(tmp_read_ptr)

    call field%set_write_behaviour(tmp_write_ptr)

    call invoke(setval_c(field, 0.0_r_def))

    call model_data%depository%add_field( field )

  end subroutine add_real_field

end module da_dev_init_mod
