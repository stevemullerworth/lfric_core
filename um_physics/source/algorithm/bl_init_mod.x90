!----------------------------------------------------------------------------
! (c) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!----------------------------------------------------------------------------
!> @brief initialisation of things needed by BL scheme

module bl_init_mod

  use constants_mod,         only: i_um, r_def, i_def
  use field_collection_mod,  only: field_collection_type
  use physics_config_mod,    only: cloud_scheme,               &
                                   physics_cloud_scheme_none,  &
                                   physics_cloud_scheme_smith, &
                                   rhcritical
  use log_mod,               only: log_event,         &
                                   log_scratch_space, &
                                   LOG_LEVEL_ERROR
  implicit none

contains

  !>@brief Initialize the UM Boundary Layer scheme
  !>@param[in]    theta_in_wth Theta in its native space
  !>@param[in,out] twod_fields Group of 2D fields
  subroutine bl_init(theta_in_wth, twod_fields)

    ! UM modules
    use allocate_jules_arrays_mod, only: allocate_jules_arrays
    use ancil_info, only: ssi_pts, sea_pts, sice_pts,                      &
         sice_pts_ncat, ssi_index, sea_index, sice_index,                  &
         sice_index_ncat, fssi_ij, sea_frac, sice_frac, sice_frac_ncat
    use atm_fields_bounds_mod, only: atm_fields_bounds_init
    use bl_option_mod, only: i_bl_vn, sbl_op, ritrans,                     &
         cbl_op, lambda_min_nml, l_bl_mix_qcf, local_fa, keep_ri_fa,       &
         sg_orog_mixing, fric_heating, idyndiag,                           &
         zhloc_depth_fac, flux_grad, entr_smooth_dec,                      &
         relax_sc_over_cu, bl_res_inv, blending_option,                    &
         a_ent_shr_nml, alpha_cd, puns, pstb, nl_bl_levels, kprof_cu
    use cloud_inputs_mod, only: i_cld_vn, forced_cu, i_rhcpt, i_cld_area,  &
         l_fixbug_pc2_mixph, rhcrit, cloud_fraction_method,                &
         ice_fraction_method,falliceshear_method, cff_spread_rate,         &
         l_subgrid_qv, ice_width
    use cv_run_mod, only: icvdiag, cvdiag_inv, cvdiag_sh_wtest,            &
         limit_pert_opt, tv1_sd_opt, iconv_congestus, iconv_deep,          &
         ent_fac_dp, cldbase_opt_dp, cldbase_opt_sh, w_cape_limit,         & 
         l_param_conv
    use dyn_coriolis_mod, only: f3_at_u
    use dynamics_input_mod, only: numcycles
    use jules_sea_seaice_mod, only: nice_use, iseasurfalg, emis_sea,       &
         seasalinityfactor, charnock, nice
    use jules_soil_mod, only: dzsoil, dzsoil_io
    use jules_surface_mod, only: l_epot_corr, cor_mo_iter, iscrntdiag,     &
         isrfexcnvgust
    use jules_surface_types_mod, only: nnpft, npft, nnvg, ntype, urban,    &
         lake, soil, ice
    use level_heights_mod, only: r_theta_levels, r_rho_levels, eta_theta_levels
    use model_domain_mod, only: model_type
    use nlsizes_namelist_mod, only: model_levels, bl_levels, row_length,   &
         rows, land_field, ntiles, sm_levels, tr_vars
    use timestep_mod, only: timestep
    use tuning_segments_mod, only: bl_segment_size

    ! LFRic modules
    use field_mod, only : field_type, field_proxy_type
    use timestepping_config_mod, only: dt

    implicit none

    type( field_type ), intent( in ) :: theta_in_wth
    type( field_collection_type ), intent(inout) :: twod_fields
    type( field_proxy_type )  :: theta_in_wth_proxy
    type( field_type ), pointer :: tstar_2d  => null()
    type( field_type ), pointer :: zh_2d => null()
    type( field_type ), pointer :: z0msea_2d => null()
    type( field_type ), pointer :: ntml_2d => null()
    type( field_type ), pointer :: cumulus_2d => null()


    integer(kind=i_def) :: nlayers

    ! loop counters
    integer :: i,j,l

    theta_in_wth_proxy = theta_in_wth%get_proxy()

    tstar_2d => twod_fields%get_field('tstar')
    zh_2d => twod_fields%get_field('zh')
    z0msea_2d => twod_fields%get_field('z0msea')

    ntml_2d => twod_fields%get_field('ntml')
    cumulus_2d => twod_fields%get_field('cumulus')

    ! set up various dimensions for a single column sea point
    nlayers = theta_in_wth_proxy%vspace%get_nlayers()
    model_levels = theta_in_wth_proxy%vspace%get_nlayers()
    bl_levels = nlayers-1
    row_length=1
    rows=1
    land_field=0
    ntiles=1
    sm_levels=1
    nice=1
    nice_use=1
    tr_vars=0


    ! set up array sizes for a single column model
    model_type=5
    call atm_fields_bounds_init( 0_i_um, 0_i_um, 0_i_um, &
                                 0_i_um, row_length, rows,rows,  &
                                 nlayers, bl_levels, nlayers )

    ! allocate jules stuff
    nnpft=5
    npft=5
    nnvg=4
    ntype=9
    urban=6
    lake=7
    soil=8
    ice=9
    call allocate_jules_arrays(land_field,ntiles,sm_levels,nice_use,nice_use)
    dzsoil => dzsoil_io(1:sm_levels)

    ! model timestep
    timestep=dt

    ! BL options
    i_bl_vn=3
    sbl_op=6
    ritrans=0.1
    cbl_op=2
    lambda_min_nml=40.0
    l_bl_mix_qcf=.true.
    local_fa=1
    keep_ri_fa=1
    sg_orog_mixing=0
    fric_heating=1
    idyndiag=4
    zhloc_depth_fac=0.3
    flux_grad=0
    entr_smooth_dec=0
    relax_sc_over_cu=0
    kprof_cu=0
    bl_res_inv=0
    blending_option=0
    a_ent_shr_nml=5.0
    allocate(alpha_cd(bl_levels))
    alpha_cd=1.5
    alpha_cd(1)=2.0
    puns=0.5
    pstb=2.0
    nl_bl_levels=bl_levels

    ! convection options
    icvdiag=1
    cvdiag_inv=0
    cvdiag_sh_wtest=0.02
    limit_pert_opt=2
    tv1_sd_opt=2
    iconv_congestus=0
    iconv_deep=1
    ent_fac_dp=1.13
    cldbase_opt_dp=3
    cldbase_opt_sh=0
    w_cape_limit=0.3
    l_param_conv=.false.

    ! cloud options
    select case (cloud_scheme)
      case(physics_cloud_scheme_none) 
        i_cld_vn=0
      case(physics_cloud_scheme_smith) 
        i_cld_vn=1
      case default
        write( log_scratch_space, '(A,I3)' )  &
          'Invalid cloud scheme option, stopping', cloud_scheme 
        call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end select
    i_rhcpt=0
    forced_cu=0
    i_cld_area=0
    l_fixbug_pc2_mixph=.true.
    cloud_fraction_method=1
    ice_fraction_method=1
    falliceshear_method=2 
    cff_spread_rate=1.0e-3
    l_subgrid_qv=.true.
    ice_width=0.02
    ! set rhcrit to the profile provided in the physics namelist.
    ! rhcrit is used throughout the UM and its value needs setting 
    ! here.
    rhcrit = rhcritical

    ! dynamics options
    numcycles=1

    ! tuning segment sizes
    bl_segment_size=16

    ! jules options
    charnock=0.018
    emis_sea=0.985
    iseasurfalg=1
    seasalinityfactor=0.98
    cor_mo_iter=3
    iscrntdiag=2
    isrfexcnvgust=1
    l_epot_corr=.true.

    ! arrays that should be allocated at startup
    allocate(f3_at_u(row_length,rows))
    allocate(r_theta_levels(row_length,rows,0:nlayers))
    allocate(r_rho_levels(row_length,rows,nlayers))
    allocate(eta_theta_levels(0:nlayers))

    ! BL prognostics - initialise
    call invoke( setval_c(tstar_2d, 300.0_r_def))
    call invoke( setval_c(zh_2d, 1000.0_r_def))
    call invoke( setval_c(z0msea_2d, 1.5e-4_r_def))
    call invoke( setval_c(ntml_2d, 1.0_r_def))
    call invoke( setval_c(cumulus_2d, 0.0_r_def))

    !-----------------------------------------------------------------------
    ! Set up index for sea and sea-ice
    !
    ! This code is copied from atmos_physics1 and has been adapted
    ! for a sea-point only - no land or sea-ice
    !
    ! It will need re-writing!
    !-----------------------------------------------------------------------
    ssi_pts = 0
    ssi_index(:)=0
    DO j=1,rows
      DO i=1,row_length
        ssi_pts=ssi_pts + 1
        ssi_index(ssi_pts) = (j-1)*row_length + i
        fssi_ij(i,j)=1.0
      END DO
    END DO

    !-----------------------------------------------------------------------
    ! Allocate space for and initialise sea and sea-ice indices.
    !-----------------------------------------------------------------------
    sea_pts = 0
    sice_pts = 0
    sea_index(:)=0
    sice_index(:)=0
    sice_frac(:)=0.0
    sea_frac(:)=0.0
    DO l=1,ssi_pts
      j=(ssi_index(l)-1)/row_length + 1
      i = ssi_index(l) - (j-1)*row_length
      IF (ssi_index(l) > 0) THEN
        sea_pts=sea_pts+1
        sea_index(sea_pts)=l
        sea_frac(l)=1.0 - sice_frac(l)
      END IF
    END DO

    ! NOTE these settings use NICE_USE not NICE so are suitable for use here and
    ! in the explicit part of the surface exchange code.  They are then updated
    ! using NICE before the call to the implicit part of the surface exchange
    ! code
    sice_pts_ncat(:)=0
    sice_index_ncat(:,:)=0
    sice_frac_ncat(:,:)=0.0

  end subroutine bl_init

end module bl_init_mod
